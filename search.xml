<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>简单的了解一下递归</title>
      <link href="/posts/3902425944.html/"/>
      <url>/posts/3902425944.html/</url>
      
        <content type="html"><![CDATA[<h1 id="简单的了解一下递归"><a href="#简单的了解一下递归" class="headerlink" title="简单的了解一下递归"></a>简单的了解一下递归</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在编程中，递归大家肯定都不陌生了吧，今天我们来总结总结有关于递归的东西。</p><blockquote><p>什么？！ 你陌生， 去刷题去，完后你就熟了。</p></blockquote><span id="more"></span><h2 id="递归的定义"><a href="#递归的定义" class="headerlink" title="递归的定义"></a>递归的定义</h2><p><strong>程序调用自身的编程技巧称为递归</strong></p><h2 id="递归长什么样子"><a href="#递归长什么样子" class="headerlink" title="递归长什么样子"></a>递归长什么样子</h2><p>提到举例子我们肯定第一个想到的就是阶乘。</p><blockquote><p>n! = n * (n-1) * (n-2) * …* 1(n&gt;0)</p><p>5! = 5 * 4 * 3 * 2 * 1</p></blockquote><p>阶乘是我们从小学数学就接触的东西，没想到它现在还陪伴着我们🙄</p><p>用代码实现一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursion</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> n * recursion(n - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(recursion(<span class="number">5</span>)) <span class="comment">// 5 * 4 * 3 * 2 * 1 = 120</span></span><br></pre></td></tr></table></figure><p>再举一个例子吧，也是我们初高中课本上的，著名的河内塔问题：</p><img src="/posts/3902425944.html/河内塔.png"><p>这个问题也是用递归来解决的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hanoi</span>(<span class="params"> n, p1, p2, p3</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> == n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;盘子从&#x27;</span> + p1 + <span class="string">&#x27;移动到&#x27;</span> + p3);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">hanoi(n-<span class="number">1</span>, p1, p3, p2);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;盘子从&#x27;</span> + p1 + <span class="string">&#x27;移动到&#x27;</span> + p3);</span><br><span class="line">hanoi(n-<span class="number">1</span>, p2, p1, p3);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">hanoi(<span class="number">3</span>,<span class="string">&#x27;p1&#x27;</span>,<span class="string">&#x27;p2&#x27;</span>,<span class="string">&#x27;p3&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/posts/3902425944.html/%E6%B2%B3%E5%86%85%E5%A1%94%E7%BB%93%E6%9E%9C.png"></p><h2 id="总结一哈"><a href="#总结一哈" class="headerlink" title="总结一哈"></a>总结一哈</h2><p>既然要写递归，就要知道它具备什么条件，从上面的例子不难看出，递归是具有边界条件的，阶乘中的<code>n==1</code>和河内塔中的<code>1==n</code>都是边界条件，递归还具有两个部分，边界条件满足的时候进入返回过程，边界条件不满足的时候，再次进入递归过程。</p><p>那么它还具有什么特点呢？</p><ul><li>它必须有一个出口条件，也就是要有一处作为结束，变成非递归的样子处理。</li><li>递归处理的子问题要同原问题一样，并且逐渐变得简单。</li></ul><p>总结一下：<strong>我们写的递归要具有边界条件，和基于边界条件分别做出的两部分处理过程。</strong></p><blockquote><p>并且使用递归是要逐渐使得问题变得简单，最终用非递归的方法作为结尾哦。</p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我觉得，递归是思考过后对于问题提出的一种解决方案。</p><p>在你提出用递归解决的时候，就已经知道他的边界条件是什么了，只需要写出递归的那部分，随后使用非递归的方式作为程序出口即可。</p><blockquote><p>点个赞，一起学习进步吧♥</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法/数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法/数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于promise的使用方法</title>
      <link href="/posts/3499638177.html/"/>
      <url>/posts/3499638177.html/</url>
      
        <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>好几天前就想写一个promise的笔记了，但是一直以来就仅仅知道它是用来解决回调地狱问题的，没有一个详细的了解，所以在这几天学习的时候，针对它名下的几个方法，做了一个简要的使用介绍。</p><blockquote><p>promise：这就是我的说明书！</p><p>我：可能说的不是太全，多包涵~</p></blockquote><span id="more"></span><h2 id="先来了解一下它"><a href="#先来了解一下它" class="headerlink" title="先来了解一下它"></a>先来了解一下它</h2><p>什么是promise？它是一个类？一个对象？一个数组？</p><p>我们先打印它来看一看吧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.dir(<span class="built_in">Promise</span>);</span><br></pre></td></tr></table></figure><img src="/posts/3499638177.html/认识promise.png" style="zoom:60%;"><p>打印完了，我们来正式认识一下它。</p><p><strong>promise</strong>是一个构造函数，是ES6提出的异步编程解决方案，用来解决<strong>回调地狱</strong>这种问题，从打印可以看出，它有<code>reject</code>、<code>all</code>、<code>resolve</code>等方法，它的原型上有<code>catch</code>、<code>then</code>等方法。</p><p><strong>还有一种说法来自于网络：</strong>promise，意为承诺，承诺过一段时间给你结果。promise有三种状态，分别为pending（等待），fulfiled（成功），rejected（失败），状态一旦经过改变，就不会在变。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn1执行，如果a&gt;10 执行fn2 ，如果a == 11，执行fn3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">a, fn2</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">10</span> &amp;&amp; <span class="keyword">typeof</span> fn2 == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    fn2(a,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">11</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;this is fn3&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fn1(<span class="number">11</span>, <span class="function"><span class="keyword">function</span>(<span class="params">a, fn3</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;this is fn2&#x27;</span>)</span><br><span class="line">    fn3()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面说了promise的提出是用来解决回调地狱的问题，那么什么是回调地狱呢？可以参考一下我这段代码，不断的嵌套回调函数之后，代码就会变得非常繁琐，看代码的时候眼睛不舒服，脑子也不舒服，这种嵌套回调非常多的情况，就叫做<strong>回调地狱</strong>。</p><h2 id="如何使用promise"><a href="#如何使用promise" class="headerlink" title="如何使用promise"></a>如何使用promise</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//做一些异步操作</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;执行完成&#x27;</span>);</span><br><span class="line">        resolve(<span class="string">&#x27;写啥都行&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Promise的构造函数接收一个function，并且这个函数需要传入两个参数：</p><ul><li>resolve ：异步操作执行成功后的回调函数</li><li>reject：异步操作执行失败后的回调函数</li></ul><h3 id="then"><a href="#then" class="headerlink" title="then"></a>then</h3><p>还记得上面我写的那个嵌套非常多的例子吗？啊，不记得，那你翻一翻~</p><p>Promise的优势就在于，可以在<code>then</code>方法中继续写Promise对象并返回，然后继续调用then来进行回调操作。</p><p>所以，从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。所以使用Promise的正确场景是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//做一些异步操作</span></span><br><span class="line">       resolve(a);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;            </span><br><span class="line">&#125;</span><br><span class="line">fn1(<span class="number">11</span>)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">10</span>)&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;a大于10&#x27;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   resolve(a);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">11</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a等于11&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>我将上面那个改写了一下。最后那个没有return出来是我后面没有继续then了。</p></blockquote><p>这其实就是链式写法。then就相当于我们之前的callback。</p><p>then方法中，不光可以return promise对象，也可以return数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//做一些异步操作</span></span><br><span class="line">       resolve(a);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;            </span><br><span class="line">&#125;</span><br><span class="line">fn1(<span class="number">11</span>)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">10</span>)&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;a大于10&#x27;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> a</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">11</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a等于11&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h3><p>把promise的状态从<code>pending</code>改成<code>rejected</code>，之后我们就可以在<code>then</code>中执行失败情况的回调，来看这个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(a&gt;<span class="number">10</span>)&#123;</span><br><span class="line">       resolve(a);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">       reject(a);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;            </span><br><span class="line">&#125;</span><br><span class="line">fn1(<span class="number">9</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a大于10&#x27;</span>)</span><br><span class="line">&#125;,<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a小于10&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>then可以接收两个参数，分别对应着resolve的回调和reject的回调，所以在调整传入的a的值，我们可以得到两个结果。</strong></p><blockquote><p>即a大于10和a小于10</p></blockquote><h3 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h3><p>对其他语言有了解的人应该可以知道，catch是用来抓取异常的，那么在promise里，它的作用也一样，<strong>它就如同then的第二个参数，对应着reject的回调</strong></p><p>写法是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.then(<span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a大于10&#x27;</span>)</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a小于10&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>效果和写在then的第二个参数里面是一样的。</p><p>不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死进程，而是会进到这个catch方法中。</p><blockquote><p>就很像 try catch </p></blockquote><p>再来看这段代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//做一些异步操作</span></span><br><span class="line">       resolve(a);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;            </span><br><span class="line">&#125;</span><br><span class="line">fn1(<span class="number">11</span>)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">10</span>)&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;a大于10&#x27;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> b</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;发生了错误:&#x27;</span> + err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这段代码中 本来想return a的 结果写成了b，正常来说浏览器会报错，不会向下执行了，在我们用了catch后，</p><p>浏览器会打印出<strong>a大于10</strong>和<strong>发生了错误:ReferenceError: b is not defined</strong>。</p><p>也就是说即使是上面出错了，还是进到catch方法里面去了，而且把错误原因传到了err参数中，使得程序继续执行下去。</p><h3 id="all"><a href="#all" class="headerlink" title="all"></a>all</h3><p>all方法提供了多个任务并行，执行异步操作的能力，并且在所有异步操作执行完后才执行回调。</p><ul><li>all方法接收的参数是一个数组，其中每个对象都是promise</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.all([fn1, fn2, fn3])</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="title">funciton</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 三个都成功则成功  </span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 只要有一个失败，则失败 </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>有了all，我们就可以并行执行多个异步操作，有一个场景是很适合用这个的，打开一个网页，需要加载各类资源，所有的都加载完后，我们再进行页面的初始化。</p><h3 id="race"><a href="#race" class="headerlink" title="race"></a>race</h3><p>all方法的效果实际上是<strong>谁跑的慢，以谁为准执行回调</strong>，那么相对的就有另一个方法<strong>谁跑的快，以谁为准执行回调</strong>，这就是race方法，这个词本来就是赛跑的意思。</p><p>拿上面的fn123举例子，假如他们分别是1、2、3秒执行完，那么在第一秒结束的时候就会输出fn1执行后的结果，在两秒跟三秒的时候会分别输出fn2、fn3的结果。</p><p>这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作。</p><p>例如图片请求，我们将一个延迟请求（假如是3秒）跟图片请求同时使用race方法调用，在3秒的时候如果请求成功了，就会resolve进入then方法，如果失败了就会进入catch方法输出图片资源请求失败的错误。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>十一的假期结束了，上学人又要继续上课了，害。</p><blockquote><p>点个赞，一起努力进步吧♥</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用那么久this了，来详细了解一下</title>
      <link href="/posts/724479206.html/"/>
      <url>/posts/724479206.html/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>this想必大家都很不陌生了，在例如<code>Vue.js</code>中，各种this，唰唰唰的写，但是有没有遇到this指向出错的问题呢？</p><p>我有，我猜应该也会有人跟我一样。</p><p>所以，我总结了一些this的基础概念和基本使用在这里，供大家参考。</p><span id="more"></span><h2 id="this出现在哪里"><a href="#this出现在哪里" class="headerlink" title="this出现在哪里"></a>this出现在哪里</h2><p><strong>全局上下文中的this</strong></p><p>console.log(this)来打印出来全局执行上下文中的 this，最终输出的是 window 对象。</p><p>所以可以得出这样一个结论：全局执行上下文中的 this 是指向 window 对象的。这也是 this 和作用域链的唯一交点，作用域链的最底端包含了 window 对象，全局执行上下文中的 this 也是指向 window 对象</p><p><strong>函数上下文中的this</strong></p><p>在全局环境中调用一个函数，函数内部的 this 指向的是全局变量 window。</p><p>通过一个对象来调用其内部的一个方法，该方法的执行上下文中的 this 指向对象本身</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;;</span><br><span class="line">foo(); <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line"><span class="attr">b</span>:<span class="number">0</span>,</span><br><span class="line"><span class="attr">fn</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a.fn(); <span class="comment">//&#123; b:0, fn:f() &#125;</span></span><br></pre></td></tr></table></figure><h2 id="this指向总结"><a href="#this指向总结" class="headerlink" title="this指向总结"></a>this指向总结</h2><ul><li><p>当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window；</p></li><li><p>通过一个对象来调用其内部的一个方法，该方法的执行上下文中的 this 指向对象本身</p></li><li><p>ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数</p></li><li><p>new 关键字构建好了一个新对象，并且构造函数中的 this 其实就是新对象本身</p></li><li><p>嵌套函数中的 this 不会继承外层函数的 this 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123; </span><br><span class="line"><span class="attr">name</span> : <span class="string">&quot;Ned&quot;</span>, </span><br><span class="line"><span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// myObj</span></span><br><span class="line">        <span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;阿泽&quot;</span>; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// window</span></span><br><span class="line">        &#125; </span><br><span class="line">        bar(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">myObj.showThis();</span><br><span class="line"><span class="built_in">console</span>.log(myObj.name); <span class="comment">// Ned</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">// 阿泽</span></span><br></pre></td></tr></table></figure><ul><li><p>解决this不继承的方法</p><ul><li>内部函数使用箭头函数</li><li>将在外层函数中创建一个变量，用来存储this，内层函数通过作用域链即可访问</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123; </span><br><span class="line"><span class="attr">name</span> : <span class="string">&quot;Ned&quot;</span>, </span><br><span class="line"><span class="attr">showThis</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// myObj</span></span><br><span class="line">        <span class="keyword">var</span> bar = <span class="function">()=&gt;</span>&#123; </span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;阿泽&quot;</span>; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// window</span></span><br><span class="line">        &#125; </span><br><span class="line">        bar(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">myObj.showThis();</span><br><span class="line"><span class="built_in">console</span>.log(myObj.name); <span class="comment">// 阿泽</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">//  </span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123; </span><br><span class="line"><span class="attr">name</span> : <span class="string">&quot;Ned&quot;</span>, </span><br><span class="line"><span class="attr">showThis</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// myObj</span></span><br><span class="line">        <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; </span><br><span class="line">        self.name = <span class="string">&quot;阿泽&quot;</span>; </span><br><span class="line">        <span class="built_in">console</span>.log(self) <span class="comment">// window</span></span><br><span class="line">        &#125; </span><br><span class="line">        bar(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">myObj.showThis();</span><br><span class="line"><span class="built_in">console</span>.log(myObj.name); <span class="comment">// 阿泽</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">// </span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="改变this指向的方法"><a href="#改变this指向的方法" class="headerlink" title="改变this指向的方法"></a>改变this指向的方法</h2><h3 id="call-和-apply-的共同点"><a href="#call-和-apply-的共同点" class="headerlink" title="call 和 apply 的共同点"></a>call 和 apply 的共同点</h3><p>都能够<strong>改变函数执行时的上下文</strong>，将一个对象的方法交给另一个对象来执行，并且是立即执行的</p><blockquote><p><strong>调用 call 和 apply 的对象，必须是一个函数 Function</strong></p></blockquote><h3 id="call-和-apply-的区别"><a href="#call-和-apply-的区别" class="headerlink" title="call 和 apply 的区别"></a>call 和 apply 的区别</h3><h4 id="call-的写法"><a href="#call-的写法" class="headerlink" title="call 的写法"></a>call 的写法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.call(obj,param1,param2,...)</span><br></pre></td></tr></table></figure><p>需要注意以下几点：</p><ul><li>调用 call 的对象，必须是个函数 Function。</li><li>call 的第一个参数，是一个对象。 Function 的调用者，将会指向这个对象。如果不传，则默认为全局对象 window。</li><li>第二个参数开始，可以接收任意个参数。每个参数会映射到相应位置的 Function 的参数上。但是如果将所有的参数作为数组传入，它们会作为一个整体映射到 Function 对应的第一个参数上，之后参数都为空。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span> (<span class="params">a,b,c</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">func.call(obj, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">// func 接收到的参数实际上是 1,2,3</span></span><br><span class="line"></span><br><span class="line">func.call(obj, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment">// func 接收到的参数实际上是 [1,2,3],undefined,undefined</span></span><br><span class="line"><span class="comment">// 其实func还是接收了三个参数，只不过咱们只传了一个过去，这个应该很容易理解的</span></span><br></pre></td></tr></table></figure><h4 id="apply-的写法"><a href="#apply-的写法" class="headerlink" title="apply 的写法"></a>apply 的写法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function.apply(obj[,argArray])</span><br></pre></td></tr></table></figure><p><strong>需要注意的是：</strong></p><ul><li>它的调用者必须是函数 Function，并且只接收两个参数，第一个参数的规则与 call 一致。</li><li>第二个参数，必须是数组或者类数组，它们会被转换成类数组，传入 Function 中，并且会被映射到 Function 对应的参数上。这也是 call 和 apply 之间，很重要的一个区别。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func.apply(obj, [1,2,3])</span><br><span class="line">// func 接收到的参数实际上是 1,2,3</span><br><span class="line"></span><br><span class="line">func.apply(obj, &#123;</span><br><span class="line">    0: 1,</span><br><span class="line">    1: 2,</span><br><span class="line">    2: 3,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;)</span><br><span class="line">// func 接收到的参数实际上是 1,2,3</span><br></pre></td></tr></table></figure><h3 id="call-和-apply-的用途"><a href="#call-和-apply-的用途" class="headerlink" title="call 和 apply 的用途"></a>call 和 apply 的用途</h3><p>下面会分别列举 call 和 apply 的一些使用场景。</p><blockquote><p>声明：例子中没有哪个场景是必须用 call 或者必须用 apply 的，看个人习惯就好。</p></blockquote><h4 id="call-的使用场景"><a href="#call-的使用场景" class="headerlink" title="call 的使用场景"></a>call 的使用场景</h4><p><strong>对象的继承</strong>如下面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">superClass</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subClass</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    superClass.call(<span class="built_in">this</span>);  <span class="comment">// 执行superClass，并将superClass方法中的this指向subClass</span></span><br><span class="line">    <span class="built_in">this</span>.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subClass();</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>subClass 通过 call 方法，继承了 superClass 的 print 方法和 a 变量。</p><p>此外，subClass 还可以扩展自己的其他方法。</p><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><h4 id="bind-的用法"><a href="#bind-的用法" class="headerlink" title="bind 的用法"></a>bind 的用法</h4><p>在 MDN 上的解释是：bind() 方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。</p><p>它的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function.bind(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure><p>bind 方法 与 apply 和 call 比较类似，也能改变函数体内的 this 指向。</p><p>不同的是，<strong>bind 方法的返回值是函数，并且需要稍后调用，才会执行</strong>。</p><p>而 apply 和 call 则是立即调用，来看下面这个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function add (c) &#123;</span><br><span class="line">    return this.a + this.b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;a:1,b:2&#125;</span><br><span class="line"></span><br><span class="line">add.bind(obj, 5); // 这时，并不会返回 8</span><br><span class="line">add.bind(sub, 5)(); // 调用后，返回 8</span><br></pre></td></tr></table></figure><p>如果 bind 的第一个参数是 null 或者 undefined，this 就指向全局对象 window。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>“abc”的使用，具体还是要看个人运用，理解了之后，那它们就变成了工具，怎么顺手怎么来了~</p><p>顺便说一下本人，我还是喜欢apply多一点hhh，用它的次数多一点，所以在场景用谁都行的时候，我一般都会选择apply。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全 | XSS基础知识</title>
      <link href="/posts/1710773078.html/"/>
      <url>/posts/1710773078.html/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天又到了我最喜欢的东西，一些网络安全有关的东西。</p><blockquote><p>小时候就特别喜欢黑客，觉得特帅~ </p><p>大学报计算机相关专业可能也是这方面的原因，但是阴差阳错，没有走网络安全的方向。</p></blockquote><p>今天来说一说，XSS攻击的事情，我有幸，曾经用php搭建的博客（typecho），被我同学挂了脚本，xss了一下，完后，什么什么的，啊，你们懂得。</p><p>从那以后，我就知道，网络安全，是不可避免的，是一定要考虑到的，是一定要去了解的东西。</p><blockquote><p>身处网络时代，谁又能置身事外！</p></blockquote><span id="more"></span><h3 id="什么是xss攻击？"><a href="#什么是xss攻击？" class="headerlink" title="什么是xss攻击？"></a>什么是xss攻击？</h3><p>XSS又叫CSS（Cross Site Script），跨站脚本攻击：指恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。</p><img src="/posts/1710773078.html/image-20210617162454870.png" alt="image-20210617162454870" style="zoom: 33%;"><p>那么，当当前的网页弹出1的时候，我们就知道，这个网页是可以执行js脚本的了，那么我们是不是就可以通过document去盗取一些信息，来帮助我们<strong>更进一步</strong>的去潜入进去呢？例如盗取一下cookie等。</p><p><strong>先来看一下XSS有几种吧</strong>：</p><ul><li><strong>持久型</strong>：一些可以提交的地方，文章评论，个人信息填写等，如果没有加过滤的话，嵌入的脚本就会被提交到服务器上，之后用户每次访问都会触发脚本（例如图中的alert(1)，每个用户打开都会弹出1）</li><li><strong>非持久型</strong>：反射型跨站脚本漏洞，是最普遍的类型。大多是链接的方式，需要用户点击，才能返回脚本进行操作（用户访问服务器–&gt;点击跨站链接—&gt;返回脚本代码）</li><li><strong>DOM型</strong>：客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM XSS漏洞（很少见emm，反正我没见过hhh，日后见到了来补上，再细说）</li></ul><h3 id="XSS可能会带来的危害"><a href="#XSS可能会带来的危害" class="headerlink" title="XSS可能会带来的危害"></a>XSS可能会带来的危害</h3><p><strong>使网页无法正常运行</strong>：这个就是我们上面中图示的内容，如果不仅仅是一个<code>alert(1)</code>呢？外部来一个永久循环，这个网页的弹窗就会永远关不掉，导致无法正常的实现整体业务流程。</p><p><strong>获取cookie信息</strong>：这个我们也在上文中说过，如果网页上可以执行js脚本的话，那么我们是可以通过<code>document.cookie</code>来实现获取用户cookie的。</p><blockquote><p>试想下如果像QQ空间说说中能够写入xss攻击语句，那岂不是看了你说说的人的号你都可以登录</p><p>一个字：爽~</p></blockquote><p><strong>劫持流量恶意跳转</strong>：</p><p>像这样，在网页中想办法插入一句像这样的语句，访问的网页就会直接跳转到百度去。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">window</span>.location.href=<span class="string">&quot;http://www.baidu.com&quot;</span>;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="XSS的攻击应该具备这样的条件"><a href="#XSS的攻击应该具备这样的条件" class="headerlink" title="XSS的攻击应该具备这样的条件"></a>XSS的攻击应该具备这样的条件</h3><p>网页内部有输入框，内容可存储在服务器上</p><p>输入框内的内容，才能被<strong>提交</strong>到他的服务器上，才能改变这个网页内部的文件内容。</p><blockquote><p>前提是这个输入，没有被过滤，才会成功哦！</p><p>可以自己写demo尝试一下，不建议直接在网络上开搞emm，自己玩玩就行哈~</p></blockquote><h3 id="XSS防御措施（对用户输入内容和服务端返回内容进行过滤和转译）"><a href="#XSS防御措施（对用户输入内容和服务端返回内容进行过滤和转译）" class="headerlink" title="XSS防御措施（对用户输入内容和服务端返回内容进行过滤和转译）"></a><strong>XSS防御措施（对用户输入内容和服务端返回内容进行过滤和转译）</strong></h3><p><strong>现代大部分浏览器都自带 XSS 筛选器</strong>（vue/react等主流框架已经避免类似问题，vue举例：不能在template中写script标签，无法在js中通过ref或append等方式动态改变或添加script标签）</p><p><strong>过滤</strong>，对诸如<strong>script</strong>、<strong>img</strong>、<strong>a</strong>等标签进行过滤。</p><p><strong>编码</strong>，像一些常见的符号，如&lt;&gt;在输入的时候要对其进行转换编码，这样做浏览器是不会对该标签进行解释执行的，同时也不影响显示效果。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>学习网络安全是为了保护好自己，在这个网络时代，避免自己的信息被不法分子盗取，而不是说我们学会如何去<strong>攻击别人</strong>。</p><blockquote><p> 还有更多的网络安全知识等着我们去学习呢，冲！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的继承，原型和原型链</title>
      <link href="/posts/2566346867.html/"/>
      <url>/posts/2566346867.html/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想必，学过 java 和 C++ 的小伙伴们，对于继承这个词应该不陌生，最近我也是一直在巩固JavaScript的知识，今天就来一起学习一下JavaScript里的继承吧。</p><span id="more"></span><h2 id="继承是什么？"><a href="#继承是什么？" class="headerlink" title="继承是什么？"></a>继承是什么？</h2><p>首先我们要明确继承的概念：</p><p><strong>继承就是一个对象可以访问另外一个对象中的属性和方法</strong></p><img src="/posts/2566346867.html/01.png" alt="image-20210617142202137" style="zoom: 50%;"><p>B继承了A，所以B也有A具有的<code>color</code>属性，这个是不是我们接触CSS的时候，会有样式继承这个东西，可以这么理解一下下~</p><h2 id="继承的目的？"><a href="#继承的目的？" class="headerlink" title="继承的目的？"></a>继承的目的？</h2><p>继承的目的我觉得殊途同归，都是实现了父类的设计，并且进行代码复用。</p><h2 id="继承的方式"><a href="#继承的方式" class="headerlink" title="继承的方式"></a>继承的方式</h2><p>java、c++等：java是通过<code>class</code>类，C++是通过<code>:</code></p><p>而我们的JavaScript，是通过<strong>原型链</strong> ，ES2015/ES6 中引入了 class 关键字，但那只是语法糖，JavaScript 的继承依然和基于类的继承没有一点关系。</p><h2 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h2><p><strong>JavaScript 只有一种结构：对象。</strong></p><p>JavaScript 的每个对象都包含了一个隐藏属性__proto__，我们就把该隐藏属性 <strong>proto</strong> 称之为该<strong>对象的原型</strong> (prototype)，<strong>proto</strong> 指向了内存中的另外一个对象，我们就把 <strong>proto</strong> 指向的对象称为该<strong>对象的原型</strong>，那么该对象就可以直接访问其原型对象的方法或者属性。</p><p><img src="/posts/2566346867.html/02.png" alt="image-20210617143041487"></p><p>我们可以看到使用 C.name 和 C.color 时，给人的感觉属性 <code>name</code> 和 <code>color</code> 都是对象 C 本身的属性，但实际上这些属性都是位于原型对象上，我们把这个查找属性的路径称为<strong>原型链</strong></p><p>每个实例对象（ <strong>object</strong> ）都有一个私有属性（称之为 <strong>proto</strong> ）指向它的构造函数的原型对象（<strong>prototype</strong> ）。该原型对象也有一个自己的原型对象( <strong>proto</strong> ) ，层层向上直到一个对象的原型对象为 <code>null</code>。根据定义，<code>null</code> 没有原型，并作为这个<strong>原型链</strong>中的最后一个环节。</p><blockquote><p>查到到null，证明链子到头啦~</p></blockquote><p>总结一下：<strong>继承</strong>就是一个对象可以访问另外一个对象中的属性和方法，在JavaScript 中，我们通过<strong>原型和原型链</strong>的方式来实现了继承特性。</p><h2 id="继承的方式-1"><a href="#继承的方式-1" class="headerlink" title="继承的方式"></a>继承的方式</h2><h3 id="构造函数如何创建对象"><a href="#构造函数如何创建对象" class="headerlink" title="构造函数如何创建对象"></a>构造函数如何创建对象</h3><blockquote><p>有一点java基础的看这块会不会特别得劲~，我当初是学过java之后接触到的这个概念，就很顺利的就理解了。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DogFactory</span>(<span class="params">type, color</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">    <span class="built_in">this</span>.color = color</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> DogFactory(<span class="string">&#x27;Dog&#x27;</span>,<span class="string">&#x27;Black&#x27;</span>)</span><br></pre></td></tr></table></figure><p>创建实例的过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dog = &#123;&#125;;</span><br><span class="line">dog.__proto__ = DogFactory.prototype;</span><br><span class="line">DogFactory.call(dog,<span class="string">&#x27;Dog&#x27;</span>,<span class="string">&#x27;Black&#x27;</span>);</span><br></pre></td></tr></table></figure><img src="/posts/2566346867.html/03.png" alt="image-20210617153157853" style="zoom: 33%;"><p>观察这个图，我们可以看到执行流程分为三步：</p><ul><li><p><strong>首先，创建了一个空白对象 dog；</strong></p></li><li><p><strong>然后，将 DogFactory 的 prototype 属性设置为 dog 的原型对象，这就是给 dog 对象设置原型对象的关键一步；</strong></p></li><li><p><strong>最后，再使用 dog 来调用 DogFactory，这时候 DogFactory 函数中的 this 就指向了对象 dog，然后在 DogFactory 函数中，利用 this 对对象 dog 执行属性填充操作，最终就创建了对象 dog。</strong></p></li></ul><blockquote><p>每个函数对象中都有一个公开的 prototype 属性，当你将这个函数作为构造函数来创建一个新的对象时，新创建对象的原型对象就指向了该函数的 prototype 属性，所以通过该构造函数创建的任何实例都可以通过原型链找到构造函数的prototype上的属性</p></blockquote><p><strong>实例的proto属性 ==  构造函数的proyotype</strong></p><p>也就是说<strong>dog.__proto == DogFactory.prototype</strong></p><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p><strong>原理：</strong> 实现的本质是<strong>将子类的原型指向了父类的实例</strong></p><p><strong>优点：</strong></p><ul><li>父类新增原型方法/原型属性，子类都能访问到</li><li>简单容易实现</li></ul><p><strong>缺点：</strong></p><ul><li>不能实现多重继承</li><li>来自原型对象的所有属性被所有实例共享</li><li>创建子类实例时，无法向父类构造函数传参</li></ul><img src="/posts/2566346867.html/image-20210617154553631.png" alt="image-20210617154553631" style="zoom:50%;"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name,</span><br><span class="line">    <span class="built_in">this</span>.age = age,</span><br><span class="line">    <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="built_in">this</span>.setName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"><span class="comment">//子类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.price = price</span><br><span class="line">    <span class="built_in">this</span>.setScore = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person(<span class="string">&#x27;wang&#x27;</span>,<span class="number">23</span>) <span class="comment">// 子类型的原型为父类型的一个实例对象</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Student(<span class="number">15000</span>)</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> Student(<span class="number">14000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1,s2)</span><br></pre></td></tr></table></figure><h3 id="借用构造函数实现继承"><a href="#借用构造函数实现继承" class="headerlink" title="借用构造函数实现继承"></a>借用构造函数实现继承</h3><p><strong>原理</strong>：在子类型构造函数中通用call()调用父类型构造函数</p><p><strong>特点</strong>：</p><ul><li>解决了原型链继承中子类实例共享父类引用属性的问题</li><li>创建子类实例时，可以向父类传递参数</li><li>可以实现多重继承(call多个父类对象)</li></ul><p><strong>缺点</strong>：</p><ul><li>实例并不是父类的实例，只是子类的实例</li><li>只能继承父类的实例属性和方法，不能继承父类原型属性和方法</li><li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name,</span><br><span class="line">    <span class="built_in">this</span>.age = age,</span><br><span class="line">    <span class="built_in">this</span>.setName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Person.prototype.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="built_in">this</span>, name, age) </span><br><span class="line">    <span class="comment">// 相当于: </span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    this.Person(name, age)</span></span><br><span class="line"><span class="comment">    this.name = name</span></span><br><span class="line"><span class="comment">    this.age = age*/</span></span><br><span class="line">    <span class="built_in">this</span>.price = price</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> s1 = <span class="keyword">new</span> Student(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">20</span>, <span class="number">15000</span>)</span><br></pre></td></tr></table></figure><h3 id="原型链-借用构造函数的组合继承"><a href="#原型链-借用构造函数的组合继承" class="headerlink" title="原型链+借用构造函数的组合继承"></a>原型链+借用构造函数的组合继承</h3><p><strong>原理</strong>：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用。</p><p><strong>优点</strong>：</p><ul><li>可以继承实例属性/方法，也可以继承原型属性/方法</li><li>不存在引用属性共享问题</li><li>可传参</li><li>父类原型上的函数可复用</li></ul><p><strong>缺点</strong>：</p><ul><li>调用了两次父类构造函数，生成了两份实例</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name,</span><br><span class="line">    <span class="built_in">this</span>.age = age,</span><br><span class="line">    <span class="built_in">this</span>.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="built_in">this</span>,name,age)</span><br><span class="line">    <span class="built_in">this</span>.price = price</span><br><span class="line">    <span class="built_in">this</span>.setScore = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person()</span><br><span class="line">Student.prototype.constructor = Student<span class="comment">//组合继承也是需要修复构造函数指向的</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Student(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">20</span>, <span class="number">15000</span>)</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> Student(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">22</span>, <span class="number">14000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1)</span><br><span class="line"><span class="built_in">console</span>.log(s1.constructor) <span class="comment">//Student</span></span><br></pre></td></tr></table></figure><h3 id="ES6-class继承"><a href="#ES6-class继承" class="headerlink" title="ES6 class继承"></a>ES6 class继承</h3><p><strong>原理：</strong> ES6中引入了class关键字，class可以通过extends关键字实现继承，还可以通过static关键字定义类的静态方法,这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p><blockquote><p>我当时第一次见的时候，还以为是java</p><p>其实我还是觉得，class写起来得劲多了，哈哈哈</p></blockquote><p><strong>优点</strong>：</p><ul><li>语法简单易懂,操作更方便</li></ul><p><strong>缺点</strong>：</p><ul><li>并不是所有的浏览器都支持class关键字</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用类的构造方法</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">        <span class="built_in">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一般的方法</span></span><br><span class="line">    <span class="function"><span class="title">showName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;调用父类的方法&quot;</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name, <span class="built_in">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span>  Person(<span class="string">&#x27;kobe&#x27;</span>, <span class="number">39</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1)</span><br><span class="line"><span class="comment">//定义一个子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, age, salary</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age)<span class="comment">//通过super调用父类的构造方法</span></span><br><span class="line">        <span class="built_in">this</span>.salary = salary</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">showName</span>(<span class="params"></span>)</span> &#123;<span class="comment">//在子类自身定义方法</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;调用子类的方法&quot;</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name, <span class="built_in">this</span>.age, <span class="built_in">this</span>.salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> Student(<span class="string">&#x27;wade&#x27;</span>, <span class="number">38</span>, <span class="number">1000000000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1)</span><br><span class="line">s1.showName()</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>其实我没有在平时写的项目中，用过继承，所以不太懂具体的应用场景，希望大佬们可以指点一下。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学会这些，再也不怕水平垂直居中了</title>
      <link href="/posts/4281072405.html/"/>
      <url>/posts/4281072405.html/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天来看看一个之前困扰我很久的问题，在CSS中，水平垂直居中，能有几种写法。</p><h2 id="方法一：margin-auto"><a href="#方法一：margin-auto" class="headerlink" title="方法一：margin:auto"></a>方法一：margin:auto</h2><p>子绝父相，当元素绝对定位的时候，会根据最近父元素进行定位，利用这个特性，我们有了这种方法。</p><span id="more"></span><p>CSS代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTML代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;avatar.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果图：</p><img src="/posts/4281072405.html/marginauto.png" style="zoom:60%;"><h2 id="方法二：flex弹性盒子法"><a href="#方法二：flex弹性盒子法" class="headerlink" title="方法二：flex弹性盒子法"></a>方法二：flex弹性盒子法</h2><p>利用flex，<code>align-items:center</code>是控制垂直方向居中，<code>justify-content:center</code>是控制水平方向的居中。</p><p>CSS代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTML代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;avatar.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果图：</p><img src="/posts/4281072405.html/marginauto.png" style="zoom:60%;"><h2 id="方法三：margin-负数法"><a href="#方法三：margin-负数法" class="headerlink" title="方法三：margin:负数法"></a>方法三：margin:负数法</h2><p>margin可以为负数是我在牛客上报了个课之后才学到的，在那之前一直没有试过。</p><p>道理其实跟方法一差不多，通过百分比将图片移动到容器中心，再对齐中心点就行了。</p><p>要记住margin如果是负数的话就是向该方向移动，例如margin-left:-100px;，就是向左移动100px。它与正常添加margin是撑开正好相反。</p><blockquote><p>还不明白可以去写个小demo就懂啦。</p></blockquote><p>CSS代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTML代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;avatar.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果图：</p><img src="/posts/4281072405.html/marginauto.png" style="zoom:60%;"><h2 id="方法四：table-cell法"><a href="#方法四：table-cell法" class="headerlink" title="方法四：table-cell法"></a>方法四：table-cell法</h2><p>这应该算是很老的方法了吧，我没有这么写过。是在百度上搜索得到的结果，完后尝试写了一下。</p><blockquote><p>有个问题，因为按照理解，我觉得img里不加那个应该也是居中的，但是我加了之后在浏览器调试发现，他向上偏移了一些肉眼大概数不出来的距离，在img里加上之后才消失，不知道为什么，希望有大佬可以告知。</p></blockquote><p>CSS代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">   <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTML代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;avatar.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果图：</p><img src="/posts/4281072405.html/marginauto.png" style="zoom:60%;"><h2 id="方法五：translate-50-50"><a href="#方法五：translate-50-50" class="headerlink" title="方法五：translate(-50%,-50%)"></a>方法五：translate(-50%,-50%)</h2><p>translate()函数可以将元素向指定的方向移动，我们可以利用它来做成与方法三相同的事情。</p><p>CSS代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">   <span class="attribute">position</span>: absolute;</span><br><span class="line">   <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">   <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">   <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTML代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;avatar.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果图：</p><img src="/posts/4281072405.html/marginauto.png" style="zoom:60%;"><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>说一下我自己的感受吧，这一共是五种方法，我用过1、2、3、5，其中2和5我用的较多，又以2为最多。</p><p>日后如果见到还有别的，也会记录在此的。</p>]]></content>
      
      
      <categories>
          
          <category> Css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Node.js做一个本地的石头剪刀布游戏</title>
      <link href="/posts/2316163776.html/"/>
      <url>/posts/2316163776.html/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前一段日子学了个石头剪刀布游戏，自己在本地进行了实现，想挂在自己服务器上让他形成一个外网可访问的游戏的时候，出了问题，是接口请求路径不对的问题，现在还不知道什么原因，等解决之后我还会更一下。</p><span id="more"></span><h3 id="所需要准备的"><a href="#所需要准备的" class="headerlink" title="所需要准备的"></a>所需要准备的</h3><ul><li>Node.js环境（没有的可以去官网下一下，傻瓜式安装就好）</li><li>基础的html、css、js能力</li><li>入门级的Node.js就好（因为我也是这个级别）</li><li>一个你熟悉的代码编写工具</li></ul><h3 id="开始上手操作"><a href="#开始上手操作" class="headerlink" title="开始上手操作"></a>开始上手操作</h3><p>首先我们需要一个html页面来作游戏结果的返回以及玩家操作。</p><p><strong>需求分析：</strong></p><ul><li>我们需要一个地方来做游戏结果的返回</li><li>还需要三个按钮来给用户做操作交互</li></ul><p>下面来看<code>index.html</code>文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;output&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 400px; width: 600px; background: #eee&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;rock&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 40px; width: 80px&quot;</span>&gt;</span>石头<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;scissor&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 40px; width: 80px&quot;</span>&gt;</span>剪刀<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;paper&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 40px; width: 80px&quot;</span>&gt;</span>布<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我定义了一个<code>div</code>，来作为显示游戏结果的地方，定义了三个按钮，分别代表剪刀、石头、布。</p><p>接下来我们应该做的就是通过接口的方式，提交我们用户的操作并且获取游戏结果，将他显示在刚刚的<code>div</code>里。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $button = &#123;</span><br><span class="line">        <span class="attr">rock</span>: <span class="built_in">document</span>.getElementById(<span class="string">&#x27;rock&#x27;</span>),</span><br><span class="line">        <span class="attr">scissor</span>: <span class="built_in">document</span>.getElementById(<span class="string">&#x27;scissor&#x27;</span>),</span><br><span class="line">        <span class="attr">paper</span>: <span class="built_in">document</span>.getElementById(<span class="string">&#x27;paper&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> $output = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;output&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys($button).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    $button[key].addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        fetch(<span class="string">`http://<span class="subst">$&#123;location.host&#125;</span>/game?action=<span class="subst">$&#123;key&#125;</span>`</span>)</span><br><span class="line">            .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> res.text()</span><br><span class="line">            &#125;)</span><br><span class="line">            .then(<span class="function">(<span class="params">text</span>) =&gt;</span> &#123;</span><br><span class="line">                $output.innerHTML += text + <span class="string">&#x27;&lt;br/&gt;&#x27;</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>之后我们去建立一个<code>game.js</code>文件，写一下游戏的判断逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">palyerAction</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>([<span class="string">&#x27;rock&#x27;</span>,<span class="string">&#x27;scissor&#x27;</span>,<span class="string">&#x27;paper&#x27;</span>].indexOf(palyerAction) == -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;invalid playerAction&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算出电脑出的结果</span></span><br><span class="line">    <span class="keyword">var</span> computerAction;</span><br><span class="line">    <span class="keyword">var</span> random = <span class="built_in">Math</span>.random() * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(random &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        computerAction = <span class="string">&quot;rock&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(random &gt; <span class="number">2</span>)&#123;</span><br><span class="line">        computerAction = <span class="string">&quot;scissor&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        computerAction = <span class="string">&quot;paper&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(computerAction == palyerAction)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(</span><br><span class="line">        (computerAction == <span class="string">&quot;rock&quot;</span> &amp;&amp; palyerAction == <span class="string">&quot;scissor&quot;</span>) ||</span><br><span class="line">        (computerAction == <span class="string">&quot;scissor&quot;</span> &amp;&amp; palyerAction == <span class="string">&quot;paper&quot;</span>) ||</span><br><span class="line">        (computerAction == <span class="string">&quot;paper&quot;</span> &amp;&amp; palyerAction == <span class="string">&quot;rock&quot;</span>)</span><br><span class="line">    )&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致的逻辑很简单，通过随机数让电脑出拳，之后判断胜负并返回。</p><p>下面看一下用<code>node.js</code>写的简单交互的地方：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> game = <span class="built_in">require</span>(<span class="string">&#x27;./game&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> playerWon = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> playerLastAction = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> sameCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">http</span><br><span class="line">    .createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> parsedUrl = url.parse(request.url);</span><br><span class="line">        <span class="keyword">if</span> (parsedUrl.pathname == <span class="string">&#x27;/favicon.ico&#x27;</span>) &#123;</span><br><span class="line">            response.writeHead(<span class="number">200</span>);</span><br><span class="line">            response.end();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parsedUrl.pathname == <span class="string">&#x27;/game&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> query = querystring.parse(parsedUrl.query);</span><br><span class="line">            <span class="keyword">const</span> playerAction = query.action;</span><br><span class="line">            <span class="keyword">if</span> (playerWon &gt;= <span class="number">3</span> || sameCount == <span class="number">9</span>) &#123;</span><br><span class="line">                response.writeHead(<span class="number">500</span>);</span><br><span class="line">                response.end(<span class="string">&#x27;我再也不和你玩了！&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (playerLastAction &amp;&amp; playerAction == playerLastAction) &#123;</span><br><span class="line">                sameCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sameCount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            playerLastAction = playerAction</span><br><span class="line">            <span class="keyword">if</span> (sameCount &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                response.writeHead(<span class="number">400</span>);</span><br><span class="line">                response.end(<span class="string">&#x27;你作弊！&#x27;</span>);</span><br><span class="line">                sameCount = <span class="number">9</span>;</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行游戏逻辑</span></span><br><span class="line">            <span class="keyword">const</span> gameResult = game(playerAction);</span><br><span class="line">            <span class="comment">// 先返回头部</span></span><br><span class="line">            response.writeHead(<span class="number">200</span>);</span><br><span class="line">            <span class="comment">// 根据不同的游戏结果返回不同的说明</span></span><br><span class="line">            <span class="keyword">if</span> (gameResult == <span class="number">0</span>) &#123;</span><br><span class="line">                response.end(<span class="string">&#x27;平局！&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gameResult == <span class="number">1</span>) &#123;</span><br><span class="line">                response.end(<span class="string">&#x27;你赢了！&#x27;</span>);</span><br><span class="line">                <span class="comment">// 玩家胜利次数统计+1</span></span><br><span class="line">                playerWon++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                response.end(<span class="string">&#x27;你输了！&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果访问的是根路径，则把游戏页面读出来返回出去</span></span><br><span class="line">        <span class="keyword">if</span> (parsedUrl.pathname == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            fs.createReadStream(__dirname + <span class="string">&#x27;/index.html&#x27;</span>).pipe(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><p>在cmd窗口中输入<code>node index.js</code>就可以在浏览器的<code>localhost:3000</code>端口中看见这个游戏啦！</p><blockquote><p>有一些node基础的同学们应该看起来很容易，毕竟我也不咋会emm。</p></blockquote><p>那，来看一下效果吧。</p><blockquote><p>没有做丝毫美化，实在是懒欸。</p></blockquote><p><img src="/posts/2316163776.html/%E7%9F%B3%E5%A4%B4%E5%89%AA%E5%88%80%E5%B8%831.gif"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>日后想优化一下，挂到自己服务器上，嘿嘿，好歹是自己做的第一个小游戏~</p><blockquote><p>大家有什么好的建议嘛~</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> 经历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript数组去重问题</title>
      <link href="/posts/1826147754.html/"/>
      <url>/posts/1826147754.html/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这应该是一个很常见的问题了，既然是常见的，那我们就更应该来学习一下！</p><h2 id="开始研究"><a href="#开始研究" class="headerlink" title="开始研究"></a>开始研究</h2><h3 id="原始"><a href="#原始" class="headerlink" title="原始"></a>原始</h3><p>数组去重，最开始我的思路是这样：定义一个新数组，完后两层for循环，如果数据第一次出现，就push到新数组里，如果重复就break掉，利用j的值与res长度相等这一点来判断数据唯一，最后返回新数组就行了。</p><span id="more"></span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">8</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;66&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> res = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; res.length; j ++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i] === res[j])&#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果数据第一次出现，那么执行完上面for语句后，j的值应该等于res的长度才对</span></span><br><span class="line"><span class="keyword">if</span>(j === res.length)&#123;</span><br><span class="line">res.push(arr[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br></pre></td></tr></table></figure><h3 id="利用indexOf优化原始方法"><a href="#利用indexOf优化原始方法" class="headerlink" title="利用indexOf优化原始方法"></a>利用indexOf优化原始方法</h3><p>我们先来简单了解一下indexOf：</p><p>indexOf(item,start) 方法可返回数组中某个指定的元素位置。</p><p>该方法将从头到尾地检索数组，看它是否含有对应的元素。开始检索的位置在数组 start 处或数组的开头（没有指定 start 参数时）。如果找到一个 item，则返回 item 的第一次出现的位置。开始位置的索引为 0。</p><p><strong>如果在数组中没找到指定元素则返回 -1。</strong></p><p>看到这大家都明白我们利用的是哪一点了吧，没错，就是加粗的那一句话：<strong>如果在数组中没找到指定元素则返回 -1。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">8</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;66&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> res = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(res.indexOf(arr[i]) === -<span class="number">1</span>)&#123;</span><br><span class="line">res.push(arr[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br></pre></td></tr></table></figure><h3 id="再次优化，filter方法！"><a href="#再次优化，filter方法！" class="headerlink" title="再次优化，filter方法！"></a>再次优化，filter方法！</h3><p>filter，顾名思义，过滤的意思，该方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</p><p>思路：用filter代替一层循环与indexOf配合，达到过滤效果，直接返回去重过后的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">8</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;66&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> res = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> arr.indexOf(item) === index</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br></pre></td></tr></table></figure><h3 id="换种思路？变成有序数组？"><a href="#换种思路？变成有序数组？" class="headerlink" title="换种思路？变成有序数组？"></a>换种思路？变成有序数组？</h3><p>不知道刷过几天力扣的小伙伴们有没有这种感觉，看见题目中出现数组，眼睛就立刻往前瞄了瞄，看看是有序数组还是无序数组~</p><p>回到这个问题上，我们将要去重的数组变成有序，重复的数据肯定都挨着了，用一个变量存放上一个元素值，再循环判断当前值与上一个元素值是否相同，如果不相同，就将它添加到res中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">8</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;66&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> res = []</span><br><span class="line"><span class="keyword">var</span> pre</span><br><span class="line">arr = arr.sort()</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!i || pre !== arr[i])&#123;</span><br><span class="line">res.push(arr[i])</span><br><span class="line">&#125;</span><br><span class="line">pre = arr[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br></pre></td></tr></table></figure><h3 id="再再次优化，filter！"><a href="#再再次优化，filter！" class="headerlink" title="再再次优化，filter！"></a>再再次优化，filter！</h3><p>刚刚悟了~，filter好像也可以把排序这里重写一下，变得更为简洁，我们直接看代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">8</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;66&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> res = arr.sort().filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> !index || item !== arr[index - <span class="number">1</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br></pre></td></tr></table></figure><h3 id="ES6，Set来袭！"><a href="#ES6，Set来袭！" class="headerlink" title="ES6，Set来袭！"></a>ES6，Set来袭！</h3><p>ES6给我们带来了很多好处，其中，map、set尤为优秀。</p><p>Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。</p><p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</p><p>所以我们可以利用Set的这一特性，来进行去重处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">8</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;66&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br></pre></td></tr></table></figure><p>注：Set是对象，所以要转成数组进行返回。</p><h4 id="懂解构赋值的你，可以再简化一点"><a href="#懂解构赋值的你，可以再简化一点" class="headerlink" title="懂解构赋值的你，可以再简化一点"></a>懂解构赋值的你，可以再简化一点</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">8</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;66&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> [...new <span class="built_in">Set</span>(arr)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br></pre></td></tr></table></figure><blockquote><p>想了解一下解构赋值的也可以先康康这个：<a href="https://blog.wangez.site/posts/1586874348.html/">解构运算符的理解与运用 </a></p><p>之前学习，记录的笔记🎨</p></blockquote><h4 id="继续优秀下去（箭头函数）"><a href="#继续优秀下去（箭头函数）" class="headerlink" title="继续优秀下去（箭头函数）"></a>继续优秀下去（箭头函数）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">8</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;66&#x27;</span>]</span><br><span class="line"><span class="keyword">var</span> unique = <span class="function">(<span class="params">arr</span>) =&gt;</span> [...new <span class="built_in">Set</span>(arr)]</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>从最开始的好几行代码，到最后利用箭头函数，可以一行就写完，足以见得，JavaScript是在逐渐变得更好。</p><p>那我们，作为开发者，也要努力学习，才能更好的去使用这门语言呀🎈</p><blockquote><p>学无止境，不是说说而已。</p><p>点个赞，我们一起学习进步吧~</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>都2021年了，节流是不是也应该了解一下了</title>
      <link href="/posts/335803086.html/"/>
      <url>/posts/335803086.html/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天发了有关防抖的文章，很多人都问为啥节流不一起写了呢？这当然是因为昨天那个是上实验课摸鱼写的，节流不没摸出来嘛，嘿嘿。</p><p>不过不要慌，节流，它来了！</p><p>个人理解：节流的作用与防抖相似，都是为了限制事件的频繁触发。</p><span id="more"></span><h2 id="如何实现节流"><a href="#如何实现节流" class="headerlink" title="如何实现节流"></a>如何实现节流</h2><p>实现节流，就要先了解节流的原理。</p><p>节流就是，在一定的时间内，只执行一次事件。</p><p>或者说是，每隔一段时间，只执行一次事件。</p><blockquote><p>要与防抖做一下区分哦~</p><p>防抖是，不管你触发了几次，我只看你最后触发的那一次，并且在若干时间后去执行此次事件。</p></blockquote><p>我了解到的节流，有两种方式，分别是<strong>时间戳</strong>与<strong>定时器</strong>。</p><p>那么我们来实现一下看看吧~</p><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>使用时间戳，当触发事件的时候，我们记录当前的时间戳，然后减去之前记录的时间戳(最一开始值一定不要忘了设为 0 )，如果大于设置的时间周期(也就是那个间隔的时间段)，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。</p><p>看完是不是觉得很简单？那我们来写一下。</p><blockquote><p>具体的例子还是使用防抖的那个，懒得再写一个啦，嘿嘿~   将防抖函数换成节流就可</p><p>防抖文章链接：<a href="https://blog.wangez.site/posts/647457095.html">都2021年了，不会还有人不知道防抖吧？</a></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">todo, time</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (now - pre &gt; time) &#123;</span><br><span class="line">            todo.apply(that);</span><br><span class="line">            pre = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的话还是跟之前相同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = throttle(shake,<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>为什么设置3000，当然想让效果看起来明显一些，下面来看看效果吧：</p><p><img src="/posts/335803086.html/%E6%97%B6%E9%97%B4%E6%88%B3%E8%8A%82%E6%B5%81.gif"></p><p>好了好了，别在心里数123了，我们接着往下来。</p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。</p><p>上代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">todo, time</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout,that;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">                todo.apply(that)</span><br><span class="line">            &#125;, time)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看效果：</p><p><img src="/posts/335803086.html/%E5%AE%9A%E6%97%B6%E5%99%A8%E8%8A%82%E6%B5%81.gif"></p><p>可以看出，它是过了3s才生效的，但是不知道为什么，这种方式给我的体验感不是很好，可能是因为不是点击的下一刻就有了反馈吧~</p><blockquote><p>这块要加上一个过渡动画，是不是会好很多？</p></blockquote><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>既然有两种方法，那就要说一下他们的区别。</p><p>第一种：在例子中可以清楚的看到，点击触发后立即有反馈（执行第一次），连续触发直到过了等待时间才会进行下一次执行，停止触发就不会执行。</p><p>第二种：过了等待时间才会执行第一次，停止触发还会执行一次。</p><p>在网上看到了这样的形容词：<strong>有头无尾，和无头有尾</strong>，是不是很形象。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>啊，终于结束了！还是那句话，可能我想到的或者写的不是很完善，希望大家能够指出，我会及时更正哒。</p><blockquote><p>要是以后的我觉得某处可以优化，也会回来更新的！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>都2021年了，你还不会防抖吗？</title>
      <link href="/posts/647457095.html/"/>
      <url>/posts/647457095.html/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在我们写项目遇到不听话的用户的时候，例如一个登录按钮，他就偏偏要反复点好几次，调用了<code>/login</code>接口好多次，是不是很烦？</p><p>因为涉及到ajax请求，就会有这样的情况，假设 1 秒触发了 60 次，每个回调就必须在 1000 / 60 = 16.67ms 内完成，否则就会有卡顿出现。</p><p>那么只有请求需要写防抖吗？</p><p>当然不是，凡是（可能）涉及到频繁事件触发的地方，都需要写防抖。</p><span id="more"></span><blockquote><ol><li>window 的 resize、scroll</li><li>mousedown、mousemove</li><li>keyup、keydown</li><li>click事件</li><li>……</li></ol></blockquote><p>我们简单的写一个小demo，看一下没有防抖跟有防抖的效果。</p><p>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// html</span></span><br><span class="line">&lt;button id=<span class="string">&quot;btn&quot;</span> onclick=<span class="string">&quot;shake()&quot;</span>&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shake</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    container.innerHTML = count++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p><img src="/posts/647457095.html/%E6%9C%AA%E9%98%B2%E6%8A%96.gif"></p><hr><h2 id="如何实现防抖"><a href="#如何实现防抖" class="headerlink" title="如何实现防抖"></a>如何实现防抖</h2><p>实现防抖，就要了解防抖的原理。</p><p>防抖就是，不管你触发了几次，我只看你最后触发的那一次，并且在若干时间后去执行此次事件。</p><p>根据这个原理，我们可以写出这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preventShake</span>(<span class="params">todo,time</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(todo, time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置一个延迟操作的事件，并且如果再次触发就把之前的延迟取消掉，重新进入计时。</p><p>将它运用在刚刚的例子上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shake</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    container.innerHTML = count++;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preventShake</span>(<span class="params">todo,time</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(todo, time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">btn.onclick = preventShake(shake,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><hr><p><img src="/posts/647457095.html/%E9%98%B2%E6%8A%96%E6%9C%AA%E4%BC%98%E5%8C%96.gif"></p><hr><p>我们已经实现了基础的它，那么我们继续优化一下吧！</p><h2 id="this指向优化"><a href="#this指向优化" class="headerlink" title="this指向优化"></a>this指向优化</h2><p>看似上面的结果没有什么太大问题，但是我们打印一下原先的<code>shake</code>和使用了<code>preventShake</code>后的this就会知道，他们指向的并不是一个东西。</p><ul><li><p>原先指向的是</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用了<code>preventShake</code>后this指向的是<strong>Window</strong>对象！</p></li></ul><p>于是我们要加一步，就是改变this指向。</p><blockquote><p>欸，这个是不是又是一篇文章？？</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preventShake</span>(<span class="params">todo,time</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            todo.apply(that);</span><br><span class="line">        &#125;, time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就解决了this指向可能带来的问题。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>至此，这个简易的防抖函数就写完了，可能我想的还不太完善，希望大家给予建议，我也会及时学习，之后将其完善，争取做的更好。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速了解ES6模块化少不了这篇文章</title>
      <link href="/posts/3892826279.html/"/>
      <url>/posts/3892826279.html/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在之前的JavaScript中是没有模块化概念的，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。如果要进行模块化操作，就需要引入第三方的类库。随着技术的发展，前后端分离，前端的业务变的越来越复杂化，于是才有了ES6模块化的诞生。</p><p>为什么要有模块化，或者模块化的好处是什么呢？</p><blockquote><p> 大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块间的相互调用，利人利己。</p><p> 可以将一段复杂的程序拆解开来，方便维护可拓展。</p></blockquote><span id="more"></span><h2 id="前端模块化规范"><a href="#前端模块化规范" class="headerlink" title="前端模块化规范"></a>前端模块化规范</h2><p>在<strong>ES6模块化</strong>诞生之前，JavaScript社区尝试并提出了<strong>AMD、CMD、commonJS</strong>等模块化规范。</p><p>但是，这些模块化规范，存在一定的差异性与局限性，并不能通用。</p><p>例如：</p><ul><li><p>AMD和CMD适用于浏览器端的JavaScript模块化</p></li><li><p>commonJS适用于服务器端的JavaScript模块化</p><blockquote><p>Node.js 就是遵循的这个规范</p><p>导入其它模块使用require()</p><p>导出使用module.exports对象</p></blockquote></li></ul><p>太多的模块化规范给开发者增加了学习的难度与开发的成本。所以，ES6模块化规范诞生了！</p><h3 id="什么是ES6模块化规范"><a href="#什么是ES6模块化规范" class="headerlink" title="什么是ES6模块化规范"></a>什么是ES6模块化规范</h3><p>ES6模块化规范是浏览器端与服务端通用的模块化开发规范。它的出现极大的降低了前端开发者的模块化学习成本，开发者不需要在额外学习AMD、CMD或者commonJS等模块化规范。</p><p>ES6中模块化规范中定义：</p><ul><li>每个js文件都是一个独立的模块</li><li>导入其他模块成员使用<code>import</code>关键字</li><li>向外共享模块成员使用<code>export</code>关键字</li></ul><h2 id="在node-js中体验ES6模块化"><a href="#在node-js中体验ES6模块化" class="headerlink" title="在node.js中体验ES6模块化"></a>在node.js中体验ES6模块化</h2><p>node.js中默认仅支持commonJS模块化规范，若想在node中进行体验，要按照如下两步骤进行配置：</p><ul><li><p>确保安装了<code>v14.15.1</code>或者更高版本的node.js</p><blockquote><p>可以使用在cmd窗口中使用<code>node -v</code>命令查看当前版本号哦~</p></blockquote></li><li><p>在package.json的根节点中添加<code>&quot;type&quot;:&quot;module&quot;</code>节点</p><blockquote><p>不知道如何添加的小伙伴看这里：</p><p>首先我们要在一个空文件夹内，执行<code>npm init -y</code>，这时候我们就能看见已经自动生成了<code>package.json</code>文件了</p><p>完后在vs-code打开，在内添加<code>&quot;type&quot;:&quot;module&quot;</code>节点即可</p><p>小提示：type值默认为commonJS，所以我们平时node遵循的模块化规范都是commonJS</p></blockquote></li></ul><h2 id="ES6模块化的基本语法"><a href="#ES6模块化的基本语法" class="headerlink" title="ES6模块化的基本语法"></a>ES6模块化的基本语法</h2><p>ES6的模块化主要包含如下3种用法：</p><ul><li>默认导出与默认导入</li><li>按需导出与按需导入</li><li>直接导入并执行模块中的代码</li></ul><h3 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h3><p>语法：<code>export default</code> <font color="nred">默认导出的成员</font></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n1 = <span class="number">10</span> <span class="comment">// 定义模块私有成员 n1</span></span><br><span class="line"><span class="keyword">let</span> n2 = <span class="number">20</span> <span class="comment">// 定义模块私有成员 n2 因为没有共享出去，所以外界访问不到</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 定义模块私有方法 show</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; <span class="comment">// 使用export default 默认导出语法 向外共享n1 和 show 两个成员</span></span><br><span class="line">n1,</span><br><span class="line">    show</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><p>每个模块中，只允许用唯一的一次 <code>export default</code>，否则会报错！</p><h3 id="默认导入"><a href="#默认导入" class="headerlink" title="默认导入"></a>默认导入</h3><p>语法：<code>import</code><font color="nred">接收名称</font><code>form</code><font color="nred">模块标识符</font></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 m1.js 模块中导入 export default 向外共享的成员</span></span><br><span class="line"><span class="comment">// 并使用 m1 进行接收</span></span><br><span class="line"><span class="keyword">import</span> m1 form <span class="string">&#x27;./m1.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(m1)</span><br><span class="line"><span class="comment">// 输出为: &#123; n1: 10, show: [Function:show]&#125;</span></span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><p>默认导入的时候，接收名字可以任意写，注意是合法的成员名称就行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m1 合法 不报错</span></span><br><span class="line"><span class="keyword">import</span> m1 form <span class="string">&#x27;./m1.js&#x27;</span></span><br><span class="line"><span class="comment">// 成员名称不能用数字开头，所以会直接报错</span></span><br><span class="line"><span class="keyword">import</span> <span class="number">123</span> form <span class="string">&#x27;./m1.js&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="按需导出"><a href="#按需导出" class="headerlink" title="按需导出"></a>按需导出</h3><p>语法：<code>export</code><font color="nred">按需导出的成员</font></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向外按需导出变量 s</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> s = <span class="string">&#x27;Ned&#x27;</span></span><br><span class="line"><span class="comment">// 向外按需导出方法 show</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="按需导入"><a href="#按需导入" class="headerlink" title="按需导入"></a>按需导入</h3><p>语法：<code>import &#123;s&#125; from</code><font color="nred">模块标识符 </font></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; s, show &#125; form <span class="string">&#x27;./m1.js&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(s) <span class="comment">// Ned</span></span><br><span class="line"><span class="built_in">console</span>.log(show) <span class="comment">// [Function: show]</span></span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li>每个模块中可以使用多次按需导出</li><li>按需导入的成员名称必须跟按需导出的名称一致</li><li>按需导入时，可以使用<code>as</code>关键字进行重命名</li><li>按需导入可以和默认导入一起使用</li></ul><p>重命名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; s <span class="keyword">as</span> str &#125; form <span class="string">&#x27;./m1.js&#x27;</span></span><br></pre></td></tr></table></figure><p>使用as关键字，将s重命名为str，所以接下来我们使用str就好了，不能再使用s这个名字。</p><p>按需导入和默认导入一起使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> info,&#123; s <span class="keyword">as</span> str &#125; form <span class="string">&#x27;./m1.js&#x27;</span></span><br></pre></td></tr></table></figure><p>info就是默认导入，后面带大括号的就是按需导入。</p><h3 id="直接导入并执行模块中的代码"><a href="#直接导入并执行模块中的代码" class="headerlink" title="直接导入并执行模块中的代码"></a>直接导入并执行模块中的代码</h3><p>如果只想单纯的执行某个模块中的代码，并不需要得到其内部向外共享的成员，可以这样做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m1.js:</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line">-------------------------</span><br><span class="line"><span class="comment">// 直接导入并执行模块中的代码</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./m1.js&#x27;</span></span><br></pre></td></tr></table></figure><p>没错，就是直接导入即可。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这篇文章简单介绍一下模块化的概念和语法，过几天我还会出一篇文章来告诉大家模块化在实际应用里是如何使用的。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么？你还不知道Symbol？</title>
      <link href="/posts/2670144936.html/"/>
      <url>/posts/2670144936.html/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>ES6引入了一种新的原始数据类型<code>Symbol</code>表示独一无二的值。它是JavaScript语言的第七种数据类型，是一种类似于字符串的数据类型。</p><h3 id="Symbol的特点"><a href="#Symbol的特点" class="headerlink" title="Symbol的特点"></a>Symbol的特点</h3><ul><li>Symbol的值是唯一的，用来解决命名冲突的问题</li><li>Symbol值不能与其他数据进行运算</li><li>Symbol定义的对象属性不能使用<code>for...in</code>循环遍历，但是可以使用<code>Reflect.ownKeys</code>来获取对象的所有键名</li></ul><span id="more"></span><h3 id="创建Symbol的两种方式"><a href="#创建Symbol的两种方式" class="headerlink" title="创建Symbol的两种方式"></a>创建Symbol的两种方式</h3><h4 id="创建Symbol"><a href="#创建Symbol" class="headerlink" title="创建Symbol"></a>创建Symbol</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Symbol</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(s, <span class="keyword">typeof</span> s); <span class="comment">// Symbol() &#x27;symbol&#x27;</span></span><br></pre></td></tr></table></figure><p>打印出来的数据跟想象中是不是不一样？是不是觉得<code>s</code>应该是一个很长的东西？这是因为它的唯一性在这里是不可见的，所以我们才看不见。</p><p>不要慌，继续往下看，我们继续创建Symbol。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;Ned&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">Symbol</span>(<span class="string">&#x27;Ned&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s2 === s3); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>我们现在传入了两个字符串，想看看返回的值是不是一样的，发现是不一样的。</p><blockquote><p>我的理解：<br>虽然传入两个字符串内容一样，但是他们的编号未必一样，啊不，应该是一定不一样。</p></blockquote><h4 id="使用Symbol-for创建Symbol"><a href="#使用Symbol-for创建Symbol" class="headerlink" title="使用Symbol.for创建Symbol"></a>使用Symbol.for创建Symbol</h4><p>这样创建的Symbol是一个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s4 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;Ned&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s4, <span class="keyword">typeof</span> s4); <span class="comment">// Symbol(Ned) &#x27;symbol&#x27;</span></span><br></pre></td></tr></table></figure><p>通过<code>Symbol.for</code>创建的，我们可以通过传入同一字符串来得到唯一的symbol值的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s4 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;Ned&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s5 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;Ned&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s4 === s5); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="【强调】Symbol值不能与其他数据进行运算"><a href="#【强调】Symbol值不能与其他数据进行运算" class="headerlink" title="【强调】Symbol值不能与其他数据进行运算"></a>【强调】Symbol值不能与其他数据进行运算</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> b = a + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">let</span> c = a + <span class="string">&#x27;100&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这都是不行的，会直接在浏览器中报错。</p><h3 id="Symbol的基本使用"><a href="#Symbol的基本使用" class="headerlink" title="Symbol的基本使用"></a>Symbol的基本使用</h3><blockquote><p>symbol的使用场景就是给对象加属性或者方法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> game = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;石头剪刀布&#x27;</span>，</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">up</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;这是up函数&#x27;</span>);</span><br><span class="line">    &#125;，</span><br><span class="line">    <span class="attr">down</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;这是down函数&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有一个对象<code>game</code>,我们想往里添加两个方法，分别是<code>up</code>和<code>down</code>，但是我们不清楚现在对象中是否已经具有<code>up</code>和<code>down</code>两个方法，按照以往的方法，我们是不是应该打开这个对象，去里面一一查找是否具有这两个方法，如果找到了，我们是不是就应该换个名字，如果没找到，我们就可以向内添加方法，但是这个对象结构简单还好，如果稍微复杂一点的话，这个操作就会非常复杂，会耗费许多时间。</p><p>在这种应用场景下，我们就应该应用<code>Symbol</code>来创建唯一值，完成这个需求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个method对象</span></span><br><span class="line"><span class="keyword">let</span> methods = &#123;</span><br><span class="line">    <span class="attr">up</span>: <span class="built_in">Symbol</span>(),</span><br><span class="line">    <span class="attr">down</span>: <span class="built_in">Symbol</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向game对象中，注入方法</span></span><br><span class="line">game[methods.up] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我要上升！&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">game[methods.down] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我要下降！&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用这样的方式，给<code>game</code>对象添加方法，是不会破坏<code>game</code>原有的一些属性的，是非常安全快速的。</p><p>下面我们打印一下<code>game</code>对象，看一下他内部是什么样子的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name: <span class="string">&quot;石头剪刀布&quot;</span></span><br><span class="line"><span class="attr">down</span>: f()</span><br><span class="line"><span class="attr">up</span>: f()</span><br><span class="line"><span class="built_in">Symbol</span>(): f()</span><br><span class="line"><span class="built_in">Symbol</span>(): f()</span><br></pre></td></tr></table></figure><p>可以看到，多出了两个Symbol函数，没有对原函数造成影响。</p><h3 id="数据类型小诀窍"><a href="#数据类型小诀窍" class="headerlink" title="数据类型小诀窍"></a>数据类型小诀窍</h3><p>送大家一个记住JavaScript数据类型的小诀窍</p><p>共八种</p><blockquote><p><strong>USONB: you are so niu bility</strong> </p><p><strong>U: undefined</strong></p><p><strong>S: string  symbol</strong></p><p><strong>O: object</strong></p><p><strong>N: null  number</strong></p><p><strong>B: boolean  bigint</strong></p></blockquote><blockquote><p><strong>想顺便复习数据类型的话也可以看我的这篇文章：<a href="https://blog.wangez.site/posts/2884264051.html/#more">一文带你了解JavaScript的数据类型</a></strong></p></blockquote><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>希望总结的这些知识可以让大家对symbol类型的数据有一个简单的了解。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于JavaScript的数据类型（2021.9.23更新）</title>
      <link href="/posts/2884264051.html/"/>
      <url>/posts/2884264051.html/</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>二刷JavaScript高级了，上一次是刷的黑马pink老师的课程，这次刷的是尚硅谷的课程，都是B站的课程，对课程进行了些许总结。</p><p>可能是课程有些老的原因，例如视频中仅有5个基本类型，但是目前好像是有7种。</p><p>所以结合之前所学的一些知识，对内容进行了补充。</p><p><em>如有错误，还望指正。</em></p><span id="more"></span><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="基本（值）类型"><a href="#基本（值）类型" class="headerlink" title="基本（值）类型"></a>基本（值）类型</h3><ul><li>String：任意字符串</li><li>Number：任意的数字</li><li>boolean：true  /  false</li><li>undefined：undefined</li><li>null：null</li><li>bigInt：可以用任意精度表示整数</li><li>symbol：符号类型是唯一的并且是不可修改的，通常用来作为object的key</li></ul><h3 id="引用（对象）类型"><a href="#引用（对象）类型" class="headerlink" title="引用（对象）类型"></a>引用（对象）类型</h3><ul><li>Object：任意对象</li><li>Function：一种特别的对象（可以执行）</li><li>Array：一种特别的对象（数值下标，内部数据是有序的）</li></ul><h2 id="如何判断数据类型"><a href="#如何判断数据类型" class="headerlink" title="如何判断数据类型"></a>如何判断数据类型</h2><p>三种方法：</p><ul><li><p>typeof</p><blockquote><p>typeof返回数据类型的字符串表达  </p><p>注：可以判断undefined、数值、boolean、字符串，不能判断null与object object与array</p></blockquote></li><li><p>instanceof</p><blockquote><p>判断对象的具体类型</p></blockquote></li><li><p>===</p><blockquote><p>注：可以判断undefined，null</p></blockquote></li></ul><h3 id="判断基本类型"><a href="#判断基本类型" class="headerlink" title="判断基本类型"></a>判断基本类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="built_in">console</span>.log(a,<span class="keyword">typeof</span> a,<span class="keyword">typeof</span> a === <span class="string">&#x27;undefined&#x27;</span>,a === <span class="literal">undefined</span>) <span class="comment">// undefined &#x27;undefined&#x27; true true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> === <span class="string">&#x27;undefined&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a</span><br><span class="line">a = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a === <span class="string">&#x27;number&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">a = <span class="string">&#x27;Ned&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">a = <span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a === <span class="string">&#x27;boolean&#x27;</span>) <span class="comment">// true </span></span><br><span class="line">a = <span class="literal">null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a, a=== <span class="literal">null</span>) <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p><strong>请注意：这里string，s一定要小写，否则会是false，这是因为人家已经设计好的，是固定的。</strong></p><h3 id="判断对象类型"><a href="#判断对象类型" class="headerlink" title="判断对象类型"></a>判断对象类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b1 = &#123;</span><br><span class="line">    <span class="attr">b2</span>: [a,<span class="string">&#x27;abc&#x27;</span>,<span class="built_in">console</span>.log]</span><br><span class="line">    <span class="attr">b3</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;b3&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体的 b1 是个对象，b2 是数组， b3 是函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(b1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>, b1 <span class="keyword">instanceof</span> <span class="built_in">Array</span>) <span class="comment">// true false</span></span><br><span class="line"><span class="built_in">console</span>.log(b1.b2 <span class="keyword">instanceof</span> <span class="built_in">Array</span>, b1.b2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true true</span></span><br><span class="line"><span class="built_in">console</span>.log(b1.b3 <span class="keyword">instanceof</span> <span class="built_in">Function</span>, b1.b3 <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true true</span></span><br></pre></td></tr></table></figure><blockquote><p>标注一下 instance of 的用法</p><p>[实例] instanceof [类]</p><p>如果这个实例是类的实例，就返回true，反之返回false</p></blockquote><p>也就是说，我们判断对象类型，要用instanceof。</p><p>另：判断<code>function</code>还可以用<code>typeof</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b1.b3 === <span class="string">&#x27;function&#x27;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p> 不知道大家有没有注意，b2的第三个值我们写了个console.log，下面我们也来判断一下它，应该是个function的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b1.b2[<span class="number">2</span>] === <span class="string">&#x27;function&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>所以我们要调用这个函数的时候可以直接<code>b1.b2[2]()</code>，这里提醒大家，我们千万不要被<code>b1.b2[2]</code>所迷惑，我们要清楚它的数据类型到底是什么。</p><p>就此情况，我们上面b1中的b3改写一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b1 = &#123;</span><br><span class="line">    <span class="attr">b3</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(b3)</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Ned&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们想要得到<code>&#39;Ned&#39;</code>，应该怎么做？</p><p>只需要调用这个返回过来的函数即可：<code>b1.b3()()</code>，输出一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(b1.b3()())</span><br></pre></td></tr></table></figure><p>所以不要拘泥于表面现象，一定要看清楚得到的是什么类型的数据，才能进行下一步的操作！</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="手写instanceof"><a href="#手写instanceof" class="headerlink" title="手写instanceof"></a>手写instanceof</h3><p>想要手写，我们首要的就是要了解它的原理。</p><p>原理：验证当前类的原型prototype是否会出现在实例的原型链<strong>proto</strong>上，只要在它的原型链上，则结果都为true。因此，<code>instanceof</code>在查找的过程中会遍历左边变量的原型链，直到找到右边变量的<code>prototype</code>，找到返回true，找不到返回false。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myinstanceOf</span>(<span class="params">left,right</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> proto = left.__proto__</span><br><span class="line">    <span class="keyword">let</span> prototype = right.prototype</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(proto == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(proto == prototype)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        proto = proto.__proto__</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="constructor（用于引用数据类型）"><a href="#constructor（用于引用数据类型）" class="headerlink" title="constructor（用于引用数据类型）"></a>constructor（用于引用数据类型）</h3><ul><li>语法： 被检测数据.constructor === class</li><li>特点：<ul><li>适合使用在引用数据类型上</li><li>原型链不会干扰</li></ul></li><li>原理：构造函数原型上有一个 constructor 属性指向构造函数自身的，如果在实例上使用 construtor 时，就会直接使用其构造函数原型的上的该属性，并指向其构造函数。</li></ul><h3 id="Object-prototype-toString-call-（对象原型链判断方法）"><a href="#Object-prototype-toString-call-（对象原型链判断方法）" class="headerlink" title="Object.prototype.toString.call()（对象原型链判断方法）"></a>Object.prototype.toString.call()（对象原型链判断方法）</h3><ul><li>语法：Object.prototype.toString.call(被检测数据)   </li><li>特点：适用于所有类型的判断检测</li><li>原理：Object.prototype.toString 表示一个返回对象类型的字符串，call()方法可以改变this的指向，那么把Object.prototype.toString()方法指向不同的数据类型上面，返回不同的结果</li></ul><h2 id="补充，相关问题（2021-9-23）"><a href="#补充，相关问题（2021-9-23）" class="headerlink" title="补充，相关问题（2021.9.23）"></a>补充，相关问题（2021.9.23）</h2><h3 id="undefined与null的区别？"><a href="#undefined与null的区别？" class="headerlink" title="undefined与null的区别？"></a>undefined与null的区别？</h3><ul><li>undefined表示定义未赋值</li><li>null表示定义并赋值了，只是值为null</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br><span class="line">a = <span class="literal">null</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// null</span></span><br></pre></td></tr></table></figure><h3 id="什么时候给变量赋值为null呢？"><a href="#什么时候给变量赋值为null呢？" class="headerlink" title="什么时候给变量赋值为null呢？"></a>什么时候给变量赋值为null呢？</h3><ul><li>初始赋值，表明将要赋值为对象</li><li>结束前，让对象成为垃圾对象，被回收掉。</li></ul><p>不知道大家是否还记得，typeof 一个null的时候，返回的是什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a) <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>没错，是object。</p><p>所以当我们将一个变量的初始值赋值为null的时候，我们是向其他程序员表明，这个变量将会被赋值为对象。</p><blockquote><p>不这么做行不行？ 当然可以。</p><p>那为什么还要这么做？</p><p>当然是因为，编程也是很严谨的。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="literal">null</span> <span class="comment">// 初始赋值为null，表明将要赋值为对象</span></span><br><span class="line">b = [<span class="string">&#x27;Ned&#x27;</span>,<span class="number">20</span>] <span class="comment">// 确定对象就赋值</span></span><br><span class="line">b = <span class="literal">null</span> <span class="comment">// 最后，让b指向的对象成为垃圾对象（被垃圾回收器回收）</span></span><br></pre></td></tr></table></figure><h3 id="严格区别变量类型与数据类型"><a href="#严格区别变量类型与数据类型" class="headerlink" title="严格区别变量类型与数据类型"></a>严格区别变量类型与数据类型</h3><ul><li>数据的类型<ul><li>基本类型</li><li>对象类型</li></ul></li></ul><ul><li>变量的类型（变量内存值的类型）<ul><li>基本类型：保存就是基本类型的数据</li><li>引用类型：保存的是地址值</li></ul></li></ul><p>平时的时候我们不会去区分这个概念（要不是视频里看见了我都不知道:crying_cat_face:）。</p><p>简单的了解到这个概念就行吧~。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = fuction ()&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;这是一个函数&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a) <span class="comment">// function</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack基础认识</title>
      <link href="/posts/3206731080.html/"/>
      <url>/posts/3206731080.html/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>webpack在框架中多半被脚手架所集成，例如vue中的vue-cli，但是在面试中，还是会被问到，所以我们还是要了解一些必要知识，能让我们对此类技术有一个更深的认识。</p><p>不得不说，在学习过程中，我了解到了许多我之前仅仅知道那是配置文件的东西，但是经过学习了解之后，已经可以知道哪些配置是为了什么目的的了。</p><blockquote><p>古人云：学吧，学会了都是你的~</p><p>古人又云：学吧，学不死就往死里学！</p></blockquote><p><em>注：本文为摘录笔记，供学习使用。</em></p><span id="more"></span><h3 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack"></a>什么是webpack</h3><p>可能大家了解的，百度搜到的，webpack是一个<strong>模块打包器</strong>。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。</p><p>还有另一种说法：webpack是<strong>前端项目工程化的具体解决方案</strong></p><p>主要功能：它提供了友好的<strong>前端模块化</strong>开发支持，以及<strong>代码压缩混淆、处理浏览器端JavaScript的兼容性、性能优化</strong>等强大的功能。</p><blockquote><ul><li>代码压缩混淆是为了缩减文件体积，让网页打开更迅速</li><li>程序员可以放心大胆写js高级语法，webpack在具体浏览器运行的时候会有转换过程，将高级的转换成低级，没有兼容问题的代码，去浏览器里跑。</li><li>css3动画，浏览器不兼容是不会显示的，不会报错，效果出不来</li><li>js，如果低版本浏览器不兼容的话，浏览器会报错</li><li>webpack目前有一些现有的成熟的兼容方案</li></ul></blockquote><p>好处：让 程序员把<strong>工作重心</strong>放到具体功能的实现上，提高了前端<strong>开发效率</strong>和项目的<strong>可维护性</strong>。</p><h3 id="webpack的基本使用"><a href="#webpack的基本使用" class="headerlink" title="webpack的基本使用"></a>webpack的基本使用</h3><h4 id="构建初始项目目录"><a href="#构建初始项目目录" class="headerlink" title="构建初始项目目录"></a>构建初始项目目录</h4><p>因为许多我觉得大家都会，所以在此简略一些。</p><p>①新建项目空白目录，运行<code>npm init -y</code>命令，初始化包管理配置文件<code>package.json</code></p><p>②新建<code>src</code>源代码目录</p><p>③新建src—&gt;<code>index.html</code>首页和src—&gt;<code>index.js</code>脚本文件</p><blockquote><p>下面就是初始化和引入依赖了，我随便的引入一个jq，完后瞎写了点东西，主要还是学习webpack</p></blockquote><p>④初始化首页的基本结构</p><p>⑤运行<code>npm install jquery -S</code>命令，安装jQuery</p><blockquote><p>之前是不是都是去网上下一个类似<code>jquery.min.js</code>的文件手动拉到文件夹？</p></blockquote><h4 id="在项目中安装webpack"><a href="#在项目中安装webpack" class="headerlink" title="在项目中安装webpack"></a>在项目中安装webpack</h4><p>在终端运行如下命令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack@<span class="number">5.42</span><span class="number">.1</span> webpack-cli@<span class="number">4.7</span><span class="number">.2</span> -D</span><br></pre></td></tr></table></figure><blockquote><p>解释一下npm命令中-S -D的区别</p><p>开发中跟上线后部署都需要的包，要-S存到dependencies节点下</p><p>只在开发中使用的包，上线后不需要的包，要-D存到devDependencies节点下</p><p>注：-S 是 –save的简写 -D 是 –save-dev的简写</p></blockquote><h4 id="在项目中配置webpack"><a href="#在项目中配置webpack" class="headerlink" title="在项目中配置webpack"></a>在项目中配置webpack</h4><p>只安装不配置当然不会生效，所以我们还要来配置一下。</p><p>① 在项目根目录中，创建名字为<code>webpack.config.js</code>的webpack配置文件，并初始化如下的基本配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span> <span class="comment">// mode用来指定构建模式，可选值：development、production</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>module.exports  这个是不是很眼熟（Node.js的导出语法，如果对node有了解的话会知道），它的作用是向外导出一个配置对象，它是webpack的配置文件，当然，这个配置就是给webpack用的咯！</p><p>mode的两个可选值，代表着开发的不同阶段：分别是开发模式（development）跟生产模式（production）。</p><blockquote><p>生产模式也就是要上线了。</p></blockquote><p>② 在package.json的scripts节点下，新增<code>dev脚本</code>如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>:&#123;</span><br><span class="line"><span class="string">&quot;dev&quot;</span>:<span class="string">&quot;webpack&quot;</span> <span class="comment">// script 节点下的脚本，可通过npm run执行，例如npm run dev</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&quot;dev&quot;:&quot;webpack&quot;</code>,冒号前面是这个脚本的名字，冒号后面是个命令，后面的命令必须是字符串，前面脚本的名字可以任意去写，不一定叫dev，合法就行。</p><p>③ 在终端中运行<code>npm run dev命令</code>，启动webpack进行项目的打包构建。</p><p>运行之后，会多一个<code>dist</code>目录，打开后里面有一个main.js代码。</p><p>如果你之前<code>index.js</code>的代码引入到<code>index.html</code>中，出现了兼容性问题，那么不妨引入<code>main.js</code>试试，你会发现没有任何问题，这就是<strong>webpack</strong>的在起作用了，它帮着对我们的项目进行了兼容性处理。</p><h4 id="mode的可选值"><a href="#mode的可选值" class="headerlink" title="mode的可选值"></a>mode的可选值</h4><p><strong>mode节点</strong>的可选值在上面已经说过了，有两个，分别是</p><ul><li>development<ul><li>开发环境</li><li>不会对打包生成的文件进行代码压缩和性能优化</li><li>打包速度快，适合在开发阶段使用</li></ul></li><li>production<ul><li>生产环境</li><li>会对打包生成的文件进行代码压缩和性能优化</li><li>打包速度很慢，今是何在项目发布的阶段使用</li></ul></li></ul><p><strong>结论：</strong>开发的时候我们一定要用development，因为我们追求的是速度而不是体积，反过来，发布上线的时候我们一定要用production，因为上线追求的是体积和性能，而不是打包的速度。</p><h4 id="webpack-config-js文件的作用"><a href="#webpack-config-js文件的作用" class="headerlink" title="webpack.config.js文件的作用"></a>webpack.config.js文件的作用</h4><p>webpack.config.js是webpack的配置文件。webpack在真正开始打包构建之前，会先读取这个配置文件，从而基于给定的配置，对项目进行打包。</p><p>注意：由于webpack是基于node.js开发出来的打包工具，因此在它的配置文件中，支持使用node.js相关的语法和模块进行webpack的个性化配置。</p><h4 id="webpack中的默认约定"><a href="#webpack中的默认约定" class="headerlink" title="webpack中的默认约定"></a>webpack中的默认约定</h4><p>在webpack4.x和5.x的版本中，有如下的默认约定：</p><ul><li>默认的打包入口文件为<code>src-&gt;index.js</code></li><li>默认的输出文件路径为<code>dist-&gt;main.js</code></li></ul><p>注意：可以在<code>webpack.config.js</code>中修改打包的默认约定</p><h4 id="自定义打包的入口与出口"><a href="#自定义打包的入口与出口" class="headerlink" title="自定义打包的入口与出口"></a>自定义打包的入口与出口</h4><p>在<code>webpack.config.js</code>配置文件中，通过<strong>entry</strong>节点指定打包的入口。通过<strong>output</strong>节点指定打包的出口。</p><p>示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>) <span class="comment">// 导入node.js中专门操作路径的模块</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">entry</span>: path.join(__dirname,<span class="string">&#x27;./src/index.js&#x27;</span>), <span class="comment">// 打包入口文件路径</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.join(__dirname, <span class="string">&#x27;./dist&#x27;</span>), <span class="comment">// 输出文件的存取路径</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;main .js&#x27;</span> <span class="comment">// 输出文件名称 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意： __dirname 是两个下划线！！代表这个文件的存放路径。</p></blockquote><h3 id="webpack中的插件"><a href="#webpack中的插件" class="headerlink" title="webpack中的插件"></a>webpack中的插件</h3><blockquote><p>方便程序员的开发</p></blockquote><p>通过安装和配置第三方的插件，可以拓展webpack的能力，从而让webpack用起来方便。最常用的webpack插件有如下两个：</p><ul><li>webpack-dev-server<ul><li>类似于node.js阶段用到的nodemon工具</li><li>每当修改了源代码，webpack会自动进行项目的打包和构建</li></ul></li><li>html-webpack-plugin<ul><li>webpack中的HTML插件（类似于一个模板引擎插件）</li><li>可以通过此插件自定制index.html页面内容</li></ul></li></ul><h4 id="安装webpack-dev-server"><a href="#安装webpack-dev-server" class="headerlink" title="安装webpack-dev-server"></a>安装webpack-dev-server</h4><p>运行如下命令：</p><p><code>npm install webpack-dev-server@3.11.2 -D</code></p><blockquote><p>-D，上面有讲过，他只是在开发阶段使用的工具，并不是上线部署的时候需要的。</p></blockquote><h4 id="配置webpack-dev-server"><a href="#配置webpack-dev-server" class="headerlink" title="配置webpack-dev-server"></a>配置webpack-dev-server</h4><ul><li><p>修改<code>package.json--&gt;scripts</code>中的<code>dev</code>命令如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>:&#123;</span><br><span class="line"><span class="string">&quot;dev&quot;</span>: <span class="string">&quot;webpack serve&quot;</span>, <span class="comment">// script 节点下的脚本，可以通过npm run 执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>serve是一个参数，代表我们要通过插件实现自动打包功能，只要修改代码保存，他就会自动打包生成</p></blockquote><ul><li>再次运行<code>npm run dev</code>命令，重新进行项目的打包</li><li>在浏览器中访问<code>http://localhost:8080</code>地址，查看自动打包效果</li></ul><p>注意：<code>webpack-dev-server</code>会启动一个<strong>实时打包的http服务器</strong></p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组件库计划，启航！</title>
      <link href="/posts/2713460185.html/"/>
      <url>/posts/2713460185.html/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在大一下，第一次尝试饿了么团队的element-ui的时候，我就有想过在未来自己尝试参与开发一款属于自己的组件库，但是由于种种原因，就一直没能开始啃这块饼，终于这次开学，开始尝试着自己去做一个组件库，目的有二，一是实现自己当初的梦想，二是能够进一步锻炼自己的能力。</p><p>那么，组件库计划，正式起航！</p><p>在开始之前，去网上找了许多资料，要么是不太详细，要么是讲的太高深导致我看不大懂，挑选了很久，在掘金找到了篇自己觉得对小白很友好的博客，会在文中放给大家，本文是对我开发的组件库的一个简介。</p><span id="more"></span><h3 id="建立项目"><a href="#建立项目" class="headerlink" title="建立项目"></a>建立项目</h3><p>组件库选定为基于Vue开发的组件库，所以我们要建立一个vue项目。</p><p>这里我参考了：<a href="https://juejin.cn/post/6844904085808742407#heading-4">从零到一教你基于vue开发一个组件库 </a></p><p>我是参考这位大佬的博客来进行构建项目目录，并做出了一些修改，修改后我的目录如下：</p><img src="/posts/2713460185.html/目录.png" alt="s" style="zoom:80%;"><p>建立一个style目录，存放所有的样式文件，包括目前的主题样式，单个组件样式，跟以后可能会有的icon样式等，早些抽离出来以方便后期维护。</p><p>建立一个utils目录，存放用到的自己封装的一些工具函数，例如日期，随机数，遍历数组等。</p><h3 id="关于组件"><a href="#关于组件" class="headerlink" title="关于组件"></a>关于组件</h3><p>我们做组件库同平时自己封装项目中的组件是不一样的，做组件库的时候要想的是公共需求，也就是，一个组件库最基本应该具备什么，其次才是你针对于某些业务而做出的优化，这些优化会成为你的特点，然而目前我要做的，仅仅是努力做到基本，我觉得就很好了。</p><p>拿一个简单的button举例子，他应该有哪些<code>type</code>呢？</p><p>我认为：最基本的应该是：<code>default</code>、<code>success</code>、<code>error</code>、<code>warning</code>、<code>primary</code>，分别对应着：默认、成功、失败、警告和主要。</p><blockquote><p>毕竟，日后也是可以在这个基础上进行增加的嘛。</p></blockquote><p>除了<code>type</code>，一个button还应该具有哪些？</p><p>我还写了以下这些，方便开发者能够迅速的开发：</p><ul><li><code>size</code>：default，large，small</li><li><code>width</code>、<code>height</code>、<code>color</code>、<code>background</code>：一些基础的样式</li><li><code>borderColor</code>：最近在网上看那种幽灵按钮很好看，于是也把这个写了进去，但是还没做</li><li><code>disabled</code>：用来做按钮禁用的</li><li><code>handleClick</code>：点击事件</li></ul><p>暂时，这个button组件仅支持这些内容，日后还会更新一些新的type和一些样式的参数方便大家使用。</p><h3 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h3><p>组件库名字暂时定为：<strong>vstu-ui</strong></p><blockquote><p>起名鬼才的我，v：是Vue的组件，stu：学生，代表这个组件库，是由身为学生的我们开发的。</p></blockquote><p>开发者：我和我的三个小学弟</p><blockquote><p>秉持着边开发边学习的理念，提高自己。</p></blockquote><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>这个组件库暂时未发布到npm上，也暂时没有开源到github/gitee上呢，当这个组件库具有一定数量的组件后会同时上传，发布后希望大家给与支持，你们的issue是我们坚持下去的动力！</p>]]></content>
      
      
      <categories>
          
          <category> 经历 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>假期总结（暑假结束！）</title>
      <link href="/posts/1009533019.html/"/>
      <url>/posts/1009533019.html/</url>
      
        <content type="html"><![CDATA[<h2 id="假期总结"><a href="#假期总结" class="headerlink" title="假期总结"></a>假期总结</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>短暂的暑假就这么结束了，简单做个复盘，看看自己暑假都做了什么。</p><blockquote><p>关于我</p><p>一个在校生（开学大三）</p><p>我的主页：<a href="https://wangez.site/">Ned - 我的主页</a></p><p>简单描述：<a href="https://blog.wangez.site/about/">Ned - 关于我</a></p></blockquote><hr><span id="more"></span><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p>共计更文十五篇</p><p>从7.16开始： <a href="https://blog.wangez.site/posts/1173819435.html/">JS中，函数原来有这么多种定义方法（暑假开始！）</a></p><p>到9.5号的：<a href="https://blog.wangez.site/posts/3558445990.html/">中秋想赏月却不想出门怎么办 </a></p><p>我的博客：<a href="https://blog.wangez.site/">Ned - Blog</a></p><p>感想：要坚持下去，慢慢的，提高质量，加强深度。</p><hr><h3 id="掘金社区"><a href="#掘金社区" class="headerlink" title="掘金社区"></a>掘金社区</h3><p>参与了三个活动，发布了十余篇文章</p><p>获得了150+点赞，2000+浏览量</p><p>参与活动获得了掘金的升级证书，抱枕，杯子等字节周边</p><p>我的主页：<a href="https://juejin.cn/user/105972016875911/posts">Ned 的个人主页 - - 掘金 </a></p><p>感想：采用参加活动的方式来督促自己更文学习，确实是一种较为不错的方式，但是<strong>八月更文活动</strong>，这种31天连续更文会把作者榨干的，确实肝不动，另外发布自己的理解到社区上，也会有好心的大佬来指点，看自己理解有没有错误之类的（我就很幸运的受到了点拨），也能认识许多有趣的人。</p><hr><h3 id="字节青训营"><a href="#字节青训营" class="headerlink" title="字节青训营"></a>字节青训营</h3><p>参与了字节于暑假举办的青训营活动，听了月影、李松峰等老师所讲解的知识，收获甚多。</p><p>跟认识的小伙伴顺利完成了最终青训营的大作业，仿掘金抽奖。</p><p>了解到这个阶段的前端大佬们都学到了什么程度，自己学习的动力更足了（不比永远不知道自己有多菜）。</p><p>技术栈采用的是：express+vue</p><p>项目地址：<a href="https://github.com/yiyu66/raffle">仿掘金抽奖</a></p><p>感想：第一次采用github参与到多人协作中（之前都是要么在gitee，要么自己一个人做），我们小队都是大三的，交流都十分顺畅，但是人家大三都已经工作了一段时间了，我们学校还不放我走，呜呜呜。</p><hr><h3 id="在线简历App"><a href="#在线简历App" class="headerlink" title="在线简历App"></a>在线简历App</h3><p>做移动应用开发大赛，用uni-app做了个app，第一次自己完全的从头至尾去制作app，踩了很多坑，也修了很多bug。</p><p>前端技术栈：uni-app+uView</p><blockquote><p>连续尝试40+小时未解决的bug</p><p>谁知道用uni-app做的app如何导出pdf？</p><p>Renderjs，在uni-app里返回函数为何频频失效？</p><p>uni-app，操作dom也太费劲了。</p></blockquote><p>感想：在uni-app生态没有再好一点之前，我应该是不太想使用了，属实太累了，网上的资源太少，官方文档的解释也不是很到位，甚至社区都是暂时的解决方案，没有一个良好的解决方案。</p><hr><h3 id="力扣"><a href="#力扣" class="headerlink" title="力扣"></a>力扣</h3><p>坚持了一阵子的力扣刷题，后来发现算法还是太差，于是找了个课，准备补习一下。</p><blockquote><p>课最近在网盘里吃灰</p></blockquote><p>算法一直被我放在后面，但是发现缺少这玩意还真不行。</p><hr><h3 id="牛客"><a href="#牛客" class="headerlink" title="牛客"></a>牛客</h3><p>在牛客上做了几套题，才意识到算法在笔试中的重要性，所以才有了刷力扣，补习算法的一系列操作。</p><ul><li>字节青训营的笔试：有关于前端知识点都是很基础的，但是都是多选，所以有点莫能两可的感觉，觉得自己还是不扎实；第一个算法题在力扣上之前做过，会做，但是牛客的笔试跟之前刷题不一样的地方在于他不给输入输出，所以一下子蒙圈了，没有写出来，第二个算法题就直接死亡了，一点思路没有，后来出来跟小伙伴们语音得知，好像要动态规划，不会。</li><li>做了几套其他企业的前端/技术笔试题：知识点主要集中在计网，算法，操作系统（前端较少，不知道是不是我刷的少），发现自己现在忽略了科班的东西，还是应该重视大学中的基础（要不在学学我就得走社招了？？）。</li></ul><p>之前六七月份在牛客上买了2022届秋招的冲刺课，知识点跟讲解都还不错的，两个小时的视频往往要看好几遍才能懂一丝。到目前为止除了Vue相关还没看之外其他的都看的差不多了。（Vue的不是不看我打算学完B站那个视频回来在看）</p><hr><h3 id="这个假期学习情况"><a href="#这个假期学习情况" class="headerlink" title="这个假期学习情况"></a>这个假期学习情况</h3><p>RN看了一些，心思假期做点东西来着，但是流产了。</p><p>Node重新学了一遍基础（上次看已经是大一的事情了），自己照着教程做了一个网页版的小游戏，能够利用express做一些简单的小接口（但是还要依赖我们万能的搜索引擎）。</p><p>uni-app，暂时拥有了强大的debug能力，对于某些地方的报错有着强烈的记忆能力（折磨死我了），并对于百度上的一些资源有着辨别真假的能力。</p><p>ES6，对于promise async await的封装有一些简单的应用，其他某些方面也能够较为多的应用了一些。</p><p>Vue，看了B站黑马的Vue3，还没看完。</p><p>参加了字节的青训营，学了很多之前没有注意的点跟新知识。</p><hr><h3 id="下学期学习计划？"><a href="#下学期学习计划？" class="headerlink" title="下学期学习计划？"></a>下学期学习计划？</h3><p>Vue3是优先级最高的，其次还是前端基础，让自己更了解的全面一些吧。</p><p>Node的程度暂时我只想学到可以自己做小demo的程度，也就是传说中的简历上写<strong>了解</strong>的程度，暂时就可以了。</p><p>算法的话，每天都要看一点，一个知识点一个知识点去滚（难滚也得滚）。</p><p>计网，在面试前疯狂吸收吧（这玩意应该也属于基础）。</p><blockquote><p>写到这我又想起来了，小马哥的视频也在网盘里吃灰！</p></blockquote><p>害，老吃灰人了！</p><img src="/posts/1009533019.html/happy.webp" style="zoom:50%;"><hr><h3 id="总结完毕"><a href="#总结完毕" class="headerlink" title="总结完毕"></a>总结完毕</h3><blockquote><p> 另：哪位友友有详细的前端校招八股的整理的知识点，可否给一份，最近掘金掘的太苦了。</p></blockquote><p>对了，还要多看书，深入浅出Vue跟红宝书都看一看吧，别吃灰了。</p><p>就酱！上学！</p><img src="/posts/1009533019.html/kaixue.webp" alt="z" style="zoom:60%;">]]></content>
      
      
      <categories>
          
          <category> 经历 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中秋想赏月却不想出门怎么办</title>
      <link href="/posts/3558445990.html/"/>
      <url>/posts/3558445990.html/</url>
      
        <content type="html"><![CDATA[<h1 id="中秋想看月亮还不想出门怎么办"><a href="#中秋想看月亮还不想出门怎么办" class="headerlink" title="中秋想看月亮还不想出门怎么办"></a>中秋想看月亮还不想出门怎么办</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>是不是快到中秋节了？</p><p>中秋节，团圆的日子，先祝各位节日快乐，身体健康！</p><p>在吃过团圆饭后，我们是不是还有一个传统的习俗，就是赏月。古时候，人们都住在庭院里，没有现在的高楼大厦，吃完饭在院子里一坐，谈话赏月。</p><blockquote><p> 一壶茶，一家人，岂不快哉~</p></blockquote><p>但是问题来了，现如今我们的生活节奏太快了，楼房遍地都是，很少人有雅兴去能够静下心来去做赏月这回事，很有可能是当天晚上因为出去办事，顺便照个相，发个pyq，赏月结束。</p><p>但是大家放心，我们是谁？伟大的程序员啊，我们当然可以做到，足不出户的赏月~</p><span id="more"></span><h3 id="开始造月"><a href="#开始造月" class="headerlink" title="开始造月"></a>开始造月</h3><p>首先我们先来一个黑色的背景板，当作夜空，在其中放上一个<code>div</code>，接下来造月用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>&#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-tag">body</span>&#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: black;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;moon&quot;</span> <span class="attr">title</span>=<span class="string">&quot;这是一个月亮&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来就是为这个<code>div</code>月亮添加样式了，月亮嘛，得是白色，圆的是吧，所以我们添加上这些CSS样式，因为居中好看一些，所以我们在body中添加了样式使得月亮垂直水平居中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.moon</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">8em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">8em</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们的月亮是这样子的。</p><p><img src="/posts/3558445990.html/moon.png"></p><p>嗯，是一个月亮的样子了，但是我觉得这还不够，一个月亮怎么能够没有光辉呢？加上！光辉这里，我的思路是加上白色的阴影，这样在黑色的衬托下就会显得像有光辉一样。</p><p>所以我们加上这个：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.moon</span>&#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">40px</span> white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/3558445990.html/moonLight.png"></p><p>至此，我们中秋所看见的圆月就造完了，小伙伴们就可以在家赏月了😏，下面再做两个月亮不是圆月的样子。</p><p><img src="/posts/3558445990.html/threeMoon.png"></p><p>总体的代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-around;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.moon1</span>,<span class="selector-class">.moon2</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">8em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">8em</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.moon1</span>&#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">40px</span> white;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.moon2</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> white;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.moon2</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">8em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">8em</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.moon3</span>&#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">8em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">8em</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1.5em</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-color</span>: white;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;moon1&quot; title=&quot;这个是刚刚做的圆月&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;moon2&quot; title=&quot;这个月亮右侧不能设置光辉&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;moon3&quot; title=&quot;这个月亮由边框设置的，不能设置光辉&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="再谈月亮"><a href="#再谈月亮" class="headerlink" title="再谈月亮"></a>再谈月亮</h3><p>有心的小伙子可以看出，第二和第三个月亮的实现方式并不一样。那我们再来说一下他们是如何实现的吧。</p><h4 id="第二个月亮"><a href="#第二个月亮" class="headerlink" title="第二个月亮"></a>第二个月亮</h4><p>我们用两个纸片，用剪刀裁剪成相同大小的圆，把他们重叠在一起，错开位置，这样的形状就是我们想要的了。在css中也是一样的道理，利用伪元素，制造一个相同大小的圆，完后用黑色的圆去遮盖白色圆的右边（利用相对定位）。</p><p>下面再贴一次代码，方便大家看（只贴了css部分）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.moon1</span>,<span class="selector-class">.moon2</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">8em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">8em</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.moon2</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> white;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.moon2</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">8em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">8em</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样的圆的圆弧一侧是没有光辉的，因为那里是遮盖形成的。</p><h4 id="第三个月亮"><a href="#第三个月亮" class="headerlink" title="第三个月亮"></a>第三个月亮</h4><p>第三个月亮我们是用边框来做的。设置元素的左边框的宽度，再设置一个圆角使他变成一个弧形，别忘了把边框的颜色改成白色，这样就好啦。</p><blockquote><p>注意，这个不能设置光辉，也就是阴影哦~ </p><p>要不，要不就露馅啦！</p><p>（加个boder-shadow去试试吧，嘿嘿）</p></blockquote><p>下面也贴一下它的代码，方便观察：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.moon3</span>&#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">8em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">8em</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1.5em</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-color</span>: white;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>还是要提前祝大家中秋节快乐呀！月饼🥮🥮🥮🥮🥮，记得吃一块，沾沾节气。</p><p>不出意外的话，这应该是开学前的倒数第二篇啦，开学前应该还有一篇来做一下假期总结的（情感博主再次上线）</p><p><img src="/posts/3558445990.html/holiday.webp"></p>]]></content>
      
      
      <categories>
          
          <category> Css </category>
          
          <category> 经历 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的设计模式-代理模式</title>
      <link href="/posts/1278378512.html/"/>
      <url>/posts/1278378512.html/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>学学设计模式，每次更一个，实在太多了。</p><p>第一次更新：<strong>单例模式</strong></p><p>第二次更新：<strong>策略模式</strong></p><p>第三次更新：<strong>代理模式</strong></p><blockquote><p>打算10月前将JavaScript滚个百分之六七十，不知道能不能学完。</p><p>计网操作系统数据结构算法还没学</p><p>vue还没盘</p><p>我还有机会吗</p></blockquote><span id="more"></span><h3 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a>什么是设计模式？</h3><p>在软件设计过程中，针对特定问题的简洁而优雅的解决方案。</p><p>把之前的经验总结并且合理运用到某处场景上，能够解决实际的问题。</p><h3 id="设计模式五大设计原则（SOLID）"><a href="#设计模式五大设计原则（SOLID）" class="headerlink" title="设计模式五大设计原则（SOLID）"></a>设计模式五大设计原则（SOLID）</h3><ul><li><p>S-单一职责原则</p><blockquote><p>即一个程序只做好一件事</p></blockquote></li><li><p>O-开放封闭原则</p><blockquote><p>可扩展开放，对修改封闭</p></blockquote></li><li><p>L-里氏置换原则</p><blockquote><p>子类能覆盖父类，并能出现在父类出现的地方</p></blockquote></li><li><p>I-接口独立原则</p><blockquote><p>保持接口的单一独立</p></blockquote></li><li><p>D-依赖导致原则</p><blockquote><p>使用方法只关注接口而不关注具体类的实现</p></blockquote></li></ul><h3 id="为什么需要设计模式？"><a href="#为什么需要设计模式？" class="headerlink" title="为什么需要设计模式？"></a>为什么需要设计模式？</h3><ul><li><p>易读性</p><blockquote><p>使用设计模式能够提升我们的代码可读性，提升后续开发效率</p></blockquote></li><li><p>可拓展性</p><blockquote><p>使用设计模式对代码解耦，能很好的增强代码的yi修改性和拓展性</p></blockquote></li><li><p>复用性</p><blockquote><p>使用设计模式可以复用已有的解决方案，无需重复相同工作</p></blockquote></li><li><p>可靠性</p><blockquote><p>使用设计模式能够增加系统的健壮性，使代码编写真正工程化</p></blockquote></li></ul><h3 id="常见设计模式"><a href="#常见设计模式" class="headerlink" title="常见设计模式"></a>常见设计模式</h3><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>定义：<strong>唯一&amp;全局访问。保证一个类仅有一个实例，并提供一个访问它的全局访问点。</strong></p><blockquote><p>另外一种多例模式，通过一个类构造出多个不一样的实例，这就是多例模式。</p><p>单例模式与多例模式最本质的区别：实例的数量。</p><p>单例模式永远只有一个实例，这个实例可以被缓存起来，可以复用。</p></blockquote><p>应用场景：就是能被缓存的内容，例如登录弹窗。</p><blockquote><p>我觉得就是一个地方如果在你的项目中可以用到两次或两次以上，都可以尝试一下这个，能够减少很多代码。</p></blockquote><p>来看这段伪代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> creatLoginLayer = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">    div.innerHtml = <span class="string">&quot;登录浮窗&quot;</span>;</span><br><span class="line">    div.style.display = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">    <span class="keyword">return</span> div;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;loginBtn&quot;</span>).onclick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> loginLayer = creatLoginLayer();</span><br><span class="line">    loginLayer.style.display = <span class="string">&quot;block&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>creatLoginLayer</code>的作用是创建一个登录浮窗并将节点添加到body上，下面做的是登录按钮的一个点击事件，点击登录按钮就会创建登录浮窗并将<code>display</code>从<code>none</code>改为<code>block</code>，将他显示出来。</p><p>这个逻辑是没毛病的，但是我们想一下，每点击一下登录按钮就要执行这些代码，一个项目中如果有很多地方要呢？我们上面这短短几行而已，如果是上百上千甚至上万呢？是不是就非常损耗性能，这个时候，我们的单例模式就派上了用场。</p><p>使用单例模式后：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getSingle = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...rest</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result || (result = fn.apply(<span class="built_in">this</span>.rest));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> creatLoginLayer = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">    div.innerHtml = <span class="string">&quot;登录浮窗&quot;</span>;</span><br><span class="line">    div.style.display = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">    <span class="keyword">return</span> div;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createSingleLoginLayer = getSingle(createLoginLayer);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;loginBtn&quot;</span>).onclick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> loginLayer = createSingleLoginLayer();</span><br><span class="line">    loginLayer.style.display = <span class="string">&quot;block&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以见到，增加了一个<code>getSingle</code>函数，这里有个闭包的概念，result变量只要一直在引用就不会被销毁，起到了一个缓存的作用，函数的参数是一个<code>function</code>，如果result是null或者undefined就执行后面的逻辑，将这个传进来的函数的返回值也就是这个<code>div</code>赋给result，这样我们下面的函数就执行一次就可以了，下次调用的时候result有值，所以就直接返回了，不会在执行后面的逻辑。</p><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>定义：<strong>定义一系列的算法，把它们一个个的封装起来，并且使它们可以相互转换。把看似毫无联系的代码提取封装、复用，使之更容易被理解和拓展</strong></p><blockquote><p>它就像我们解决问题的思路，有很多种，那我们就应该选择最适合解决当前业务的那一种。</p></blockquote><p>应用场景：要完成一件事情，有不同的策略。例如绩效计算、表单验证规则。</p><p>来看这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> calculateBonus = <span class="function">(<span class="params">level, salary</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (level) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>: &#123;</span><br><span class="line">            <span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>: &#123;</span><br><span class="line">            <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: &#123;</span><br><span class="line">            <span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attr">default</span>: &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strategies[level][salary];</span><br><span class="line">&#125;;</span><br><span class="line">calculateBonus[<span class="string">&#x27;s&#x27;</span>,<span class="number">20000</span>];</span><br></pre></td></tr></table></figure><p>函数<code>calculateBonus</code>接收level跟salary两个参数，运用switch case来计算绩效。但是在以后我们又要增加新绩效的时候，例如我们想加一个p绩效，我们要深入到代码中，去在switch case中去增加一个 case p的逻辑，这样子我们相当于每次业务变更都要去改造这个函数，就是不太好的情况。</p><blockquote><p>使用switch还好，代码看起来很清晰，如果是if else呢   不敢想象了~</p></blockquote><p>再看策略模式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> strategies = &#123;</span><br><span class="line">    <span class="attr">s</span>: <span class="function">(<span class="params">salary</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">a</span>: <span class="function">(<span class="params">salary</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">b</span>: <span class="function">(<span class="params">salary</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> caculateBonus = <span class="function">(<span class="params">level, salary</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> strategies[level][salary];</span><br><span class="line">&#125;;</span><br><span class="line">caculateBonus(<span class="string">&#x27;s&#x27;</span>,<span class="number">20000</span>)</span><br></pre></td></tr></table></figure><p>也是有着一个<code>caculateBonus</code>函数，接收level跟salary两个参数，但是我们构建了一个策略表，在策略表中维护这个计算规则。这时候如果要加入一个新绩效等级，就去表中加入一个新等级，再加入它的计算规则即可，并且可以将表提取出来放到另一个文件中，甚至是放到公网上下发，因为这个表是可以不用程序员们来维护的，可以做成页面交给公司其他人员去维护，就有了前面说的那个下发的功能，可以去给别人展示。计算绩效的时候去读取策略表，完后根据表中规则来进行计算就行。</p><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>定义：<strong>为一个对象提供一个代用品或者占位符，以便控制对它的访问。替身对象可对请求预先进行处理，再决定是否转交给本体对象。</strong></p><blockquote><p>假如项目中一个图片过大，短时间内加载不出来的时候，用户只能看见白屏，体验感就会非常糟糕，这时候我们就可以用一个替身来暂时替代图片。</p><p>当真身被访问的时候，我们先访问替身对象，让替身代替真身去做一些事情，之后在转交给真身处理。     </p></blockquote><p>应用场景：当我们不方便直接访问某个对象时，或不满足需求时，可考虑使用一个替身对象来控制该对象的访问。</p><p>来看这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生函数</span></span><br><span class="line"><span class="keyword">const</span> rawImage = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> imgNode = <span class="built_in">document</span>.createElement(<span class="string">&quot;img&quot;</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(imgNode);</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">setSrc</span>:<span class="function">(<span class="params">src</span>)=&gt;</span> &#123;</span><br><span class="line">imgNode.src = <span class="string">&quot;./loading.gif&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.src = src;</span><br><span class="line">img.onload = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">imgNode.src = <span class="built_in">this</span>.src;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">rawImage.setSrc(<span class="string">&quot;http://xxx.gif&quot;</span>);</span><br></pre></td></tr></table></figure><p>这个xxx.gif的加载时间可能要到10s左右，我们首先预加载了一个loading图，用户看到的过程是最开始看见loading，当xxx加载完成后，也就是onload执行完后，就会做一个替换的效果，完成了这个功能。</p><p>思考：这段代码是不是耦合性太强了啊？</p><p>是的，loading的逻辑跟我们实际加载的逻辑是耦合在一起的，我们要做两个事情，一个是设置loading，一个是设置图片链接。那我们给他分开，用代理函数去做预处理，加载loading，用原生函数提供一个设置图片链接的功能。</p><p>实现一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生函数</span></span><br><span class="line"><span class="keyword">const</span> rawImage = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> imgNode = <span class="built_in">document</span>.createElement(<span class="string">&quot;img&quot;</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(imgNode);</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">setSrc</span>:<span class="function">(<span class="params">src</span>)=&gt;</span> &#123;</span><br><span class="line">imgNode.src = src;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理函数</span></span><br><span class="line"><span class="keyword">const</span> proxyImage = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.onload = <span class="function">() =&gt;</span>&#123;</span><br><span class="line">rawImage.setSrc(<span class="built_in">this</span>.src);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">setSrc</span>:<span class="function">(<span class="params">src</span>) =&gt;</span> &#123;</span><br><span class="line">rawImage.setSrc(<span class="string">&quot;./loading.gif&quot;</span>);</span><br><span class="line">img.src = src;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">proxyImage.setSrc(<span class="string">&quot;http://xxx.gif&quot;</span>);</span><br></pre></td></tr></table></figure><p>我们通常会进行一些请求的预处理的时候使用代理模式。</p><h4 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h4><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><h4 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h4><h4 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h4><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享一次踩坑，一次自己封装的uni官方api</title>
      <link href="/posts/1196783753.html/"/>
      <url>/posts/1196783753.html/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这几天在做一个app，用来打比赛用，使用的是uni+uView的组件库。这个组件库是半道加进来的，学弟推荐的，我看有组件的话确实会方便很多，而且他都是按需引入，不占用额外空间，挺好的，我也就直接拿来用了。</p><p>使用感想：感觉这套技术栈跟vue+element差不多了emm，就是某些官方api还不太一样，还是比较顺手的。</p><p>组件库传送门：<a href="https://www.uviewui.com/components/intro.html"> uView - 多平台快速开发的UI框架 </a></p><p>但是，不熟悉组件的api以及参数，让我踩了坑，非常难受emm，还是写个记录，长长记性。</p><p>本次内容：分享一个踩坑，一个自己进行封装的uni官方api</p><blockquote><p>毕竟踩坑日记专栏好久没更新了。</p></blockquote><span id="more"></span><h3 id="坑：uView组件库，uToast组件"><a href="#坑：uView组件库，uToast组件" class="headerlink" title="坑：uView组件库，uToast组件"></a>坑：uView组件库，uToast组件</h3><p>传送门：<a href="https://www.uviewui.com/components/toast.html">Toast 消息提示 </a></p><p>使用方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将这个标签放在页面中</span></span><br><span class="line">&lt;u-toast ref=<span class="string">&quot;uToast&quot;</span> /&gt;</span><br><span class="line"><span class="comment">// 需要消息提示的话，加上如下代码</span></span><br><span class="line"><span class="built_in">this</span>.$refs.uToast.show(&#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;登录成功&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;success&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/pages/user/index&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><p><code>title</code>:消息提示显示的文本</p></li><li><p><code>type</code>:主题类型，不填默认为<code>default</code>（一共有6中主题色）</p></li><li><p><code>url</code>:toast结束跳转的url，不填不跳转</p></li></ul><blockquote><p>更多详细api请点击上方toast传送门去到该组件库官网看</p></blockquote><p>我遇到的坑，便是填写了url，他执行结束后不跳转。</p><p>说一下我的大致使用情况：</p><p>登录成功后弹出消息提示登录成功，完后跳转到一个tab页面上去。但是他只给弹出登录成功，不报错也不跳转。当时真的人傻了，找了好多地方，也打了断点，所有的事情都告诉我一切正常。于是我开始怀疑起我的电脑emm，我将整个程序打包，发给了我的学弟，让他在他电脑上帮我调试一下，结果与我电脑一致（nice！那就是电脑没坏，还能用），在我吃完饭回到电脑前准备跟这个问题决一死战的时候，学弟发来的一张截图让我人呆滞了。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th><th>类型</th><th>默认值</th><th>可选值</th></tr></thead><tbody><tr><td>isTab</td><td>toast结束后，跳转tab页面时需要配置为<code>true</code></td><td>Boolean</td><td>fasle</td><td>true</td></tr></tbody></table><p>没错，就是这个表格。我才知道这个组件要是跳转到tab页面的话还需要额外配置一个参数，赶忙加上，于是我又从坑中站了起来。</p><h4 id="关于toast结束跳转URL"><a href="#关于toast结束跳转URL" class="headerlink" title="关于toast结束跳转URL"></a>关于toast结束跳转URL</h4><ul><li>如果配置了<code>url</code>参数，在toast结束的时候，就会用<code>uni.navigateTo</code>(默认)或者<code>uni.switchTab</code>(需另外设置<code>isTab</code>为<code>true</code>)</li><li>如果配置了<code>params</code>参数，就会在跳转时自动在URL后面拼接上这些参数，具体用法如下：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$refs.uToast.show(&#123;</span><br><span class="line"><span class="attr">title</span>: <span class="string">&#x27;操作成功&#x27;</span>,</span><br><span class="line"><span class="attr">url</span>: <span class="string">&#x27;/pages/user/index&#x27;</span>,</span><br><span class="line"><span class="attr">params</span>: &#123;</span><br><span class="line"><span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">menu</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个故事告诉我们，大家使用之前一定要摸清楚api，不要学习泽泽！！！</p><h3 id="封装uni-getStorage函数"><a href="#封装uni-getStorage函数" class="headerlink" title="封装uni.getStorage函数"></a>封装uni.getStorage函数</h3><p>这个应该不算坑，我只是觉得他这个使用起来不是很方便（好像是相当不方便）</p><p>传送门：<a href="https://uniapp.dcloud.io/api/storage/storage?id=getstorage">uni.getStorage </a></p><p>它的作用就是从本地缓存中异步获取指定 key 对应的内容。</p><p>我的需求就是要从缓存中获取一些我之前存入进去的东西，但是我取一个还好，某一处需要取两个的话要把这个函数写两次，反正我本人是觉得很麻烦的（即使CV不麻烦，但在程序员眼中，代码相似程度有点高），那为什么不尝试着封装一下呢？</p><p>函数本来的样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uni.getStorage(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;storage_key&#x27;</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>他是根据<code>key</code>，去取缓存中的数据，完后返回值<code>res.data</code>中就是我们需要的数据了。</p><p>思路就是：传一个<code>key</code>给他，同时接好<code>res.data</code>的值</p><p>改造前：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">uni.getStorage(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;token&#x27;</span>,</span><br><span class="line">    <span class="attr">success</span>:<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;token:&#x27;</span>+ res.data)</span><br><span class="line">        <span class="built_in">this</span>.token = res.data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">uni.getStorage(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;username&#x27;</span>,</span><br><span class="line">    <span class="attr">success</span>:<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;username&#x27;</span> + res.data)</span><br><span class="line">        <span class="built_in">this</span>.userInfo.username = res.data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>改造后：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">getCache</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a:&#x27;</span>+a)</span><br><span class="line">    uni.getStorage(&#123;</span><br><span class="line">        <span class="attr">key</span>:a,</span><br><span class="line">        <span class="attr">success</span>:<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;res.data:&#x27;</span>+res.data);</span><br><span class="line">            b = res.data;</span><br><span class="line">            <span class="keyword">return</span> res.data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>需要调用的时候这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="built_in">this</span>.getCache(<span class="string">&#x27;username&#x27;</span>)</span><br></pre></td></tr></table></figure><p>是不是非常的方便呢？</p><blockquote><p>封装，yyds</p></blockquote><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>踩坑可以迟到，但永远不会缺席，我们能做的就是每次细心一点，并且把犯过的错，背过的锅记录在小本本上，再也不去犯第二次。</p><p>毕竟，神也会犯错呀！</p><p>祝愿天下的程序员都少一点bug吧。</p><h3 id="改进上面的封装函数"><a href="#改进上面的封装函数" class="headerlink" title="改进上面的封装函数"></a>改进上面的封装函数</h3><p>自己今天使用的时候发现，这样封装只能单页面内使用，可是一个项目中，我有好几处都要使用，就只能复制粘贴。</p><blockquote><p>那我不又成了cv程序员？？？</p></blockquote><p>于是我继续开始封装，想把它以组件的方法进行封装。</p><p><code>cache.js</code>，我给他放在了common文件夹内</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getCache</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> b = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a:&#x27;</span>+a)</span><br><span class="line">uni.getStorage(&#123;</span><br><span class="line"><span class="attr">key</span>:a,</span><br><span class="line"><span class="attr">success</span>:<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;res.data:&#x27;</span>+res.data);</span><br><span class="line">b = res.data;</span><br><span class="line"><span class="keyword">return</span> res.data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>使用方法：</strong></p><p>在需要使用这个函数的页面进行引入就好，方法类似于我们按需引入组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;getCache&#125; <span class="keyword">from</span> <span class="string">&#x27;common/cache.js&#x27;</span></span><br></pre></td></tr></table></figure><p>使用的时候直接进行调用就好。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.username = getCache(<span class="string">&#x27;username&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 移动端 </category>
          
          <category> uni-app </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑日记 </tag>
            
            <tag> uni-app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于浏览器的渲染进程</title>
      <link href="/posts/3321770798.html/"/>
      <url>/posts/3321770798.html/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近都在跟着青训营学习，不跟着学习的时候也去看node的相关课程了，很少有自己去学一些别的知识，刚好今天的学习任务量较少，进度赶出来了，晚上无聊，看了看之前感兴趣的重绘重排的相关知识，梳理了一下浏览器的相关原理，挑出一部分，记录在博客上。</p><blockquote><p>纯记录</p></blockquote><h3 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h3><p>渲染进程的<strong>核心工作是将HTML,CSS和JavaScript转换为用户可以与之交互的网页。</strong>主要包括以下线程：</p><span id="more"></span><h4 id="浏览器-GUI-渲染线程"><a href="#浏览器-GUI-渲染线程" class="headerlink" title="浏览器 GUI 渲染线程"></a>浏览器 GUI 渲染线程</h4><h5 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h5><p><img src="/posts/3321770798.html/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E5%B7%A5%E4%BD%9C.png" alt="image-20210615171514782"></p><ul><li>分层的目的：避免整个页面渲染，把页面分成多个图层，尤其是动画的时候，把动画独立出一个图层，渲染时只渲染该图层就ok，transform，z-index等，浏览器会自动优化生成图层</li><li>光栅化：页面如果很长但是可视区很小，避免渲染非可视区的样式造成资源浪费，x以将每个图层又划分成多个小个子，当前只渲染可视区附近区域</li></ul><h5 id="重排"><a href="#重排" class="headerlink" title="重排"></a>重排</h5><ul><li><p>重排 ：当DOM的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排</p></li><li><p>重排特点：style后面所有流程都更新</p></li></ul><p><img src="/posts/3321770798.html/image-20210615172629674.png" alt="image-20210615172629674"></p><ul><li><p>触发重排的方法</p><ul><li><p>页面初始渲染，这是开销最大的一次重排</p></li><li><p>添加/删除可见的DOM元素</p></li><li><p>改变元素位置</p></li><li><p>改变元素尺寸，比如边距、填充、边框、宽度和高度等</p></li><li><p>改变元素内容，比如文字数量，图片大小等</p></li><li><p>改变元素字体大小</p></li><li><p>改变浏览器窗口尺寸，比如resize事件发生时</p></li><li><p>激活CSS伪类（例如：<code>:hover</code>）</p></li><li><p>设置 style 属性的值，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow</p><p>查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等</p></li></ul></li></ul><h5 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h5><ul><li><p>重绘：当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程</p></li><li><p>重绘特点：跳过布局和分层阶段</p></li></ul><p><img src="/posts/3321770798.html/image-20210615172906367.png" alt="image-20210615172906367"></p><ul><li>重排必重绘</li></ul><h5 id="避免重排的方法"><a href="#避免重排的方法" class="headerlink" title="避免重排的方法"></a>避免重排的方法</h5><ul><li><p>样式集中改变</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> left = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> top = <span class="number">10</span>;</span><br><span class="line">el.style.left = left + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">el.style.top = top + <span class="string">&quot;px&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当top和left的值是动态计算而成时...</span></span><br><span class="line"><span class="comment">// better </span></span><br><span class="line">el.style.cssText += <span class="string">&quot;; left: &quot;</span> + left + <span class="string">&quot;px; top: &quot;</span> + top + <span class="string">&quot;px;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// better</span></span><br><span class="line">el.className += <span class="string">&quot; className&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用 absolute 或 fixed 脱离文档流</p><p>使用绝对定位会使的该元素单独成为渲染树中 <code>body</code> 的一个子元素，重排开销比较小，不会对其它节点造成太多影响。当你在这些节点上放置这个元素时，一些其它在这个区域内的节点可能需要重绘，但是不需要重排</p></li><li><p>GPU加速:transform</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 根据上面的结论</span></span><br><span class="line"><span class="comment">* 将 2d transform 换成 3d</span></span><br><span class="line"><span class="comment">* 就可以强制开启 GPU 加速</span></span><br><span class="line"><span class="comment">* 提高动画性能</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">10px</span>, <span class="number">10px</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="JavaScript-引擎线程"><a href="#JavaScript-引擎线程" class="headerlink" title="JavaScript 引擎线程"></a>JavaScript 引擎线程</h4><p>JS引擎线程负责解析Javascript脚本，运行代码 JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序</p><p>GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞</p><h4 id="浏览器定时触发器线程"><a href="#浏览器定时触发器线程" class="headerlink" title="浏览器定时触发器线程"></a>浏览器定时触发器线程</h4><p>浏览器定时计数器并不是由 JavaScript 引擎计数的, 因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案</p><h4 id="浏览器事件触发线程"><a href="#浏览器事件触发线程" class="headerlink" title="浏览器事件触发线程"></a>浏览器事件触发线程</h4><p>当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX 异步请求等，但由于 JavaScript 的单线程关系所有这些事件都得排队等待 JavaScript 引擎处理。</p><h4 id="浏览器-http-异步请求线程"><a href="#浏览器-http-异步请求线程" class="headerlink" title="浏览器 http 异步请求线程"></a>浏览器 http 异步请求线程</h4><p>在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理。</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何写好JavaScript（下）</title>
      <link href="/posts/3177970664.html/"/>
      <url>/posts/3177970664.html/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在打开这个视频之前，我真没想到讲的是优化算法之类的东西，可能是<a href="https://blog.wangez.site/posts/98016397.html/#more">如何写好JavaScript（上 ）</a>迷惑了我。</p><p>有听懂的，有没懂的，先记下来，留着梳理。</p><h3 id="看一段代码"><a href="#看一段代码" class="headerlink" title="看一段代码"></a>看一段代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断一个mat2d矩阵是否是单位矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isUnitMatrix2d</span>(<span class="params">m</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m[<span class="number">0</span>] === <span class="number">1</span> &amp;&amp; m[<span class="number">1</span>] === <span class="number">0</span> &amp;&amp; m[<span class="number">2</span>] === <span class="number">0</span> &amp;&amp; m[<span class="number">3</span>] === <span class="number">1</span> &amp;&amp; m[<span class="number">4</span>] === <span class="number">0</span> &amp;&amp; m[<span class="number">5</span>] === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码好不好？ 为什么？</p><span id="more"></span><blockquote><p>这个代码从优雅程度上来说确实是有些过于长了，看起来不是十分的美观，我们可以使用类似于for循环的方式将其变得美观起来。</p><p>但是如果他是写在代码底层（spritejs）的话，这么写的性能是最好的，因为他直接拿到索引就可以来比较，是循环所比拟不了的。</p></blockquote><p><strong>月影大佬：我们所有的代码风格，都是根据场合来的，如果是一些框架或者开源的库中，看见了不是很优雅的代码，我们应该结合场景去分析，因为有的时候这么写是有理由的。</strong></p><p>写代码最应关注什么？</p><ul><li><p>风格：</p><blockquote><p>很重要，尤其是多人协作。关键在于风格要统一，否则会增加代码维护的成本。</p></blockquote></li><li><p>效率：</p><blockquote><p>要在心中明白，什么样子的代码效率是最高的，尽量结合场景选择最合适的代码（效率or可读性）。</p></blockquote></li><li><p>约定</p></li><li><p>使用场景</p></li><li><p>设计</p></li></ul><h3 id="当年的left-pad事件"><a href="#当年的left-pad事件" class="headerlink" title="当年的left-pad事件"></a><strong>当年的left-pad事件</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leftpad</span>(<span class="params">str, len, ch</span>)</span>&#123;</span><br><span class="line">    str = <span class="built_in">String</span>(str);</span><br><span class="line">    <span class="keyword">var</span> i = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!ch &amp;&amp; ch !== <span class="number">0</span>) ch=<span class="string">&quot; &quot;</span>;</span><br><span class="line">    len = len - str.length;</span><br><span class="line">    <span class="keyword">while</span>(++i&lt;len)&#123;</span><br><span class="line">        str = ch + str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事件本身的槽点"><a href="#事件本身的槽点" class="headerlink" title="事件本身的槽点"></a><strong>事件本身的槽点</strong></h4><ul><li><p>NPM模块粒度</p><blockquote><p>说npm模块粒度太细了，单个函数的模块。</p><p>当年模块化跟打包工具不是很成熟</p></blockquote></li><li><p>代码风格</p><blockquote><p>可读性还好</p></blockquote></li><li><p>代码质量/效率</p><blockquote><p>这个效率还可以，因为正常场景中不会拼接太长的字符串</p></blockquote></li></ul><h4 id="提高效率与代码简洁性"><a href="#提高效率与代码简洁性" class="headerlink" title="提高效率与代码简洁性"></a><strong>提高效率与代码简洁性</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leftpad</span>(<span class="params">str, len, ch</span>)</span>&#123;</span><br><span class="line">    str = <span class="string">&quot;&quot;</span> + str;</span><br><span class="line">    <span class="keyword">const</span> padLen = len - str.length;</span><br><span class="line">    <span class="keyword">if</span>(padLen &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="string">&quot;&quot;</span>+ch).repeat(padLen) + str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="交通灯：状态切换"><a href="#交通灯：状态切换" class="headerlink" title="交通灯：状态切换"></a><strong>交通灯：状态切换</strong></h3><p>实现一个切换<strong>多个</strong>交通灯<strong>状态切换</strong>的功能</p><h4 id="版本一"><a href="#版本一" class="headerlink" title="版本一"></a>版本一</h4><blockquote><p>不知道为什么听这个课，我现在觉得版本一就等于很垃圾</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> traffic = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;traffic&#x27;</span>);</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">reset</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    traffic.className = <span class="string">&#x27;s1&#x27;</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        traffic.className = <span class="string">&#x27;s2&#x27;</span>;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            traffic.className = <span class="string">&#x27;s3&#x27;</span>;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                traffic.className = <span class="string">&#x27;s4&#x27;</span>;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    traffic.className = <span class="string">&#x27;s5&#x27;</span>;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(reset,<span class="number">1000</span>)</span><br><span class="line">                &#125;,<span class="number">1000</span>)</span><br><span class="line">            &#125;,<span class="number">1000</span>)</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><blockquote><p>setTimeout本身是异步，将代码这样嵌套，会造成回调地狱的问题，而且代码很丑，可读性差，不方便维护。</p><p>看来跟我上边说的一样，版本一，都是垃圾，哈哈哈哈</p></blockquote><h4 id="版本二"><a href="#版本二" class="headerlink" title="版本二"></a>版本二</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> traffic = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;traffic&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> stateList = [</span><br><span class="line">    &#123;<span class="attr">state</span>: <span class="string">&#x27;wait&#x27;</span>, <span class="attr">last</span>: <span class="number">1000</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">state</span>: <span class="string">&#x27;stop&#x27;</span>, <span class="attr">last</span>: <span class="number">3000</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">state</span>: <span class="string">&#x27;pass&#x27;</span>, <span class="attr">last</span>: <span class="number">3000</span>&#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">traffic,stateList</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">applyState</span>(<span class="params">steteIdx</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;state,last&#125; = stateList[stateIdx];</span><br><span class="line">        traffic.className = state;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            applyState((stateIdx + <span class="number">1</span>) % stateList.length);</span><br><span class="line">        &#125;,last)</span><br><span class="line">    &#125;</span><br><span class="line">    applyState(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">start(traffic,stateList);</span><br></pre></td></tr></table></figure><blockquote><p>采用的函数封装的方法</p></blockquote><h4 id="版本三"><a href="#版本三" class="headerlink" title="版本三"></a>版本三</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> traffic = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;traffic&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">poll</span>(<span class="params">...fnList</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stateIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> fn = fnList[stateIndex++ % fnList.length];</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">    traffic.className = state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> trafficStatePoll = poll(setState.bind(<span class="literal">null</span>,<span class="string">&#x27;wait&#x27;</span>),</span><br><span class="line">setState.bind(<span class="literal">null</span>,<span class="string">&#x27;stop&#x27;</span>),setState.bind(<span class="literal">null</span>,<span class="string">&#x27;pass&#x27;</span>));</span><br><span class="line"><span class="built_in">setInterval</span>(trafficStatePoll,<span class="number">2000</span>);</span><br></pre></td></tr></table></figure><blockquote><p>抽象出一个轮巡的方法，采用高阶函数</p></blockquote><h4 id="版本四"><a href="#版本四" class="headerlink" title="版本四"></a>版本四</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> traffic = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;traffic&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">time</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve,time));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">    traffic.className = state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        setState(<span class="string">&#x27;wait&#x27;</span>);</span><br><span class="line">        <span class="keyword">await</span> wait(<span class="number">1000</span>);</span><br><span class="line">        setState(<span class="string">&#x27;stop&#x27;</span>);</span><br><span class="line">        <span class="keyword">await</span> wait(<span class="number">3000</span>);</span><br><span class="line">        setState(<span class="string">&#x27;pass&#x27;</span>);</span><br><span class="line">        <span class="keyword">await</span> wait(<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">start();</span><br></pre></td></tr></table></figure><blockquote><p>知道了异步，就肯定好做了呀，用async和await，命令式的写法。</p><p>可以继续保持异步采用声明式的封装继续去做出版本567.</p></blockquote><h3 id="判断是否是4的幂"><a href="#判断是否是4的幂" class="headerlink" title="判断是否是4的幂"></a><strong>判断是否是4的幂</strong></h3><h4 id="版本一-1"><a href="#版本一-1" class="headerlink" title="版本一"></a>版本一</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPowerOfFour</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    num = <span class="built_in">parseInt</span>(num);</span><br><span class="line">    <span class="keyword">while</span>(num&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num%<span class="number">4</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        num /= <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>很中规中矩的写法，每次对4取余，结果还是要能被4整除。</p></blockquote><h4 id="版本二-1"><a href="#版本二-1" class="headerlink" title="版本二"></a>版本二</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPowerOfFour</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    num = <span class="built_in">parseInt</span>(num);</span><br><span class="line">    <span class="keyword">while</span>(num&gt;<span class="number">1</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span>(num&amp; <span class="number">0b11</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       num &gt;&gt;&gt;=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>将对4取余数变成了判断二进制数的后两位，后两位是00就肯定是4的倍数，除以四变成右移两位。</p></blockquote><h4 id="版本三-1"><a href="#版本三-1" class="headerlink" title="版本三"></a>版本三</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPowerOfFour</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    num = <span class="built_in">parseInt</span>(num);</span><br><span class="line">    <span class="keyword">return</span> num &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (num&amp;(num - <span class="number">1</span>)) === <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (num&amp; <span class="number">0xAAAAAAAA</span>) === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>刚刚是 log的复杂度算法，这个是常数复杂度的算法</p><p>如果一个数是4的幂的话，转化二进制肯定只有首位是1的，并且后面跟着偶数个0，所以在这种情况下，判断只有一个1，并且还有偶数个0即可。</p></blockquote><h4 id="版本四-1"><a href="#版本四-1" class="headerlink" title="版本四"></a>版本四</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPowerOfFour</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    num = <span class="built_in">parseInt</span>(num).toString(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^1(?:00)*$/</span>.test(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理论与上一个同理，但是我真的震惊了，原来一个思路可以有这么多种解决方法。</p><p>但是相对来说，正则的开销会比数值的要大，但是在这个情景中还是可以接受的。</p></blockquote><h3 id="洗牌"><a href="#洗牌" class="headerlink" title="洗牌"></a><strong>洗牌</strong></h3><p>简单实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cards = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">cards</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...cards].sort(<span class="function">()=&gt;</span> <span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(shuffle(cards));</span><br></pre></td></tr></table></figure><blockquote><p>如果这是个抽奖程序的话，是会被打的。</p><p>因为不公平。和原来的位置相关。</p></blockquote><p>我们来验证一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cards = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">cards</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...cards].sort(<span class="function">()=&gt;</span> <span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="built_in">Array</span>(<span class="number">10</span>).fill(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">const</span> c = shuffle(cards);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j &lt; <span class="number">10</span>; j++)&#123;</span><br><span class="line">        result[j] += c[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><p>我们来调用上面的洗牌算法一万次，完后将每个位置上出现牌的点数都相加，如果他公平，我们相加的结果应该都差不多，对吧。</p><blockquote><p>[<br> 38511, 38548, 45148,<br> 46416, 46551, 44174,<br> 43456, 46877, 48894,<br> 51425<br>]</p></blockquote><p>这确是我打印出来的数据，连续跑了好几组都是某某要大，你将一万次改的越大，最后位置的数字就会越大，也就是说，小数字会出现在靠前的位置，大数字会出现在靠后的位置。</p><p>如果还不确认的小伙伴可以去做一下概率统计。</p><blockquote><p>这是因为sort会两两交换，每个位置上交换的次数是不同的，所以最后的数字在交换到前面的概率是比较小的，当次数被无限放大的时候，这个差距就是越来越大。所以导致刚刚的洗牌算法是不公平的。</p></blockquote><p>如果想要公平的话，有一种算法是这样的，每次随机抽取一张牌把它放到最后的位置去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cards = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">cards</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> c =[...cards];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = c.length; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">const</span> pIdx = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * i);</span><br><span class="line">        [c[pIdx],c[i-<span class="number">1</span>]] = [c[i-<span class="number">1</span>], c[pIdx]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="built_in">Array</span>(<span class="number">10</span>).fill(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">const</span> c = shuffle(cards);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j &lt; <span class="number">10</span>; j++)&#123;</span><br><span class="line">        result[j] += c[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><blockquote><p>[<br> 45466, 44956, 44753,<br> 45253, 45179, 44765,<br> 45147, 44469, 45404,<br> 44608<br>]</p></blockquote><p>可以看出这个打印出来的结果，大小都是差不大多的。</p><h4 id="分红包"><a href="#分红包" class="headerlink" title="分红包"></a><strong>分红包</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generate</span>(<span class="params">amount, count</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ret = [amount];</span><br><span class="line">    <span class="keyword">while</span>(count &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 挑选出最大的一块进行切分</span></span><br><span class="line">        <span class="keyword">let</span> cake = <span class="built_in">Math</span>.max(...ret),</span><br><span class="line">            idx = ret.indexOf(cake),</span><br><span class="line">            part = <span class="number">1</span> + <span class="built_in">Math</span>.floor((cake/<span class="number">2</span>) * <span class="built_in">Math</span>.random()),</span><br><span class="line">            rest = cake - part;</span><br><span class="line">        ret.splice(idx,<span class="number">1</span>,part,rest);</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不停的切分最大的金额。</p><blockquote><p>这个会带来一个问题，就是金额很平均。</p><p>不会有人拿了很大的红包，少了一丝趣味性。</p><p>不够刺激~</p></blockquote><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>听君一席话，如听一席话。他好似讲了许多，又好像什么也没讲。</p><p>是我菜了，继续加油！</p>]]></content>
      
      
      <categories>
          
          <category> 经历 </category>
          
          <category> JavaScript进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 字节青训营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何写好JavaScript（上）</title>
      <link href="/posts/98016397.html/"/>
      <url>/posts/98016397.html/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>课程记录笔记第三弹——《跟月影学JavaScript》</p><blockquote><p>今天真被月影大佬讲的js干的有点自闭了，1小时50分钟的视频，我楞是花了将近3个多小时去理解，还一脸懵。</p></blockquote><p>本次课题：<strong>如何写好JavaScript（上）</strong></p><blockquote><p>估计，如何写好JavaScript（下）我要后半夜更了，歇一会歇一会</p></blockquote><span id="more"></span><h3 id="如何写好JavaScript（上）"><a href="#如何写好JavaScript（上）" class="headerlink" title="如何写好JavaScript（上）"></a>如何写好JavaScript（上）</h3><p><strong>写好JavaScript的一些原则</strong></p><ul><li>各司其责</li><li>组件封装</li><li>过程抽象</li></ul><h4 id="写一个🌰"><a href="#写一个🌰" class="headerlink" title="写一个🌰"></a>写一个🌰</h4><p>写一段js，控制一个网页，让他支持浅色和深色两种浏览模式。</p><p>如果是你来实现，你会怎么做？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;modeBtn&#x27;</span>);</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> body = <span class="built_in">document</span>.body;</span><br><span class="line">    <span class="keyword">if</span>(e.target.innerHTML === <span class="string">&#x27;☀&#x27;</span>)&#123;</span><br><span class="line">        body.style.backgroundColor = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">        body.style.color = <span class="string">&#x27;white&#x27;</span>;</span><br><span class="line">        e.target.innerHTML = <span class="string">&#x27;🌙&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        body.style.backgroundColor = <span class="string">&#x27;white&#x27;</span>;</span><br><span class="line">        body.style.color = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">        e.target.innerHTML = <span class="string">&#x27;☀&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这是通过页面的一个<code>button</code>来改变的，这个代码也是最最最简单的一个例子。</p><blockquote><p>当然，这个代码是可以优化的，因为现在不便于进行维护</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;modeBtn&#x27;</span>);</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> body = <span class="built_in">document</span>.body;</span><br><span class="line">    <span class="keyword">if</span>(body.className !== <span class="string">&#x27;night&#x27;</span>)&#123;</span><br><span class="line">        body.className = <span class="string">&#x27;night&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        body.className = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>版本二，它来了。</p><p>它将版本一js操作的一些html样式放到两个类中，最后通过js来改变他的类名做到绑定与解除样式。</p><p>甚至，只用css也可以实现交互，版本三，他也来了。</p><blockquote><p>这是我从未有过的思路，在今天第一次见到</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#modeCheckBox</span>:&#123;</span><br><span class="line">    display:none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#modeCheckBox</span><span class="selector-pseudo">:checked</span>+ <span class="selector-class">.content</span>&#123;</span><br><span class="line"><span class="attribute">background-color</span>: black;</span><br><span class="line"><span class="attribute">color</span>: white;</span><br><span class="line"><span class="attribute">transition</span>: all <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用一个<code>checkbox</code>，的checked事件，首先将他隐藏起来，再用一个<code>lable</code>绑定上他，之后点击<code>lable</code>就会触发checked事件，利用选择器完成这个简单的交互</p><blockquote><p>这个确实是我没想到的，拿出小本本，圈起来</p></blockquote><p><strong>小笔记（总结）</strong></p><ul><li>html/css/js各司其责</li><li>应当避免不必要的由js直接操作样式</li><li>可以用class来表示状态</li><li>纯展示类交互寻求零js解决方案</li></ul><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>组件是指Web页面上抽出来的一个个包含模板（HTML）、功能（js）和样式（css）的单元。好的组件具备封装性，正确性，扩展性，复用性。</p><p><strong>用原生js写一个轮播图</strong></p><ul><li><p>结构—HTML：</p><ul><li>轮播图是一个典型的列表结构，我们可以使用无序列表<code>&lt;ul&gt;</code>元素来实现。</li></ul></li><li><p>表现—CSS：</p><ul><li>使用css绝对定位将图片重叠在同一个位置</li><li>轮播图切换的状态使用修饰符（modifier）</li><li>轮播图的切换动画使用css transition</li></ul></li><li><p>行为—JS</p><ul><li>API的设计应保证原子操作，职责单一，满足灵活性</li></ul></li><li><p>行为—控制流</p><ul><li>使用自定义事件来解耦</li></ul></li></ul><p><strong>总结：基本方法</strong></p><ul><li>结构设计</li><li>展现效果</li><li>行为设计<ul><li>API（功能）</li><li>Event（控制流）</li></ul></li></ul><h4 id="重构：插件化"><a href="#重构：插件化" class="headerlink" title="重构：插件化"></a><strong>重构：插件化</strong></h4><p>解耦：</p><ul><li>将控制元素抽取成插件</li><li>插件与组件之间通过<strong>依赖注入</strong>方式建立联系</li></ul><h4 id="重构：模板化"><a href="#重构：模板化" class="headerlink" title="重构：模板化"></a><strong>重构：模板化</strong></h4><p>解耦：</p><ul><li>将html模板化，更易于扩展</li></ul><blockquote><p>在插件中，抽象出来一个方法去渲染html</p></blockquote><h4 id="重构：组件框架"><a href="#重构：组件框架" class="headerlink" title="重构：组件框架"></a><strong>重构：组件框架</strong></h4><p>抽象：</p><ul><li>将通用的组件模型抽象出来</li></ul><h4 id="总结：组件封装"><a href="#总结：组件封装" class="headerlink" title="总结：组件封装"></a><strong>总结：组件封装</strong></h4><ul><li>组件设计的原则：封装性、正确性、扩展性、复用性</li><li>实现组件的步骤：结构设计、展现效果、行为设计</li><li>三次重构：<ul><li>插件化</li><li>模板化</li><li>抽象化（组件框架）</li></ul></li></ul><h3 id="过程抽象"><a href="#过程抽象" class="headerlink" title="过程抽象"></a><strong>过程抽象</strong></h3><ul><li>用来处理局部细节控制的一些方法</li><li>函数式编程思想的基础应用</li></ul><blockquote><p>function(x){</p><p>​    处理x;</p><p>​    return x;</p><p>}</p></blockquote><h4 id="写一个🌰："><a href="#写一个🌰：" class="headerlink" title="写一个🌰："></a>写一个🌰：</h4><p>一个列表（todolist），完成后点击会消失掉</p><p>操作次数限制：</p><ul><li>一些异步交互</li><li>一次性的HTTP请求</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> buttons = list.querySelectorAll(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">buttons.forEach(<span class="function">(<span class="params">button</span>)=&gt;</span>&#123;</span><br><span class="line">    button.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function">(<span class="params">evt</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> target = evt.target;</span><br><span class="line">        target.parentNode.className = <span class="string">&#x27;completed&#x27;</span>;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            list.removeChild(target.parentNode);</span><br><span class="line">        &#125;,<span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个代码是可以实现的，但是却有bug，你连续点击按钮的话，他会调用多次<code>addEventListener</code>，最后会报错，因为此时节点已经被remove了。</p><h4 id="Once"><a href="#Once" class="headerlink" title="Once"></a><strong>Once</strong></h4><ul><li>为了能够让“只执行一次”的需求覆盖不同的事件处理，我们可以将这个需求剥离出来。这个过程我们称为<strong>过程抽象</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">once</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fn)&#123;</span><br><span class="line">            <span class="keyword">const</span> ret = fn.apply(<span class="built_in">this</span>,args);</span><br><span class="line">            fn = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">button.addEventListener(<span class="string">&#x27;click&#x27;</span>,once(<span class="function">(<span class="params">evt</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> target = evt.target;</span><br><span class="line">    target.parentNode.className = <span class="string">&#x27;completed&#x27;</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        list.removeChild(target.parentNode);</span><br><span class="line">    &#125;,<span class="number">2000</span>);</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>我们加一个once函数，以fn函数作为参数，第一次进来会调用this指针执行这个函数，执行过后会将fn=null，这样再次点击的时候就不会再次调用了。</p><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a><strong>高阶函数</strong></h4><ul><li>以函数作为参数</li><li>以函数作为返回值</li><li>常用于作为函数装饰器</li></ul><h4 id="常用高阶函数"><a href="#常用高阶函数" class="headerlink" title="常用高阶函数"></a><strong>常用高阶函数</strong></h4><ul><li>Once</li><li>Throttle  节流函数</li><li>Debounce  防抖函数</li><li>Consumer / 2  异步消耗</li><li>Iterative  迭代函数</li></ul><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a><strong>思考</strong></h4><p>为什么要用高阶函数？</p><h3 id="编程范式"><a href="#编程范式" class="headerlink" title="编程范式"></a><strong>编程范式</strong></h3><p>命令式与声明式</p><ul><li><p>命令式</p><p>强调how，怎么做</p></li><li><p>声明式</p><p>强调what，做什么</p></li></ul><h4 id="编程范式—总结"><a href="#编程范式—总结" class="headerlink" title="编程范式—总结"></a><strong>编程范式—总结</strong></h4><ul><li>过程抽象/HOF/装饰器</li><li>命令式/声明式</li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>这次笔记记录的很匆忙，再加上理解的也不是很懂，所以导致后面的高阶函数部分基本没有自己的梳理，后面梳理过后会过来补上更新的。</p>]]></content>
      
      
      <categories>
          
          <category> 经历 </category>
          
          <category> JavaScript进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 字节青训营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端也要学习基本的UI设计原则与实践套路</title>
      <link href="/posts/2086971120.html/"/>
      <url>/posts/2086971120.html/</url>
      
        <content type="html"><![CDATA[<h2 id="前端也要学习基本的UI设计原则与实践套路"><a href="#前端也要学习基本的UI设计原则与实践套路" class="headerlink" title="前端也要学习基本的UI设计原则与实践套路"></a>前端也要学习基本的UI设计原则与实践套路</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>有的人可能说，我是技术研发人员，UI的事情我们团队内会有别的人去操心这个，我只管技术即可。</p><p>在一天之前，我也是这么觉得的，但是我今天听了字节的《给开发看的UI设计》这节课后，觉得一个前端工程师也是要具备一定的UI设计能力的。</p><p>依赖市面上的组件库已经不能让产品维持在好用的状态了，还需要将一些设计元素添加进去，才能让我们开发的作品，达到一个更好的层次，给与用户最好的体验。</p><p>你的团队可能没有UI同学，也可能有UI同学，但是不一定专业，他们经常会是外包人员，UI给出的设计稿通常只是静态文件，是某一交互切面的，很多的交互细节都体现不出来，在大厂中，许多的B端产品是没有专职UI角色的，前端可能要对产品最终呈现出的形态负责。</p><span id="more"></span><h3 id="设计中最重要的事情——交付功能"><a href="#设计中最重要的事情——交付功能" class="headerlink" title="设计中最重要的事情——交付功能"></a><strong>设计中最重要的事情——交付功能</strong></h3><p>工具：<a href="https://excalidraw.com/">最好用的白板——excaildraw</a></p><p>我们只需要简单粗略的设计大框就可以，设计细节可以后面在补充，在设计UI的时候永远不要忘了，我们归根结底还是要以实现需求，功能优先。</p><blockquote><p>可以使用别的设计工具去画原型图（figma），但是我觉得作为开发人员，简简单单的就可以，一切以方便为主</p></blockquote><p>要设计简单的、完整的功能</p><p>以MVP版本功能来作为设计目标</p><ul><li>MVP：Minimum Viable Product，最简化可实行产品</li></ul><p>所谓先让游戏开始，我们开发在做设计的时候，优先把主要场景设计完成，有迅速迭代能力就可以了，正所谓不需要太多花里胡哨，保持结构简单，功能完整就好。</p><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p><strong>设计原则——层级</strong></p><p>层级——是我们可能唯一要关心的原则</p><p>层级区分，更是我们最需要掌握的原则和技巧。</p><ul><li>一个产品要好用，就要让用户很容易的抓住展品重点</li><li>在重点里，用户能自在地进入沉浸式阅读，和使用的转台</li><li>当用户想探索其他内容时，ta能轻松的识别网站的次要板块还有哪些，焦点能迅速转义，并迅速沉浸</li><li>辅助提示信息，精确而又不会打扰各主要板块的呈现</li></ul><p><strong>设计原则——一致性</strong></p><p>用户在站点的各个角落，观察到的颜色、间距、阴影、位置、字体和字重的运用，都在一套有限的框架里，一套能迅速建立起亲切感的框架内。</p><blockquote><p>当页面中，主要的交互、视觉元素都采用同一主题色来表示时，用户可以迅速知道：</p><ul><li>页面中哪些元素的可以交互的</li><li>我需要的提示信息在哪</li></ul></blockquote><p><strong>设计原则——《写给大家看的设计书》</strong></p><p>简单介绍一下《写给大家看的设计书》四原则：</p><ul><li>对比：如果两个元素内涵不同，请让它们截然不同</li><li>重复：设计的视觉要素应当在整个作品中重复出现</li><li>亲密性：彼此关联的元素应当靠近放置在一起</li><li>对齐：任何元素都不能随意安放，应当总与另外至少一个 元素有视觉上的关联</li></ul><p>这四个原则其实就对应着上面的一致性和层级。</p><ul><li>层级：就是亲密性+对比的目标，让用户抓重点、切视线，又快又稳。</li><li>一致性：就是对齐+重复，克制用户实现所感受的尺度，迅速与网站设计语言建立熟悉感。</li></ul><h3 id="设计体系"><a href="#设计体系" class="headerlink" title="设计体系"></a>设计体系</h3><p><strong>设计体系——布局</strong></p><p>最基本的布局技巧，内容居中放。</p><p>多列布局：</p><ul><li>主要内容弹性收缩（可以有最小宽度），次要列固定宽度</li></ul><p><strong>设计体系——间距</strong></p><p>保证元素间有基本的间距，是最基本的设计技巧。</p><p>间距——多留白</p><p>这是一个技巧：安排元素时先大大的留空，要从松到紧的调试间距。</p><blockquote><p>间距是远比色块、边框、分界线之类的更适合用来表达关联关系的工具。值得多加练习运用。</p></blockquote><p><strong>设计体系——文字</strong></p><p>文本是站点的主要内容载体，字体的设计自然也是重中之重。</p><p><strong>设计体系——色彩</strong></p><p>谁人不喜色彩？</p><p>你选择的色彩库要有10种左右的灰色度供你使用（黑–&gt;白），要有主题色，功能色等。</p><p>要学会使用色盘，来微调，使得你的颜色对用户使用的影响更好</p><p><strong>注意事项：</strong></p><ul><li>颜色虽好，使用不当会打破页面层级平衡</li><li>色盲消费不了颜色</li><li>颜色在不同文化中可能有不同的含义</li></ul><p><strong>设计体系——深度</strong></p><p>深度的感官来源于生活，类似于光照的效果，来打造一种层级。</p><blockquote><p>就是我们常用的阴影感</p></blockquote><h3 id="实用技巧"><a href="#实用技巧" class="headerlink" title="实用技巧"></a>实用技巧</h3><p><strong>实用技巧——图片上的层级</strong></p><p>图片上的色块斑驳不一，难以找到合适的前景色。咋办？</p><ul><li>增加蒙层，对比度不就上来了。</li><li>可以给文字加上阴影，增加文字部分的对比度，不影响整张图片。</li></ul><p><strong>实用技巧——明晰的用户头像</strong></p><p>上传头像的场景，如何清晰的展示内容？</p><ul><li>加点内阴影</li></ul><p><strong>实用技巧——干掉分界线</strong></p><p>阴影可以替代边框，不通的背景色块也可以。</p><p>间距清晰的话，也就不需要分界线了。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>听完了这节课真的觉得挺有用的，虽然说讲的是设计理念，没有一丝css代码在其中，可是我觉得我的css能力上升了一个层面~</p><p>最后留下这份笔记，留给以后的自己进行梳理，也顺便分享出来给更多的前端小伙伴们，让更多之前与我一样的人了解到，前端也要懂UI。</p>]]></content>
      
      
      <categories>
          
          <category> 经历 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经历 </tag>
            
            <tag> 字节青训营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js异步编程之Promise</title>
      <link href="/posts/697311807.html/"/>
      <url>/posts/697311807.html/</url>
      
        <content type="html"><![CDATA[<h2 id="Node-js异步编程之Promise"><a href="#Node-js异步编程之Promise" class="headerlink" title="Node.js异步编程之Promise"></a>Node.js异步编程之Promise</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>先来介绍一下Promise是什么？</p><p>Promise：</p><ul><li>当前事件循环得不到的结果，但未来的事件循环会给到你结果</li><li>是一个状态机<ul><li>pending——还没有得到结果</li><li>fulfilled/resolved——得到了一个正确的结果</li><li>rejected——得到了一个错误的结果</li></ul><span id="more"></span></li></ul><p><img src="/posts/697311807.html/%E7%8A%B6%E6%80%81.png"></p><h3 id="从代码入手👻"><a href="#从代码入手👻" class="headerlink" title="从代码入手👻"></a>从代码入手👻</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            resolve();<span class="comment">// reject(new Error());</span></span><br><span class="line">        &#125;,<span class="number">500</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(promise);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(promise);</span><br><span class="line">    &#125;,<span class="number">800</span>)</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>这是一个从pending到resolved/rejected的过程。</p><p>那么可能有的小伙伴会想，我可不可以让他在300毫秒的时候转变成resolve的状态，在500毫秒的时候从resolved转变成rejected状态呢？那我们来实际操作一下看看结果吧。</p><blockquote><p>我也有这样的疑惑</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;,<span class="number">300</span>)</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>());</span><br><span class="line">        &#125;,<span class="number">300</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(promise);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(promise);</span><br><span class="line">    &#125;,<span class="number">800</span>)</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p><img src="/posts/697311807.html/%E6%B5%8F%E8%A7%88%E5%99%A8.png"></p><p>从结果我们可以看到，他还是fulfilled状态，也就是resolved状态，没有改变。</p><p><strong>所以在resolved状态与rejected状态之间应该是不能转换的。</strong></p><h3 id="继续学习🐸"><a href="#继续学习🐸" class="headerlink" title="继续学习🐸"></a>继续学习🐸</h3><p>我们使用promise去解决异步问题，是希望他拿到结果之后就要立即通知我们，那这个时候我们要怎么去写呢？</p><p>我们可以借助promise下的一个方法，叫做<strong>then</strong></p><p>把上面的代码进行改写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            resolve(<span class="number">3</span>);</span><br><span class="line">        &#125;,<span class="number">300</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(promise);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(promise);</span><br><span class="line">    &#125;,<span class="number">800</span>)</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>可能有小伙伴注意到了，我们上面还多了一个catch方法，没错，他在这里也是用来处理error的，而error在promise里就对应着rejected状态了，将上面的代码再改点东西，就成了这样子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>());</span><br><span class="line">        &#125;,<span class="number">300</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(promise);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(promise);</span><br><span class="line">    &#125;,<span class="number">800</span>)</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ul><li>关于.then和.catch<ul><li>resolved状态的promise会回调后面的第一个.then</li><li>rejected状态的promise会回调后面的第一个.catch</li><li>任何一个rejected状态且后面没有.catch的promise，都会造成浏览器/node环境的全局错误</li></ul></li></ul><h3 id="为什么说promise优秀呢？"><a href="#为什么说promise优秀呢？" class="headerlink" title="为什么说promise优秀呢？"></a>为什么说promise优秀呢？</h3><p>他可以解决异步流程控制的问题（这个在前面callback那节笔记有记过，[可以去看一下](<a href="https://blog.wangez.site/posts/3168823204.html/">Node.js学习笔记之异步编程部分（一） | Wangez-Blog</a>)）。</p><p>还是之前面试的问题，这次我们用promise的思路来看一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> promise = interview();</span><br><span class="line">    promise</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;smile&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;cry&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">interview</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Math</span>.random()&gt;<span class="number">0.2</span>)&#123;</span><br><span class="line">                resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;fail&#x27;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">500</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小细节，拿笔记好📢"><a href="#小细节，拿笔记好📢" class="headerlink" title="小细节，拿笔记好📢"></a>小细节，拿笔记好📢</h3><p>执行then和catch会返回一个新的promise，该promise最终状态根据then和catch的回调函数的执行结果决定</p><ul><li>如果回调函数是throw，那么promise就是rejected状态</li><li>如果回调函数是return，那么promise就是resolved状态</li><li>但如果回调函数最终return了一个promise，该promise回跟回调函数return的那个promise状态保持一致。</li></ul><p>接下来用多轮面试的例子，来演示一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> promise = interview();</span><br><span class="line">    promise</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> interview(<span class="number">2</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> interview(<span class="number">3</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;smile&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;cry at  &#x27;</span> + err.round + <span class="string">&#x27;  round&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">interview</span>(<span class="params">round</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Math</span>.random()&gt;<span class="number">0.2</span>)&#123;</span><br><span class="line">                resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;fail&#x27;</span>);</span><br><span class="line">                error.round = round</span><br><span class="line">                reject(error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">500</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想知道你在第几轮面试挂了吗？去执行一下试试吧！</p><h3 id="小优化🎁"><a href="#小优化🎁" class="headerlink" title="小优化🎁"></a>小优化🎁</h3><p>我们肯定是同时面试多家公司的呀，那我们再给上面的代码做一些优化吧。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">Promise</span></span><br><span class="line">    .all([</span><br><span class="line">        interview(<span class="string">&#x27;tencent&#x27;</span>),</span><br><span class="line">        interview(<span class="string">&#x27;Ali88&#x27;</span>)</span><br><span class="line">    ])</span><br><span class="line">    .then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;smile&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;cry for  &#x27;</span> + err.name );</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">interview</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Math</span>.random()&gt;<span class="number">0.2</span>)&#123;</span><br><span class="line">                resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;fail&#x27;</span>);</span><br><span class="line">                error.name = name</span><br><span class="line">                reject(error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">500</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>catch只能返回第一个面试挂的公司，如果都想知道就要存好所有的promise的状态并且打印出来哦。</li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>肝不动了，睡了睡了，总觉得上面那个例子，面试通过一家，第二家挂了他会给我返回到catch里面去呢，明天在研究一下。</p>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我与前端那割舍不开的情缘</title>
      <link href="/posts/4140439376.html/"/>
      <url>/posts/4140439376.html/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>很早就想做一个情感博主了，来说一说自己的生活，或者是自己的经历，终于，在今天的摸鱼中实现了这个梦想。</p><span id="more"></span><blockquote><p>电脑：你就是今天没去云顶之奕</p><p>我：才不是</p><img src="https://img1.baidu.com/it/u=1974436569,2502622706&fm=26&fmt=auto&gp=0.jpg" alt="zo" style="zoom:50%;"></blockquote><h3 id="入坑前端之前"><a href="#入坑前端之前" class="headerlink" title="入坑前端之前"></a>入坑前端之前</h3><p>在刚上大学的九月份，到了该报社团的日子了，各大社团，团委，学生会，神秘组织等都开始在学校贴上海报，搭起棚子，开始准备骗人，呸不对，是招新！</p><p>这时候我就想，我应该加入哪个社团呢？我可是要成为光的男人啊，那注定不凡的我当然要选择一个看起来不凡的组织！</p><p><img src="https://img1.baidu.com/it/u=2323672915,1551008553&fm=26&fmt=auto&gp=0.jpg"></p><p>最后，选择了这个当时人数为十几个人的学生开发团队–琴理工作室</p><img src="https://wangez.site/myResume/web/qinli.jfif" alt="zoom" style="zoom:40%;"><blockquote><p>琴理工作室：我们是一群平凡的人，在做着不平凡的事！</p></blockquote><p>为什么选择他呢？</p><p>因为我很喜欢学跟计算机有关的知识，大学报的也是信息院的专业（物联网工程），所以我觉得会开发的应该很帅~</p><p>那为什么选择前端呢？</p><p>我当时的心里状态：前端后端好像都是开发的，前端那个学长看起来好亲切啊~，就它了！什么？前端组长还是学姐？我先冲了xdm！</p><p><img src="https://img0.baidu.com/it/u=985530633,1842698313&fm=26&fmt=auto&gp=0.jpg"></p><h3 id="我的第一次前端考核"><a href="#我的第一次前端考核" class="headerlink" title="我的第一次前端考核"></a>我的第一次前端考核</h3><blockquote><p>培训都是由每届大二学长进行</p></blockquote><p>当时是进行了为期四周的培训，每周一天，完后月底进行了一次考核。</p><p>考核内容：做一个登录，把能登录的数据放在json数组里，做好表单校验，完后登录成功跳转到另一个页面。</p><p>先说说四天教了我们啥东西吧，第一次教了一些浮动和html标签的知识，第二次教了一些css布局的东西，第三次教了git的简单使用，第四次教了js的东西。</p><p>我以现在的前端眼光来看当时的培训，哇，我好了不起~那么多知识我竟然都会了耶。</p><p>当时的我：慌的一批，啥也不会，就会百度，百度的代码，CV上去还老出错。</p><p><img src="https://img1.baidu.com/it/u=411035725,2076790212&fm=26&fmt=auto&gp=0.jpg"></p><p>但是，依赖我的聪明才智，我还是做出来了个仿QQ登录页面的那种简易的东西，顺利通过了考核。（当时熬了好久夜，做了一个星期，代码不超过五十行）</p><h3 id="年终大考核"><a href="#年终大考核" class="headerlink" title="年终大考核"></a>年终大考核</h3><p>没想到吧，我们这个神秘组织不光有考核，还有个年底大考核。</p><p>当时分配的任务是在线简历项目，一个Web项目，技术栈使用的是Jquery+原生js+ajax配合项目组成员一起做。</p><blockquote><p>我们的项目组：</p><ul><li>前端</li><li>后端</li><li>产品</li><li>视觉</li><li>运维</li><li>运营</li></ul></blockquote><p>很全对吧，但是你很难想象，我上面的学长学姐们一共也不过20个人（在职）。</p><img src="https://wangez.site/myResume/web/zhuyemian.png" style="zoom:40%;"><blockquote><p> 当时的UI图</p></blockquote><p>按照当时我们的技术水平，那肯定是做不出来啊，开学前夕，一个个七零八落的项目，东拼西凑的，开始了展示。。。</p><p>还好，好运的我最终还是留下了~</p><h3 id="开始自学前端"><a href="#开始自学前端" class="headerlink" title="开始自学前端"></a>开始自学前端</h3><p>考核之后，再次开学，我就开始了我的自学之路，从html、css、js到jQuery、vue、element、echrats，从大一，到大二。从web开发走到移动端，又了解了小程序开发。从前端到后端再到服务器知识。</p><p>期间看过的资料：</p><blockquote><ul><li><p>黑马pink老师</p><p>我的前端入门老师，很多知识都是在B站看他的视频学会的</p></li><li><p>红宝书</p><p>前期当字典用还是不错的</p></li></ul></blockquote><p>这些在前端基础学习的时候，已经够了。</p><h3 id="大二，登上讲台"><a href="#大二，登上讲台" class="headerlink" title="大二，登上讲台"></a>大二，登上讲台</h3><p>大二意味着，当9月份一过，就要招新了，同样是摆台，这一次却变成了自己在忙活，琴理工作室从十几个人成长到了四十多人，招新过后，我们这帮初入大学的人（大一下因疫情原因，在家上网课，所以在大学一共只有半年经验，还是大一上），就贸然登上了讲台，开始给新生们进行前端知识讲解。</p><p>说实话，当时有些问题，我们也不是特别懂，都是一边开着QQ窗口，一边浏览着谷歌百度，自己弄明白了之后，又去给学弟学妹们讲。</p><p>不过现在回想起来，那阵子真挺好的，看见他们成长，自己内心会有种自豪感。</p><img src="https://img1.baidu.com/it/u=2748849229,3156588071&fm=253&fmt=auto&app=120&f=JPEG?w=500&h=474" alt="zoo" style="zoom:50%;"><h3 id="第一次自己带领项目组产出"><a href="#第一次自己带领项目组产出" class="headerlink" title="第一次自己带领项目组产出"></a>第一次自己带领项目组产出</h3><p>在大二，被当时的老大（工作室室长），让我去带一个项目组给学校官方那边开发个项目，<code>ERPQS</code>（内容不方便说），让我当了项目组长，于是在接到需求之后，开始给各个组分配任务，规划项目进度日期。</p><p><img src="https://img0.baidu.com/it/u=1176565885,2715850811&fm=26&fmt=auto&gp=0.jpg"></p><p>我自己的gitee上在当时真的是绿了一片</p><p><img src="https://wangez.site/myResume/web/git.png" alt="git"></p><p>完后五月多把项目带去给老师看，最后交工。</p><h3 id="前端？我吃饭的碗？"><a href="#前端？我吃饭的碗？" class="headerlink" title="前端？我吃饭的碗？"></a>前端？我吃饭的碗？</h3><p>在大二下，我的学长们陆续开始做出人生第二个高考抉择，考研还是就业。</p><p>在参考了学长们的建议，参考了老师的意见之后，最终，我选择了直接就业，就业方向是<code>前端</code></p><p>那有人就问了，为什么不考研？</p><p>我是这么理解考研这回事情的，考研就要考一个好大学（最次也要个985，211或者计算机有点实力的学校吧），因为本科毕竟是双非了已经，研究生不得往上爬一爬？但是考好学校就意味着竞争，并且外校不具备主场优势，一旦没考上的后果就是你比与你同届就业的人少了一年多学习时间与实习经验，这将直接决定了你毕业即失业，二战考研的话，自己的心里压力会更大。咱家里也不是有矿的家庭，所以直接就业对于我来说，应该算是最优解。</p><p>前端的就业行情在目前来看，还是很不错的，毕业平均薪资也在10k以上，好一点公司的话，毕业年包25w也已经是常见的事情了。但是具有互联网行业都有的一点，那就是卷。</p><p>在2021，内卷已经成为了一种常态，你在大二开始准备就业，可能有的人在大四才开始准备，你这就比人多准备了两年，但你肯定想不到，有的人高考完事就已经开始准备大四就业了吧？内卷就意味着你要比常人付出更多的努力，才能有可能去竞争那份看起来很体面的工作，去过上你心中那种理想的生活。</p><h3 id="那么，努力吧！"><a href="#那么，努力吧！" class="headerlink" title="那么，努力吧！"></a>那么，努力吧！</h3><p>希望未来的我，会感激在大一大二就拼命学习的自己。</p><p>也希望看到这篇博客的小伙伴，都能做出最正确的人生选择，过上自己想要的理想生活。</p><p>明天七夕拉，提前祝大家七夕快乐！</p><img src="https://img0.baidu.com/it/u=3335154325,3530608547&fm=253&fmt=auto&app=120&f=JPEG?w=500&h=500" alt="zoom" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> 经历 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js之事件循环</title>
      <link href="/posts/3309484712.html/"/>
      <url>/posts/3309484712.html/</url>
      
        <content type="html"><![CDATA[<h1 id="Node-js之事件循环"><a href="#Node-js之事件循环" class="headerlink" title="Node.js之事件循环"></a>Node.js之事件循环</h1><h3 id="简单叙述一下什么是事件循环"><a href="#简单叙述一下什么是事件循环" class="headerlink" title="简单叙述一下什么是事件循环"></a>简单叙述一下什么是事件循环</h3><p>还是拿之前的餐厅来举例，我们去点了个番茄炒蛋，服务生告诉后厨做一个番茄炒蛋，张三也去了餐厅，点了个麻辣小龙虾，服务生又告诉后厨做一份麻辣小龙虾，小李也去了，点了个蛋炒饭。</p><span id="more"></span><p>解析一下这个情景，餐厅是一个事件循环，其中我们的点餐叫做线程。服务生第一个把我要的番茄炒蛋端过来了，于是我的线程结束了，因为麻辣小龙虾做的慢，蛋炒饭做完了，服务生又给小李端上来了蛋炒饭，小李虽然是后来的，但是他的过程要比张三快，最后小龙虾好了，服务生给张三端上来小龙虾，至此三个线程都结束了。</p><h3 id="用代码实现一个简易版的事件循环"><a href="#用代码实现一个简易版的事件循环" class="headerlink" title="用代码实现一个简易版的事件循环"></a>用代码实现一个简易版的事件循环</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eventloop = &#123;</span><br><span class="line">    <span class="comment">// 事件队列</span></span><br><span class="line">    <span class="attr">queue</span>: [],</span><br><span class="line">    <span class="function"><span class="title">loop</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">this</span>.queue.length)&#123;</span><br><span class="line">            <span class="comment">// 如果有事件就进行处理</span></span><br><span class="line">            <span class="keyword">var</span> callback = <span class="built_in">this</span>.queue.shift();</span><br><span class="line">            callback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每50毫秒会检测一下事件</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="built_in">this</span>.loop.bind(<span class="built_in">this</span>),<span class="number">50</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 添加事件</span></span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.queue.push(callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eventloop.loop();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别在 500毫秒跟800毫秒，往队列中加入两个事件</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    eventloop.add(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;第一个&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,<span class="number">500</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    eventloop.add(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;第二个&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,<span class="number">800</span>)</span><br></pre></td></tr></table></figure><h3 id="有话说"><a href="#有话说" class="headerlink" title="有话说"></a>有话说</h3><p>当然，在真实情况中会比这复杂的多，不会每50毫秒去检测一次，要快的多，添加的事件也不会只有回调函数，例如一些文件读写操作等。我们的事件队列可能还会有文件处理队列，定时操作队列等多种不同的队列。</p><p>就先到这，下次见~</p>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js学习笔记之异步编程部分（一）</title>
      <link href="/posts/3168823204.html/"/>
      <url>/posts/3168823204.html/</url>
      
        <content type="html"><![CDATA[<h1 id="Node-js学习笔记之异步编程部分（一）"><a href="#Node-js学习笔记之异步编程部分（一）" class="headerlink" title="Node.js学习笔记之异步编程部分（一）"></a>Node.js学习笔记之异步编程部分（一）</h1><ul><li><p>回调函数格式规范</p><ul><li>error-first callback</li><li>Node-style callback</li></ul></li><li><p>第一个参数是error，后面的参数才是结果</p></li></ul><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>你在面试之后，面试官让你回去等消息。</p><span id="more"></span><p>结果：</p><ul><li>过</li><li>不过</li></ul><p>ps：面试过了我们就笑一下，面试不过我们就哭！</p><p>先上代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">interview(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(err)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&#x27;cry at 1st&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">interview(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(err)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&#x27;cry at 2nd&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">interview(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(err)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&#x27;cry at 3rd&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;smile&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">interview</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Math</span>.random() &lt; <span class="number">0.8</span>)&#123;</span><br><span class="line">callback(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">callback( <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;fail&#x27;</span>)); </span><br><span class="line">&#125;</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个正常的面试流程：</p><ul><li>一面——&gt;挂掉</li><li>一面——-&gt;二面——&gt;挂掉</li><li>一面——-&gt;二面——&gt;三面——&gt;挂掉</li><li>一面——-&gt;二面——&gt;三面——&gt;入职</li></ul><p>看是看着这种嵌套是真的恶心，这种问题就叫做<code>回调地狱</code>，这也是比较容易出现在异步中的问题，另外一个问题就是并发了，我们用同时面试两家公司为例，毕竟这也是正常能够出现的现象。</p><p>这时候张三说了：我会写我会写，还是上面代码的理念，我加一个计数器，面试过了就count++，count为2的时候，就证明两个面试都过了，这样可以用if判断并写一些逻辑。</p><p>简单描述一下张三的代码结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">interview(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&#x27;cry&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    count++</span><br><span class="line">&#125;)</span><br><span class="line">interview(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&#x27;cry&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    count++</span><br><span class="line">    <span class="keyword">if</span>(count)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>大致是这个样子，看起来很麻烦。这个问题就涉及到异步流程控制问题，也就是异步的并发，针对这个问题，我们强大的社区当然是有解决方案的。</p><ul><li><p>npm包：<code>async.js</code></p></li><li><p>thunk编程方式</p></li></ul><blockquote><p>现在好像这两个方式都不用了😭</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js的非阻塞I/O</title>
      <link href="/posts/212671180.html/"/>
      <url>/posts/212671180.html/</url>
      
        <content type="html"><![CDATA[<h1 id="Node-js的非阻塞I-O"><a href="#Node-js的非阻塞I-O" class="headerlink" title="Node.js的非阻塞I/O"></a>Node.js的非阻塞I/O</h1><blockquote><p>写在最前</p><p>老早就想学Node.js了，觉得前端一定要是懂服务端知识，并且可以自己独立完成一个小型全栈项目的，但是碍于时间因素，上学期学了点基础之后，就再也没空学，正好今天科二过了，Node.js我又来卷你了！！！</p></blockquote><ul><li>I/O就是input/output，一个系统的输入输出</li><li>阻塞I/O和非阻塞I/O的区别就在于<strong>系统的接收输入，在到输出期间，能不能接收其他输入</strong></li></ul><span id="more"></span><h2 id="举个栗子🌰"><a href="#举个栗子🌰" class="headerlink" title="举个栗子🌰"></a>举个栗子🌰</h2><ul><li><p>去食堂吃饭：我们都要排队打饭</p><p>我们的流程是：<font color="blue">排队——&gt;等前面的人打饭——–&gt;轮到我们自己打饭——-&gt;开始吃饭</font></p></li><li><p>出去吃饭：餐厅点菜</p><p>现在我们的流程是：<font color="red">坐下——-&gt;点菜——-&gt;等待——–&gt;开始吃饭</font></p><blockquote><p>尝试开始在markdown中使用一些奇奇怪怪的东西</p></blockquote></li><li><p><font color="red" size="5">排队打饭 vs 餐厅点菜</font></p></li><li><p><font>对于点菜人员的我们来说：</font></p><ul><li>排队打饭是阻塞I/O</li><li>餐厅点菜是非阻塞I/O</li></ul></li></ul><p>继续来看最上面那句话：</p><blockquote><p>系统的接收输入，在到输出期间，能不能接收其他输入</p></blockquote><p>在栗子中，系统=食堂打饭的阿姨或者是餐厅服务生，输入=点菜，输出=端菜（上菜）</p><p>食堂阿姨只能一份一份的打饭———&gt; <font color="red">阻塞I/O</font></p><p>服务生点完菜之后还可以服务其他客人——-&gt;<font color="red">非阻塞I/O</font></p><h3 id="其实，这个问题小学老师就教过我们"><a href="#其实，这个问题小学老师就教过我们" class="headerlink" title="其实，这个问题小学老师就教过我们"></a>其实，这个问题小学老师就教过我们</h3><blockquote><p>小芳帮妈妈做家务，需要做：用洗衣机洗衣服（20分钟）、扫地（10分钟）、整理书桌（10分钟）、晾衣服（5分钟）。你能不能设计一个巧妙合理的新顺序，使小芳最少花（      ）分钟可以完成这些事？</p><p>A.20</p><p>B.25</p><p>C.30</p><p>D.35</p></blockquote><p>没想到吧？（其实我也没想到~）</p><p>在这个过程中，我们用洗衣机洗衣服=输入，晾衣服=输出，在洗衣机洗衣服的过程中，我们是可以去做其他事情的，所以这个属于<strong>非阻塞I/O</strong>哟。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>理解非阻塞I/O，首先要确定的是什么？</p><ul><li>我们要确定有一个输入/输出（input/output）的系统。</li><li>思考在I/O过程中，能不能进行其他I/O。<ul><li>能——&gt;非阻塞</li><li>不能——-&gt;阻塞</li></ul></li></ul><h3 id="写个栗子🌰"><a href="#写个栗子🌰" class="headerlink" title="写个栗子🌰"></a>写个栗子🌰</h3><p>先新建一个<code>index.js</code>，再打开我们前端人的vs-code，打开终端，执行<code>npm install glob</code>安装一个glob包，来帮我们更加方便去观察I/O是否阻塞。</p><p><font size="4" color="red">先来看阻塞I/O</font></p><p>代码先贴上：<code>index.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">&#x27;glob&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;glob&#x27;</span>)</span><br><span class="line">result = glob.sync(__dirname + <span class="string">&#x27;/**/*&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;glob&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先，先用require引入我们的glob包，接下来，用glob.sync去做一个打印目录的一个操作，将结果打印的同时，利用time/timeEnd，去记录时间，看node执行这个操作共花费多少时间。</p><p>在终端输入<code>node index.js</code>直接运行这个文件</p><p><img src="https://wangez.site/img/img/E4C%60~CXRE0ZX7OKAYH36QMX.png"></p><p>看第一行，在我的电脑上执行共花费20.93毫秒啊，这个数量在一个服务端来说，已经不小了。</p><p><font size="4" color="red">再看非阻塞I/O</font></p><p>直接上代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">&#x27;glob&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> result = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;glon&#x27;</span>)</span><br><span class="line">glob(__dirname + <span class="string">&#x27;/**/*&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,res</span>)</span>&#123;</span><br><span class="line">    result = res;</span><br><span class="line">    <span class="comment">// console.log(result)</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;got result&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;glob&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;今天你卷了没？&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这次采用一个回调函数的方式来进行操作，因为result的打印出来实在太多行了，我们将其替换为打印出’got result’，并在计时完成后进行一个打印语句的操作，让我们来看看结果：</p><p><img src="https://wangez.site/img/img/1628690658.jpg" alt="1628690658"></p><p>首先还是我们的时间：3.258ms，跟之前的20.93比起来，简直少了不要太多好嘛，完后是我们输出的语句，最后才打印了我们想要的操作结果，也就是说，它在输入输出之间进行了别的操作，对结果无影响，且用时少了好多！</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我的理解🐱‍🐉：非阻塞I/O让我们减少了许多等待的时间，并且在等待时间内，我们还可以进行一些其他的操作</p><blockquote><p>凡事没有绝对，不是说非阻塞I/O就一定是好的，还是拿餐厅举例子，比如服务员中间发生意外，所有的客人都要等这一个服务员，这样就会影响餐厅整体质量（可以理解为服务器奔溃）；阻塞I/O由于有多个服务员，一对一的服务，即使有一个发生意外，也不会影响整体质量，而雇多个服务员也要相应的付出成本。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域的问题终于能解决了</title>
      <link href="/posts/876750285.html/"/>
      <url>/posts/876750285.html/</url>
      
        <content type="html"><![CDATA[<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><h2 id="写在最前"><a href="#写在最前" class="headerlink" title="写在最前"></a>写在最前</h2><p>啊😭！在我大一学习前端，刚入门的时候，尝试着用jquery做一些小项目，这个东西困扰了我一个寒假！！！！当时没有跨域这个概念，于是乎就开始疯狂的百度。。。。为了不拖进度，把一个前后端分离的项目被逼成了不分离，后来还好，在开学前夕顺利解决，把不分离的“不”字去掉了，并也按时完成了项目！！！</p><blockquote><p>（拖了一个月左右应该也叫按时完成吧，不管了，先奖励自己一个🍗~）</p></blockquote><p>跨域问题真的成了我一段时间的心里阴影，后来一谈到跨域，心里贼怕！</p><p>最近复习网络部分，刷到了跨域的知识点，于是结合自己毕生所学（加上搜集的一丢资料），总结了一些关于跨域的知识。</p><span id="more"></span><h2 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h2><p>先举个栗子🌰，我博客的网址是：<a href="https://blog.wangez.site:8080/">https://blog.wangez.site:8080</a><br>最前面的https叫做<strong>协议</strong>，随后的blog.wangez.site叫做域名，最后的8080叫做端口号<br>（注：真实的博客网址不带8080，<a href="https://blog.wangez.site/">我的博客</a>，都说了是举个栗子🌰，不会有人当真了吧！！！）。</p><p>当前页面中的某个接口请求的地址和当前页面的地址如果<strong>协议、域名、端口其中有一项不同</strong>，就说该接口跨域了</p><h2 id="为什么有跨域？"><a href="#为什么有跨域？" class="headerlink" title="为什么有跨域？"></a>为什么有跨域？</h2><p><strong>浏览器</strong>为了保证网页的安全，出的<strong>同源协议策略</strong></p><blockquote><p>这部分以下摘录自MDN，想详细了解这部分可以去[MDN](<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">浏览器的同源策略 - Web 安全 | MDN (mozilla.org)</a>)上看看。</p></blockquote><p><strong>同源策略</strong>是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。</p><p>如果两个 URL 的 protocol、port (en-US) (如果有指定的话)和 host 都相同的话，则这两个 URL 是<em>同源</em>。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。（“元组” 是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）。</p><p>下表给出了与 URL <code>http://store.company.com/dir/page.html</code> 的源进行对比的示例:</p><table><thead><tr><th align="left">URL</th><th align="left">结果</th><th align="left">原因</th></tr></thead><tbody><tr><td align="left"><code>http://store.company.com/dir2/other.html</code></td><td align="left">同源</td><td align="left">只有路径不同</td></tr><tr><td align="left"><code>http://store.company.com/dir/inner/another.html</code></td><td align="left">同源</td><td align="left">只有路径不同</td></tr><tr><td align="left"><code>https://store.company.com/secure.html</code></td><td align="left">失败</td><td align="left">协议不同</td></tr><tr><td align="left"><code>http://store.company.com:81/dir/etc.html</code></td><td align="left">失败</td><td align="left">端口不同 ( <code>http://</code> 默认端口是80)</td></tr><tr><td align="left"><code>http://news.company.com/dir/other.html</code></td><td align="left">失败</td><td align="left">主机不同</td></tr></tbody></table><h2 id="跨域报错"><a href="#跨域报错" class="headerlink" title="跨域报错"></a>跨域报错</h2><p><img src="https://wangez.site/img/img/image-20210605180026687.png" alt="image-20210605180026687"></p><p>当我们测接口的时候，看见数据并没有如约而至，打开我们万能的浏览器控制台，看见了这个报错，不要犹豫，就是遇见了跨域问题！</p><h2 id="跨域解决办法"><a href="#跨域解决办法" class="headerlink" title="跨域解决办法"></a>跨域解决办法</h2><h3 id="cors"><a href="#cors" class="headerlink" title="cors"></a>cors</h3><p>  <strong>这是我目前写项目最常用的一种解决办法，也是当下最流行的方案，通过设置后端，来解决跨域，简单快捷</strong></p><blockquote><p>传说中的后端跨域！</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>); <span class="comment">// 允许跨域的源地址是什么，可以设置为*，也可以设成你的源地址</span></span><br><span class="line"></span><br><span class="line">res.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;Origin, X-Requested-With, Content-Type, Accept&quot;</span>); <span class="comment">// 设置返回数据类型</span></span><br><span class="line"></span><br><span class="line">res.setHeader(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;GET, PUT, OPTIONS, POST&quot;</span>); <span class="comment">// 控制哪种请求是可以跨域的</span></span><br><span class="line"></span><br><span class="line">res.setHeader(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="literal">true</span>); <span class="comment">// 跨域的时候是否携带cookie</span></span><br></pre></td></tr></table></figure><h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><p><strong>利用的原理是script标签可以跨域请求资源，将回调函数作为参数拼接在url中</strong></p><blockquote><p>传说中的前端跨域！但是需要后端的小伙伴们来配合我们一下哦🙄</p></blockquote><p>​         后端收到请求，调用该回调函数，并将数据作为参数返回去，注意设置响应头返回文档类型，应该设置成javascript</p><blockquote><p>res.setHeader(‘content-type’, ‘application/javascript’)     // 要注意不要忘了设置这个 ，否则会出错误！</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">JsonpCallback</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">             <span class="comment">// 在这里处理后端返回来的data数据</span></span><br><span class="line">             <span class="built_in">console</span>.log(data);</span><br><span class="line">         &#125;</span><br><span class="line">   &lt;/script&gt;</span><br><span class="line">   <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://127.0.0.1:12345/jsonp/callback=JsonpCallback&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="postmessage"><a href="#postmessage" class="headerlink" title="postmessage"></a>postmessage</h3><p>这个是我没听说过的一种方法，它是利用html5的api进行的，具有特定的使用场景。      </p><p>使用场景：一个页面中嵌入另一个iframe页面，</p><p>​        在主页面中使用postmessage发送数据，在iframe页面中用监听器接收数据</p><pre><code>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 主页面</span><br><span class="line">iFrame.onload = function () &#123;</span><br><span class="line">iFrame.contentWindow.postMessage(&#123; msg: &#x27;MessageFromIndexPage&#x27; &#125;, &#x27;\*&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">// iframe页面</span><br><span class="line">window.addEventListener(&quot;message&quot;, function (event) &#123;</span><br><span class="line"></span><br><span class="line">console.log(&#x27;这里是接收到来自父页面的消息，消息内容在event.data属性中&#x27;, event)</span><br><span class="line"></span><br><span class="line">&#125;, false)</span><br></pre></td></tr></table></figure></code></pre><h3 id="其他方法：node中间件、nginx反向代理、websocket等"><a href="#其他方法：node中间件、nginx反向代理、websocket等" class="headerlink" title="其他方法：node中间件、nginx反向代理、websocket等"></a>其他方法：node中间件、nginx反向代理、websocket等</h3><p>主要是因为同源策略是浏览器的限制，服务器和服务器之间没有限制</p><p>这次我们举个菠萝🍍，小红想要小绿的新玩具<strong>（发出接口请求）</strong>，但是小绿不给他<strong>（同源策略）</strong>，于是小红去找了小兰，对小兰说，我想要小绿的新玩具<strong>（准备去搞中间件进行转发或者做代理了）</strong>，小兰去跟小绿要来了新玩具<strong>（拿到了想要的数据，说明方法成功）</strong>，并将新玩具交给了小红<strong>（解决了跨域）</strong>。</p><blockquote><p>在这里面我只接触过node中间件跟nginx反向代理，也不算很深入的了解，所以就先不献丑啦，等日后学有所成再来填上这个坑！</p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>跨域是很常见的一个问题，也是出现在面试问题中频率比较高的问题，希望每个小伙伴们在遇到这个问题的时候都能顺利解决。虽然我们现在写项目的时候，框架中大都为我们配置了代理（Vue的proxyTable代理等），但是我想了解其根源对于我们的自我提高是非常有帮助的！</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端知识链条中少不了的一环--Ajax</title>
      <link href="/posts/1172116075.html/"/>
      <url>/posts/1172116075.html/</url>
      
        <content type="html"><![CDATA[<blockquote><p>不知不觉中又好久没写博客了，这几日因为在看计网，没有记录，于是又觉得自己没有学到什么东西，正好今天在牛客刷面经的时候看见了手撕Ajax，题材有了，于是文章它来了！</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当我们步入前端大门，走过HTML，看过CSS，翻过JavaScript，接下来你该遇到的，就是它了–Ajax。<br>​这个也是前端与后端交互所必需的东西，非常之重要。所以才有了标题的说法，它是前端知识链条中少不了的一环。</p><h2 id="什么是Ajax？"><a href="#什么是Ajax？" class="headerlink" title="什么是Ajax？"></a>什么是Ajax？</h2><p>Ajax的核心是JavaScript对象XmlHttpRequest，XmlHttp使我们可以使用JavaScript向服务器提出请求并处理响应，而不阻塞用户。<br>​通过XMLHttpRequest对象，前端开发人员就可以在页面加载以后进行页面的局部更新等操作。</p><span id="more"></span><h2 id="Ajax作用是什么？"><a href="#Ajax作用是什么？" class="headerlink" title="Ajax作用是什么？"></a>Ajax作用是什么？</h2><ul><li>通过异步模式，提升了用户体验</li><li>不在使用form表单提交（会出现跳转情况），提升了用户体验</li><li>Ajax可以实现局部刷新，不用在更新整个页面，传统的网页（不适用Ajax），想要更新内容必须重载整个页面。</li></ul><p>这就使得web应用程序能够更加敏捷的回应用户操作，避免了多次向服务端发送那些重复的数据。</p><h2 id="详解Ajax创建请求步骤"><a href="#详解Ajax创建请求步骤" class="headerlink" title="详解Ajax创建请求步骤"></a>详解Ajax创建请求步骤</h2><h3 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h3><p>步骤如下：<br>    1.创建一个对象<br>    2.设置请求参数<br>    3.发送请求<br>    4.监听请求成功后的状态变化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">request.open(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;url&quot;</span>)</span><br><span class="line">request.send()</span><br><span class="line">request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.readyState == <span class="number">4</span> &amp;&amp; <span class="built_in">this</span>.status == <span class="number">200</span>) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(request.responseText)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>open()</p><blockquote><p>open()方法创建了http请求，它有三个参数，第一个参数指定了提交的方式是POST还是GET，第二个参数是指定要提交的地址是哪，第三个参数是指定异步还是同步（true or false）【目前已经废弃第三个参数】</p></blockquote></li><li><p>send()</p><blockquote><p>send()方法表示着发送请求，不需要任何参数</p></blockquote></li><li><p>监听请求成功后的状态变化</p><blockquote><p>onreadystatechange：监听请求状态改变，readyState改变时会调用此方法，一般用于指定回调函数</p><p>readyState：共有五个状态</p><ul><li>0：未初始化</li><li>1：open方法成功调用后</li><li>2：服务器已经答应客户端的请求</li><li>3：交互中，http头信息已经接收，响应数据未接收</li><li>4：完成</li></ul><p>responseText：服务器端返回的文本内容，默认是字符串</p><p>status：服务器端返回的状态码</p><p>statusText：服务器端返回的状态码文本说明信息</p></blockquote></li></ul><h3 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h3><p>步骤如下：<br>    1.创建一个对象<br>    2.设置请求参数<br>    3.设置请求头<br>    4.发送请求<br>    5.监听请求成功后的状态变化<br>可以看出，post请求比get请求多出了一个设置请求头的步骤，也请大家记住，这个步骤千万不要忘记！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let XHR = new XMLHttpRequest(); </span><br><span class="line">XHR.open(&quot;POST&quot;, &quot;url&quot;); </span><br><span class="line">XHR.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); </span><br><span class="line">XHR.send(data);</span><br><span class="line">XHR.onreadystatechange = function () &#123;</span><br><span class="line">if (XHR.readyState == 4 &amp;&amp; XHR.status == 200) &#123;</span><br><span class="line">console.log(XHR.responseText); </span><br><span class="line">XHR = null; // 此处是为了释放对象，不写也行，js本身也会进行回收</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>send()：解释一下这里send里为什么有个data，这是我们通过Ajax发送post请求给服务器发送了一组data数据。</p></li><li><p>setRequestHeader()：设置请求头</p></li><li><p>readyState值说明 ：<br>  0.初始化,XHR对象已经创建,还未执行open<br>  1.载入,已经调用open方法,但是还没发送请求<br>  2.载入完成,请求已经发送完成<br>  3.交互,可以接收到部分数据<br>  4.数据全部返回</p></li><li><p>status值说明:<br>  1.200：成功<br>  2.404：没有发现文件、查询或url<br>  3.500：服务器内部发生错误</p><h2 id="Ajax中-GET与POST请求的区别"><a href="#Ajax中-GET与POST请求的区别" class="headerlink" title="Ajax中 GET与POST请求的区别"></a>Ajax中 GET与POST请求的区别</h2></li></ul><p>1.刚刚我们已经说过，get请求我们不用设置请求头，而post请求需要。<br>2.使用get请求的时候，参数在url中显示，而使用post方式则不会显示出来。<br>3.使用get请求发送的数据量小，post请求发送的数据量大。<br>4.get请求能够被缓存，post不进行缓存。get请求能够被保存在浏览器的历史记录中（密码等私密数据采用get方式提交，别人查看历史记录就能直接看到这些数据，造成数据泄漏）。<br>5.get产生一个TCP数据包，post产生两个tcp数据包。<br>    a. 对于get，浏览器会把header跟data一起发出去，服务器响应200，并返回数据。<br>    b. 对于post，浏览器先发送header，服务器响应continue，浏览器再发送data，服务器响应200，并返回数据。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>于端午前在牛客购买的课程，如今已经看完了百分之80，随着课程将基础滚了一遍，觉得差不大多了emm，下次回滚就应该是在面试前期了，跟随着面经来复习了！最近跟小伙伴们的风气真是越来越快乐了，卷的要命！</p><blockquote><p>每日一问：今日你卷了没？</p></blockquote><p>都是一群为了自己未来拼命的人，希望未来的我们会因为当时的环境而感激在大一大二就开始耗费时光，开始奋斗的自己！</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS中，函数原来有这么多种定义方法（暑假开始！）</title>
      <link href="/posts/1173819435.html/"/>
      <url>/posts/1173819435.html/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在期末与暑假假期画饼之间不断奔波，很长时间没有记录了，今天在学习的时候看到了ES6的箭头函数，瞬间找到了写文的动力，那就来梳理一下在JavaScript中一共有几种定义函数的方式吧，最后再（微微）重点的介绍一下箭头函数✨</p><p>过段时间，要加强算法学习了，这段时间也在力扣和牛客上找题做了一下，发现自己的算法真的烂，所以可能以后还会把算法题解写一写。（🍗+ 1）</p><h3 id="JavaScript定义函数的几种方式"><a href="#JavaScript定义函数的几种方式" class="headerlink" title="JavaScript定义函数的几种方式"></a>JavaScript定义函数的几种方式</h3><p>以下是定义函数的几种方式，真正书写的话，个人觉得没有什么必须要用某种格式的情况，根据团队风格或者个人习惯来就好。</p><span id="more"></span><h4 id="最初的我们"><a href="#最初的我们" class="headerlink" title="最初的我们"></a>最初的我们</h4><p>我们刚接触js的时候，见到的就是它啦😎</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;hello javascript&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">hello();</span><br></pre></td></tr></table></figure><p>这种方式大概也是陪伴我们时间最长的了吧？是不是呢？</p><h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><p>函数都是Function的实例对象，也就可以说函数是值，与字符串，数字等是一样的。这种方法就是通过表达式来定义函数，也就是定义匿名函数，再将匿名函数交给变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;hello javascript&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">hello();</span><br></pre></td></tr></table></figure><h4 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h4><p>这种方法大家应该也都见过，它是定义匿名函数来作为对象属性的值，与函数表达式的理念相同。这种形式最早是在ES3中引入的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line"><span class="attr">fun</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES5中，引入了访问器属性定义:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line"><span class="keyword">get</span> <span class="title">name</span>() &#123;&#125;,</span><br><span class="line"><span class="keyword">set</span> <span class="title">name</span>(<span class="params">name</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到get/set是不是感觉跟Java的类有一点像了，没错我也有这种感觉，继续往下看，类它来了！</p><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>在ES6中，有了类的概念（学过java的小伙伴们一定不会陌生），没错，js中也有类，而且也有构造方法等一些与Java类一样的东西。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.fun=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;实例方法&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;构造方法&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">jingtai</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;静态方法&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">yuanxingfangfa</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;原型方法&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实例方法：定义在构造方法constructor中的this对象上，在类中，构造方法中的this指的是它的实例对象</li><li>原型方法：与constructor方法同级，可以通过构造函数的原型链去调用，也可以通过实例对象来调用</li><li>静态方法：通过static关键字定义，不能被实例调用，可以被构造函数调用。</li></ul><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>终于到了我们这次文章的主角登场啦~  我去网上查了一些资料，浏览了CSDN和掘金的一些博客社区，很多人都觉得，它是ES2015最具有争议性的函数之一，但是它如今也已经变得众所周知，无处不在。它为函数声明提供了两种不同的格式，赋值表达式（箭头后无大括号”{}”）和函数体（代码种包括0到多个语句时）。这个语法还允许在描述单个参数的时候不加圆括号，0个或者1个以上的时候要加圆括号。这些语法结构允许箭头函数有着多种书写格式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参的赋值表达式</span></span><br><span class="line">(<span class="function">() =&gt;</span> <span class="number">2</span>*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个参数，忽略括号的赋值表达式</span></span><br><span class="line">(<span class="function"><span class="params">x</span> =&gt;</span> x*<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 一个参数，忽略括号直接跟函数体</span></span><br><span class="line">(<span class="function"><span class="params">x</span> =&gt;</span> &#123; <span class="keyword">return</span> x *<span class="number">2</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 括号中为参数列表和赋值表达式</span></span><br><span class="line">(<span class="function">(<span class="params">x,y</span>) =&gt;</span> x*y);</span><br></pre></td></tr></table></figure><p>来稍微解释一下箭头函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; x * <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>箭头函数相当于匿名函数，并且简化了函数定义，使用起来非常的方便。</p><p>但是使用箭头函数，我们要注意以下几点：</p><ul><li><p>箭头函数是没有this的，它的this是从外部获取的。</p></li><li><p>箭头函数不能做new操作，没有this意味着它不能用作构造，所以不能用new调用它们</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jiantou = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> jiantou();</span><br></pre></td></tr></table></figure><p>这时候会报错，<code>jiantou is not a constructor</code></p></li><li><p>箭头函数没有arguments对象，但是同this一样，他可以访问外围函数的arguments对象</p></li><li><p>箭头函数没有原型和super，它没有原型，也就不能通过super来访问原型的属性，不过同之前的this、arguments一样，这些值由外围最近一层的非箭头函数决定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jiantou = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(jiantou.prototype); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>🐱‍🐉终于水完了，溜了溜了。</p><p>还是那句话，你可以暂时不使用这种方法来写代码，但是你不能不会用，因为你不会知道什么时候会突然要求你用这种方法去进行业务操作。</p><p>快乐的暑假，开始了！</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于作用域与作用域链的理解</title>
      <link href="/posts/1077228788.html/"/>
      <url>/posts/1077228788.html/</url>
      
        <content type="html"><![CDATA[<h1 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>继续来了解一下ES6，顺便把前段时间留下作用域的坑也填上。</p><p>JavaScript中，有一个被称之为作用域(scope)的特性，在之前闭包的文章中提到过，现在来梳理一下。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><strong>作用域</strong>是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。</p><span id="more"></span><p>在<strong>ES6</strong>之前，JavaScript中有两种作用域，分别叫做<strong>全局作用域</strong>和<strong>函数作用域</strong>。</p><ul><li>全局作用域：<strong>全局作用域</strong>中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期，页面被关闭才会被销毁。</li><li>函数作用域：<strong>函数作用域</strong>就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。</li></ul><p>作用域给我的最大感觉就是隔离变量，在不同作用域的<strong>同名变量</strong>是不会冲突的。</p><p>在ES6中，提出了<strong>块级作用域</strong>的概念。</p><ul><li><p><strong>块级作用域的特点</strong>：在代码块内部定义的变量在外部是访问不到的，并且变量会在该代码块执行完后被销毁掉。</p></li><li><p><strong>块级作用域形式</strong>：就是使用大括号包裹的代码块<code>&#123;&#125;</code>，比如函数，判断语句，循环语句，甚至单独的一个<code>&#123;&#125;</code>，包裹的也可以看作是一个块级作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if块</span></span><br><span class="line"><span class="keyword">if</span>()&#123;&#125;</span><br><span class="line"><span class="comment">// while 块</span></span><br><span class="line"><span class="keyword">while</span>()&#123;&#125;</span><br><span class="line"><span class="comment">// 函数块</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="comment">// for循环块</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;&#125;</span><br><span class="line"><span class="comment">// 单独的&#123;&#125;</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>如何让块级作用域生效，ES6给我们提供了两个关键字：<strong>let和const</strong></p><p>来看看例子吧</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// not defined</span></span><br></pre></td></tr></table></figure><p>我们来思考一道题：每隔一秒钟，打印出来一个自然数，自然数递增。</p><p>是不是用一个for循环，里面设置好一个定时器？</p><p>是这样？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;,<span class="number">1000</span>*i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是这样？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;,<span class="number">1000</span>*i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>let、const关键字解决var变量提升的问题</strong></p><p>之前有说过变量提升的问题，现在来看一下let与const是怎么解决问题的。</p><p>首先举一下都会产生什么问题：</p><ul><li><p>变量提升会导致变量值被覆盖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;张三&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;李四&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">showA() <span class="comment">// undefined  undefined</span></span><br></pre></td></tr></table></figure></li><li><p>该销毁的变量销毁不掉</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br></pre></td></tr></table></figure></li></ul><p>那么let、const是如何解决问题的呢？</p><p>先来看一下这段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"><span class="keyword">var</span> a = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">22</span>;</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">let</span> b = <span class="number">33</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">44</span>;</span><br><span class="line">        <span class="keyword">let</span> d = <span class="number">55</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(a); <span class="comment">// 11</span></span><br><span class="line">        <span class="built_in">console</span>.log(b); <span class="comment">// 33</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 22</span></span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// 44</span></span><br><span class="line"><span class="built_in">console</span>.log(d); <span class="comment">// not defined</span></span><br><span class="line">&#125; </span><br><span class="line">fun()</span><br></pre></td></tr></table></figure><ul><li><p>let与const关键字创建的变量是存储在词法环境的，而var创建的变量是存储在变量环境中的，访问变量的时候，先从执行上下文的词法环境中查找，再到变量环境中进行查找。</p></li><li><p>当块级内部代码执行结束后，内部let与const创建的变量会被销毁。</p></li><li><p>let跟const创建的变量，初始化不提升，创建提升，所以会造成<strong>暂时性死区</strong></p><p>来看一下什么是暂时性死区吧</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这个时候，我们的浏览器报错与之前的not defined就不一样了，它会报 <code> Cannot access &#39;a&#39; before initialization</code>这个错误，告诉我们在初始化前不能访问a这个变量，这是因为let与const只有创建提升，没有初始化提升，所以造成了这个问题。</p></li></ul><p><strong>再次说明一下变量提升的问题</strong></p><ul><li>var的创建和初始化被提升，赋值不会被提升</li><li>let的创建被提升，初始化和赋值不会被提升，所以会有暂时性死区的问题（就是访问不到变量）</li><li>function的创建、初始化、赋值都会被提升</li></ul><p><strong>作用域的特点：是代码编译阶段就决定好的，和函数是如何调用的没有关系</strong></p><p>看下面这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">biqibao</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">&quot;海绵宝宝&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> test1 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span>) &#123; </span><br><span class="line">    <span class="keyword">let</span> myName = <span class="string">&quot;派大星&quot;</span>; </span><br><span class="line">    <span class="built_in">console</span>.log(test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">&quot;章鱼哥&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> test = <span class="number">2</span>;</span><br><span class="line">    &#123; </span><br><span class="line">    <span class="keyword">let</span> test = <span class="number">3</span>;</span><br><span class="line">        biqibao();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">&quot;珊迪&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> myAge = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> test =<span class="number">1</span>;</span><br><span class="line">fn(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>解释一下流程，biqibao函数在fn函数中被调用，要打印test变量，首先查找biqibao函数的内部作用域，没有找到，于是去到全局作用域进行查找，找到了let test = 1这句话，于是，打印1。与fn函数中的let test = 2这句话，一点关系都没有。</p><p>这就是在诠释上面<strong>作用域特点</strong>的那句话。</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p><strong>作用域链</strong>：当一个函数中使用了某个变量，首先会在自己内部作用域查找，然后再向外部一层一层查找，直到全局作用域，这个链式查找就是作用域链</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br><span class="line">fn3();</span><br><span class="line">&#125;</span><br><span class="line">fn2();</span><br><span class="line">&#125;</span><br><span class="line">fn1(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>fn3要打印num变量，于是他从fn3的函数作用域，找到fn2的函数作用域，再找到fn1的函数作用域，再找到全局作用域，终于找到了num变量，成功将其打印。</p><h2 id="有话想说"><a href="#有话想说" class="headerlink" title="有话想说"></a>有话想说</h2><p>终于把心心念念的坑填上了一个，了解完作用域与作用域链，再去了解闭包就会轻松很多了，继续努力学习吧。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解构运算符的理解与运用</title>
      <link href="/posts/1586874348.html/"/>
      <url>/posts/1586874348.html/</url>
      
        <content type="html"><![CDATA[<h1 id="解构符号"><a href="#解构符号" class="headerlink" title="解构符号"></a>解构符号</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近一直在学JavaScript，看到了ES6中的解构符号，觉得这个给我们的代码简洁性带来了一个飞跃式的提升，而且它已经运用在了企业开发中，假如未来你工作中，别人在用，你却读不懂别人的代码，这造成的影响还是很大的。因此，好好学习一下吧。</p><p><strong>你可以不用，但是你不能不懂✔</strong></p><p>JavaScript ES6中，有很多特性都是为了简化代码，方便程序员去书写的。解构运算符就是其中很好的特性，它可以通过减少赋值语句的使用，或者减少访问数据下标、对象属性的方式，使得代码更加简洁，增强了代码的可读性。</p><span id="more"></span><h2 id="解构符号的作用"><a href="#解构符号的作用" class="headerlink" title="解构符号的作用"></a>解构符号的作用</h2><p>解构赋值是对赋值运算符的扩展，他是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值</p><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为<strong>解构</strong></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul><li><p>基本使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">// let a = 1, b = 2, c = 3;</span></span><br></pre></td></tr></table></figure></li><li><p>嵌套使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"> <span class="keyword">let</span> [a, [[b], c]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line"> <span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: [<span class="string">&#x27;hello&#x27;</span>, &#123;<span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span>&#125;] &#125;;</span><br><span class="line"> <span class="keyword">let</span> &#123; <span class="attr">x</span>: [x,&#123; y &#125;] &#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// hello</span></span><br><span class="line"><span class="built_in">console</span>.log(y); <span class="comment">// world</span></span><br></pre></td></tr></table></figure></li><li><p>忽略</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"> <span class="keyword">let</span> [a, , b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line"> <span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: [<span class="string">&#x27;hello&#x27;</span>, &#123; <span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span> &#125;] &#125;;</span><br><span class="line"> <span class="keyword">let</span> &#123; <span class="attr">x</span>: [x, &#123; &#125;] &#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure></li><li><p>不完全解构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"> <span class="keyword">let</span> [a = <span class="number">1</span>, b] = [];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line"> <span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: [&#123; <span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span> &#125;] &#125;;</span><br><span class="line"> <span class="keyword">let</span> &#123; <span class="attr">x</span>: [&#123; y &#125;, x] &#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(y); <span class="comment">// world</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>剩余运算符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"> <span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// [2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line"> <span class="keyword">let</span> &#123;a, b, ...rest&#125; = &#123;<span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(rest); <span class="comment">// &#123; c: 30, d: 40 &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// h</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// e</span></span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// l</span></span><br><span class="line"><span class="built_in">console</span>.log(d); <span class="comment">// l</span></span><br><span class="line"><span class="built_in">console</span>.log(e); <span class="comment">// o</span></span><br></pre></td></tr></table></figure></li><li><p>解构默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当解构模式有匹配结果，且匹配结果是 undefined 时，会触发默认值作为返回结果。</span></span><br><span class="line"> <span class="keyword">let</span> [a = <span class="number">2</span>] = [<span class="literal">undefined</span>]; </span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">let</span> &#123;a = <span class="number">10</span>, b = <span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;;</span><br><span class="line"> <span class="built_in">console</span>.log(a); <span class="comment">// 3</span></span><br><span class="line"> <span class="built_in">console</span>.log(b); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></li><li><p>交换变量的值.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">[a,b] = [b,a];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="解构赋值的应用"><a href="#解构赋值的应用" class="headerlink" title="解构赋值的应用"></a>解构赋值的应用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 浅克隆与合并</span></span><br><span class="line"><span class="keyword">let</span> name = &#123; <span class="attr">name</span>: <span class="string">&quot;aaa&quot;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> age = &#123; <span class="attr">age</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123; ...name, ...age &#125;</span><br><span class="line"><span class="built_in">console</span>.log(person) <span class="comment">// &#123; name: &quot;aaa&quot;, age: &#x27;bbb&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> c = [...a,...b];</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 提取JSON数据</span></span><br><span class="line"><span class="keyword">let</span> JsonData = &#123; <span class="attr">id</span>: <span class="number">10</span>, <span class="attr">status</span>: <span class="string">&quot;OK&quot;</span>, <span class="attr">data</span>: [<span class="number">111</span>, <span class="number">222</span>] &#125; </span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: numbers &#125; = JsonData; </span><br><span class="line"><span class="built_in">console</span>.log(id, status, numbers); <span class="comment">//10 &quot;OK&quot; [111, 222]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 函数参数的定义</span></span><br><span class="line"><span class="comment">// 参数有序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params">[a, b, c]</span>) </span>&#123; <span class="built_in">console</span>.log(a, b, c) &#125; </span><br><span class="line">fun1([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数无序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params">&#123; x, y, z &#125;</span>) </span>&#123; <span class="built_in">console</span>.log(x, y, z) &#125; </span><br><span class="line">fun2(&#123; <span class="attr">z</span>: <span class="number">3</span>, <span class="attr">x</span>: <span class="number">2</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;); <span class="comment">// 2 1 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数有默认值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun3</span> (<span class="params">[a=<span class="number">1</span>,b]</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);</span><br><span class="line">&#125;</span><br><span class="line">fun3([,<span class="number">3</span>]) <span class="comment">// 1 3</span></span><br></pre></td></tr></table></figure><h2 id="浅谈应用"><a href="#浅谈应用" class="headerlink" title="浅谈应用"></a>浅谈应用</h2><h3 id="提取json数据"><a href="#提取json数据" class="headerlink" title="提取json数据"></a>提取json数据</h3><p>上面列出了几种解构赋值的应用，其中我们最常用的应该是第二种，<strong>提取json数据</strong>，后端传给前端的数据就是json数据，前端通常要将数据赋值给一个对象，就是使用的这种方法。</p><h3 id="可扩展运算符"><a href="#可扩展运算符" class="headerlink" title="可扩展运算符..."></a>可扩展运算符<code>...</code></h3><p>我在leetcode上刷题的时候使用过，我是用<code>arr.push(...arr1)</code>来合并两个数组的，有点像上面的<strong>浅克隆与合并</strong>。比起以往我们合并数组的操作，这个简直不要太简单。</p><p>第88题，合并两个有序数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class="line">    nums1.length=m;</span><br><span class="line">    nums2.length=n;</span><br><span class="line">    nums1.push(...nums2);</span><br><span class="line">    <span class="keyword">let</span> arr=nums1.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>...</code>这个运算符是将数组中的数据遍历出来，并拷贝到当前对象当中。</p><p><code>arr.push(...arr1)</code>这个方法会将arr1的数组元素全部解析出来，然后依次添加到arr中去，完成两个数组的合并。</p><h3 id="交换变量值"><a href="#交换变量值" class="headerlink" title="交换变量值"></a>交换变量值</h3><p>再来看看<strong>交换变量值这个应用</strong>，我依稀记得一位学长的面试题：不占用额外内存空间的情况下，交换a与b的值。当时有两种解法，一是使用异或，二是用数学方法，将ab相加，再分别减之，(a=a+b,b=a-b,a=a-b)，现在使用解构符号的这个方法<code>[a,b] = [b,a]</code>，是不是也可以呢？</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于闭包的一些理解</title>
      <link href="/posts/400024894.html/"/>
      <url>/posts/400024894.html/</url>
      
        <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我是在大一下，一个学姐面试的时候，第一次听闻闭包这个名词。当时听了一些学长的解释（虽然没怎么听懂），但是觉得，似乎很高级的样子。</p><p>如今时隔一年，跟闭包也打了不少交道，终于也能谈一谈自己对于它的理解了。</p><h2 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h2><span id="more"></span><p>闭包是什么？ ——可简单理解为：<strong>有权访问另一个函数作用域内变量的函数都是闭包。</strong></p><p>先来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drink</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> beerName = <span class="string">&quot;雪花啤酒&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> beerNum1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> beerNum2 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> innerBeer = &#123;</span><br><span class="line"><span class="attr">getBeer</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(beerNum1)</span><br><span class="line"><span class="keyword">return</span> beerName</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">setBeer</span>:<span class="function"><span class="keyword">function</span>(<span class="params">newBeer</span>) </span>&#123;</span><br><span class="line">beerName = newBeer</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> innerBeer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> go = drink();</span><br><span class="line">go.setbeer(<span class="string">&quot;闷倒驴&quot;</span>);</span><br><span class="line">go.getBeer();</span><br><span class="line"><span class="built_in">console</span>.log(go.getBeer())</span><br></pre></td></tr></table></figure><p>当我们使用到getBeer与setBeer这两个函数的时候，它们内部是没有变量beerNum1与beerName的，那么它们这个时候会怎么办呢，学过作用域链的小伙伴可能会了解，它们这个时候就会到外层去找，也就是去drink函数中去找，找到了，于是乎可以使用了。</p><p>但是呢，问题又来了，drink是个函数，它的作用域叫做函数作用域，在drink函数执行完，这个作用域是要被销毁的，那么这个时候，innerBeer又该怎么做呢？</p><p>还是因为作用域链的原因，即使drink已经执行完了，当innerBeer再次调用其下的两个方法时，它用到的变量，是不能被销毁的，也就是说，beerNum1与beerName被迫成为了<strong>钉子户</strong>。</p><p><strong>innerBeer：我只要在用，你就不能销毁！</strong>🤣</p><p>而这，就是闭包。</p><p><strong>闭包：这就是我</strong>✌</p><h2 id="为什么说闭包容易产生内存泄漏？"><a href="#为什么说闭包容易产生内存泄漏？" class="headerlink" title="为什么说闭包容易产生内存泄漏？"></a>为什么说闭包容易产生内存泄漏？</h2><p>首先我们要知道一个概念：什么是内存泄漏？</p><p><strong>当内存中产生了不能被回收的变量，就叫内存泄漏</strong></p><p>还是看刚刚的那个例子，<code>var go = drink();</code></p><p>go是一个全局变量，无论在什么时候都可以调用setBeer与getBeer，因为我们将函数的返回值赋值给了它，只要页面没有销毁，它就会一直存在。而setBeer跟getBeer又会用到beerNum1与beerName，也就是前文中我们提到的，钉子户理论。结合JavaScript的垃圾回收机制，我们现在知道，它们两个钉子户是不可能被清除掉的了。</p><p>这块存有beerNum1与beerName的内存，只有setBeer与getBeer才能访问到，别人是访问不到的。而它也不属于哪一个执行上下文中，所以它也销毁不掉。</p><p>所以就说，<strong>闭包容易产生内存泄漏的问题</strong></p><p><strong>只要页面不关闭，这个变量就一直在，导致存在内存泄漏的问题</strong></p><h2 id="为什么还要使用闭包？"><a href="#为什么还要使用闭包？" class="headerlink" title="为什么还要使用闭包？"></a>为什么还要使用闭包？</h2><p>张三（👀没错就是法外狂徒本三）就说了：<strong>闭包既然会产生内存泄漏的问题，那我们为什么还要去使用它呢？</strong></p><p>还不是因为，我们<strong>在某些情况下，希望某些函数内的变量在函数执行后不被销毁</strong>(我也知道，好像有那么一丝🗡意)。</p><p>张三又有疑问了：那为什么干脆不定义成全局变量呢？现在搞得你还回收不了。</p><p>如果创建全局变量的话，它很容易就会被污染，同名变量，或者被一些函数修改等。为了避免它被篡改，又想让它长时间保存，让他变得形似一个全局变量，可以随时去用，我们就会在这个时候，使用闭包！</p><p><strong>请注意：闭包一定要慎用</strong></p><h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2><p>查了几个闭包的应用，学习一下ing</p><ul><li><p>模仿块级作用域</p><ul><li>计时器的一个应用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; <span class="number">1</span> &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      (<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(j);</span><br><span class="line">        &#125;, <span class="number">1000</span> * j)</span><br><span class="line">      &#125;)(i)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>打印一组li的下标</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.length; i++) &#123;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">lis[j].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>埋点计数器</p><ul><li>产品让做的网站分析的一种常用的数据采集方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ++num</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getNum = count();  <span class="comment">// 第一个需要统计的地方</span></span><br><span class="line"><span class="keyword">var</span> getNewNum = count(); <span class="comment">//第二个需要统计的地方</span></span><br><span class="line"> <span class="comment">// 如果我们统计的是两个button的点击次数</span></span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;button&#x27;</span>)[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;点击按钮1的次数：&#x27;</span>+getNum());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;button&#x27;</span>)[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;点击按钮2的次数：&#x27;</span>+getNewNum());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>柯里化</p><ul><li>把一个多参数的函数转化成单参数函数的方法，使得更灵活方便</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原函数 用来检验文本是否符合规范</span></span><br><span class="line"><span class="comment">// reg 传入的正则表达式  txt 需要被检测的文本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">reg,txt</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> reg.test(txt)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(check(电话号码的正则,<span class="number">13923456789</span>));</span><br><span class="line"><span class="built_in">console</span>.log(check(邮箱的正则,youxiang@<span class="number">163.</span>com));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现如今</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nowCheck</span>(<span class="params">reg</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">txt</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> reg.test(txt)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> isPhone = nowCheck(电话号码的正则)</span><br><span class="line"><span class="built_in">console</span>.log(isPhone(<span class="string">&#x27;13923456789&#x27;</span>))</span><br><span class="line"><span class="keyword">var</span> isEmail = nowCheck(邮箱的正则)</span><br><span class="line"><span class="built_in">console</span>.log(isEmail(<span class="string">&#x27;youxiang@163.com&#x27;</span>))</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结：简单说一下闭包吧"><a href="#总结：简单说一下闭包吧" class="headerlink" title="总结：简单说一下闭包吧"></a>总结：简单说一下闭包吧</h2><p><strong>闭包产生的原因</strong></p><p>函数中的局部变量在函数执行完后会被销毁，有时候，我们不希望这个局部变量会被销毁，我们还想在外部进行持续的操作和访问，我们就会用到闭包这种方式。</p><p><strong>为什么不创建一个全局变量来代替这个局部变量？</strong></p><p>因为全局变量会被污染或者被修改。</p><p>闭包能够访问里面的变量，是由于作用域链，用到了函数嵌套中，内部函数能够访问父级函数作用域的变量这个理念。</p><p><strong>闭包能够造成内存泄漏</strong></p><p>页面不关闭，变量就一直在，不能被垃圾回收机制回收或者手动清除。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>框架简介之Vue.js</title>
      <link href="/posts/2624959054.html/"/>
      <url>/posts/2624959054.html/</url>
      
        <content type="html"><![CDATA[<h1 id="框架介绍"><a href="#框架介绍" class="headerlink" title="框架介绍"></a>框架介绍</h1><h2 id="前端框架有哪些？"><a href="#前端框架有哪些？" class="headerlink" title="前端框架有哪些？"></a>前端框架有哪些？</h2><h3 id="React（GitHub-No-1）"><a href="#React（GitHub-No-1）" class="headerlink" title="React（GitHub No.1）"></a>React（GitHub No.1）</h3><p>React起源于Facebook的内部消息。React官方是这样介绍的它：一个声明式、高效、灵活的、创建用户界面的JavaScript库，即使React的主要作用是构建UI，但是项目的逐渐成长已经使得react成为前后端通吃的WebApp解决方案。</p><h3 id="Vue（GitHub-No-2）"><a href="#Vue（GitHub-No-2）" class="headerlink" title="Vue（GitHub No.2）"></a>Vue（GitHub No.2）</h3><p>vue官网说：Vue.js 是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。<br>渐进式，我个人理解就是阶梯式向前。vue是轻量级的，它有很多独立的功能或库，我们会根据我们的项目来选用vue的一些功能。就像我们开发项目时如果只用到vue的声明式渲染，我就只用vue的声明渲染，而我们要用他的组件系统，我们可以引用它的组件系统。<br>vue的渐进式表现为：</p><span id="more"></span><blockquote><p>声明式渲染——组件系统——客户端路由——-大数据状态管理——-构建工具</p></blockquote><h3 id="Augular（GitHub-No-3）"><a href="#Augular（GitHub-No-3）" class="headerlink" title="Augular（GitHub No.3）"></a>Augular（GitHub No.3）</h3><p>AngularJS 是一款开源JavaScript库，由Google维护，用来协助单一页面应用程序运行,它是基于ES6来开发的。</p><p>它是前端/客户端JavaScript框架，由Google创建和维护，用于构建功能强大的单页应用程序，通过表达式绑定数据到 HTML。</p><h2 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h2><h3 id="Vue的核心点"><a href="#Vue的核心点" class="headerlink" title="Vue的核心点"></a>Vue的核心点</h3><h4 id="1-响应式数据绑定"><a href="#1-响应式数据绑定" class="headerlink" title="1.响应式数据绑定"></a>1.响应式数据绑定</h4><p>当数据发生变化时，Vue自动更新视图。</p><p>原理是利用了 Object.definedProperty中的setter/getter代理数据，监控对数据的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;app&#x27;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#x27;Welcome to Your Vue.js App&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> </span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="2-可组合的视图组件"><a href="#2-可组合的视图组件" class="headerlink" title="2.可组合的视图组件"></a>2.可组合的视图组件</h4><p>一个页面被映射成组件树，将组件进行划分，方便维护，复用，测试，也就是说一个页面是由多个组件组合而成。</p><p><img src="https://wangez.site/img/shangke/zujian.png" alt="img"></p><p><img src="https://wangez.site/img/shangke/dom.png" alt="img"></p><h4 id="3-虚拟Dom"><a href="#3-虚拟Dom" class="headerlink" title="3.虚拟Dom"></a>3.虚拟Dom</h4><p>虚拟Dom是随着时代发展而诞生的产物。</p><p>在Web早期，页面的交互都十分简单，没有复杂的状态需要管理，也不需要频繁操作Dom，使用JQ来开发就能满足我们的需求。</p><p>随着时代不断发展，功能越来越多，我们需要实现的需求就越来越复杂，程序中需要维护的状态也就越来越多，导致Dom操作越来越频繁。</p><p>那么，我们再像以前那样，使用JQ来发开页面的时候，就会有一大部分代码是在操作Dom，程序中的状态也很难管理，代码的逻辑就会十分混乱。</p><p>这其实是命令式操作Dom的问题，虽然简单，但是不好维护。</p><p>现在，主流的前端的框架，都是声明式操作Dom。我们通过描述状态和Dom之间的映射关系是怎样的，就可以将状态渲染成视图，至于怎么渲染的，框架会帮我们去做，不用我们手动去操作Dom。</p><p>运行的JavaScript代码速度是很快的，但是有大量的操作DOM就会很慢，时常在更新数据后会重新渲染页面，这样造成在没有改变数据的地方也重新渲染了DOM节点，这样就造成了很大程度上的资源浪费。</p><p><strong>利用在内存中生成与真实DOM与之对应的数据结构，这个在内存中生成的结构称之为虚拟DOM</strong></p><p>当数据发生变化时，能够智能地计算出重新渲染组件的最小代价并应用到DOM操作上</p><p><img src="https://wangez.site/img/shangke/xunidom1.png" alt="img"></p><p><img src="https://wangez.site/img/shangke/xunidom2.png" alt="img"></p><h4 id="4-MVVM"><a href="#4-MVVM" class="headerlink" title="4.MVVM"></a>4.MVVM</h4><p><strong>MVVM概述：</strong>M：Model数据模型 ， V：view 视图模板  ， VM：view-Model：视图模型</p><p><img src="https://wangez.site/img/shangke/mvvm.png" alt="img"></p><p>Vue中的MVVM实例（双向数据绑定）：当输入框输入数据的时候，相应的message也会改变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;message&quot;/&gt;</span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;app&#x27;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        message: &#x27;Welcome&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> </span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="5-声明式渲染"><a href="#5-声明式渲染" class="headerlink" title="5.声明式渲染"></a>5.声明式渲染</h4><p>Vue.js 的核心是一个允许采用简洁的模板语法来声明式的将数据渲染进 DOM，初始化根实例，vue自动将数据绑定在DOM模板上</p><p>声明式渲染与命令式渲染区别</p><p>声明式渲染：所谓声明式渲染只需要声明在哪里，做什么，而无需关心如何实现</p><p>命令式渲染：需要具体代码表达在哪里，做什么，如何实践<br>需求：求数组中每一项的倍数，放在另一个数组中</p><p><strong>命令式渲染：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5]</span><br><span class="line">  var newArr = []</span><br><span class="line">  for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    newArr.push(arr[i] * 2)</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(newArr)</span><br></pre></td></tr></table></figure><p><strong>声明式渲染：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5]</span><br><span class="line">  var newArr = arr.map(function (item) &#123;</span><br><span class="line">    return item * 2</span><br><span class="line">  &#125;)</span><br><span class="line">  console.log(newArr)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js基础环境的搭建以及简单使用Element-ui</title>
      <link href="/posts/3896443464.html/"/>
      <url>/posts/3896443464.html/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue（2-x）"><a href="#Vue（2-x）" class="headerlink" title="Vue（2.x）"></a>Vue（2.x）</h1><h2 id="Vue的环境配置"><a href="#Vue的环境配置" class="headerlink" title="Vue的环境配置"></a>Vue的环境配置</h2><h3 id="Node-js的安装"><a href="#Node-js的安装" class="headerlink" title="Node.js的安装"></a>Node.js的安装</h3><p>Vue的运行是依赖node进行的，所以安装Vue之前，要先去node的官网去安装node。安装结束之后可以使用下面的命令查看安装是否成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><h3 id="npm-yarn"><a href="#npm-yarn" class="headerlink" title="npm/yarn"></a>npm/yarn</h3><p>npm（node package manager），俗称包管理器（类比于java里的maven），顾名思义，主要功能就是管理node包，包括：安装、卸载、更新等等。</p><p>他未经更改过的源，是国外的镜像，所以经常会有包丢失或者下载速度慢，建议自己换成淘宝源（阿里做的同步镜像）</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//临时</span><br><span class="line">npm --registry https://registry.npm.taobao.org install express</span><br><span class="line">//永久</span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line">npm install express</span><br></pre></td></tr></table></figure><p>yarn的话，直接去官网下载安装就行。</p><h3 id="Vue-cli"><a href="#Vue-cli" class="headerlink" title="Vue-cli"></a>Vue-cli</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-cli -g</span><br></pre></td></tr></table></figure><p>Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，提供：</p><ul><li><p>通过 <code>@vue/cli</code> 实现的交互式的项目脚手架。</p></li><li><p>通过 <code>@vue/cli</code> + <code>@vue/cli-service-global</code> 实现的零配置原型开发。</p></li><li><p>一个运行时依赖 (</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@vue/cli-service</span><br></pre></td></tr></table></figure><p>)，该依赖：</p><ul><li>可升级！；</li><li>基于 webpack 构建，并带有合理的默认配置！；</li><li>可以通过项目内的配置文件进行配置！；</li><li>可以通过插件进行扩展！。</li></ul></li><li><p>一个丰富的官方插件集合，集成了前端生态中最好的工具。</p></li><li><p>一套完全图形化的创建和管理 Vue.js 项目的用户界面！ 。</p></li></ul><p>Vue CLI 致力于将 Vue 生态中的工具基础标准化。它确保了各种构建工具能够基于智能的默认配置即可平稳衔接，这样你可以专注在撰写应用上，而不必花好几天去纠结配置的问题。</p><p>到现在，Vue的环境可以说是暂时配置完成了！下面我们去new一个Vue项目吧。</p><h2 id="Vue项目的搭建（Vue-ui）"><a href="#Vue项目的搭建（Vue-ui）" class="headerlink" title="Vue项目的搭建（Vue-ui）"></a>Vue项目的搭建（Vue-ui）</h2><p>首先打开vs-code，在终端中输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue ui</span><br></pre></td></tr></table></figure><p><img src="https://wangez.site/img/shangke/vueui.png" alt="vueui"></p><p>等待一会，就会打开Vue的一个图形化管理界面。</p><p><img src="https://wangez.site/img/shangke/vue-ui.png" alt="vue-ui"></p><p>点击左下角那个小房子的按钮，进入到项目管理的主页</p><p>点击创建项目。</p><p><img src="https://wangez.site/img/shangke/chuangjian.png" alt="chuangjian"></p><p>初始化git仓建议勾选打开，包管理器默认就好，接着我们只需要输入项目名字就可以点击下一步了</p><p><img src="https://wangez.site/img/shangke/detail.png" alt="detail"></p><p>他会让我们选择一套预设，图中的第一个，是Vue2的官方默认模板，第二个是Vue3的默认模板，第三个选项是让我们手动配置本项目的配置，并可以保存成模板，方便下次使用，最后一个就是从你的git仓库去拉取一套预设，作为本项目的预设。</p><p>因为方便大家操作，所以我们选择手动配置。</p><p><img src="https://wangez.site/img/shangke/gongneng1.png" alt="gongneng2"></p><p><img src="https://wangez.site/img/shangke/gongneng2.png" alt="gongneng2"></p><p>来详细说明一下这些选择都是什么意思。</p><ul><li>选择Vue版本，这个就是让你选择你项目到底是用Vue2还是Vue3来做开发</li><li>Babel，是一个JavaScript编译器。</li><li>TypeScript（微软开发），JavaScript的超集，可以编译成JavaScript。</li><li>Router，vue-router，路由组件</li><li>Vuex，提供vue中的状态管理</li><li>CSS Pre-processors，CSS预处理，Less，Sass，Stylus。</li><li>Linter/Formatter，代码质量检查，代码规范验证。（ESlint真的很烦人）</li><li>使用配置文件，这个是中文的，我就不解释了，勾选就行！</li></ul><p>我勾选的有1、2、router、Linter/Formatter、使用配置文件。（因为Vuex，在本次演示中用不到）</p><p>进入配置页面，</p><p><img src="https://wangez.site/img/shangke/peizhi.png" alt="peizhi"></p><p>第一个，我们看见后面2.x的时候就明白了，这个就是选择Vue2 or Vue3的一个选项。</p><p>第二个，日常关闭就好，对我们作用不大。</p><p>重点来了，第三个是让我们选择代码检查的一个严格程度。</p><p>提供了四个选项：</p><ul><li>ESlint with error prevention only (友好)</li><li>ESlint + Airbnb config (地狱)</li><li>ESlint + Standard config (标准)</li><li>ESlint + Prettier (美观？)</li></ul><p>我标注的备注都很明显的说出来了这几个标准是什么样子的，本人选的是第一个，但是不管选哪个都无所谓，这个可以进去从配置文件进行修改，只是有点麻烦的事情。</p><p><img src="https://wangez.site/img/shangke/baocunyushe.png" alt="baocunyushe"></p><p>点击创建，他会提示你是否保存此次预设，可以依据自己的情况来选择。</p><p>这样，我们的项目就创建完成了！</p><h3 id="Hello-Vue"><a href="#Hello-Vue" class="headerlink" title="Hello Vue"></a>Hello Vue</h3><p>打开你的开发工具（我使用的是Vs code）</p><p>打开该项目的终端</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run serve 或者 yarn serve</span><br></pre></td></tr></table></figure><p><img src="https://wangez.site/img/shangke/yunxing.png" alt="yunxing"></p><p>第一个是本地地址</p><p>第二个是网络地址</p><p>我们在浏览器访问一下：</p><p><img src="https://wangez.site/img/shangke/chuagnjiantrue.png" alt="chuagnjiantrue"></p><p>至此，一个Vue项目就创建成功了。</p><h2 id="Vue的目录结构"><a href="#Vue的目录结构" class="headerlink" title="Vue的目录结构"></a>Vue的目录结构</h2><ul><li>node_moudules:依赖保存的地方</li><li>public:静态资源保存的地方</li><li>dist:项目打包过后，需要挂载的目录</li><li>src:写代码的地方<ul><li>assets：src中引用的静态资源（要区别于public static）</li><li>componets：组件</li><li>router：路由</li><li>views：视图（页面）</li><li>App.vue：页面共有</li><li>main.js：全局依赖或者配置</li></ul></li><li>package.json：配置项目的基本信息和依赖的大概版本，这里强调一下，该文件的依赖版本只是指定大概的范围，具体真是下载的版本以package-lock.json为主</li><li>package-lock.json：记录node_modules依赖的真是版本</li><li>README.md:项目说明</li></ul><h2 id="Element-ui"><a href="#Element-ui" class="headerlink" title="Element-ui"></a>Element-ui</h2><p>element-ui是饿了么团队基于Vue2，封装的一个组件库，截止到目前，他可以搭配Vue2，Vue3，React，Augular等框架进行开发。</p><h3 id="我觉得它的好处"><a href="#我觉得它的好处" class="headerlink" title="我觉得它的好处"></a>我觉得它的好处</h3><p>他的官方文档对小白很友好，讲解的很细致，组件，组件的属性，提供的钩子，触发事件传的参数等等，都给出了详细的说明。</p><p>他提供了自己的icon图标，这样我们在使用的时候就会很方便，不用每个图标都要去阿里矢量库去找。</p><h3 id="我觉得它的坏处"><a href="#我觉得它的坏处" class="headerlink" title="我觉得它的坏处"></a>我觉得它的坏处</h3><p>成也组件，败也组件，他的UI，权重特别高，导致我们将他的样式进行转换的时候就会很麻烦。</p><p>有时候组件会出bug，去年寒假我做一个Vue2+element-ui的项目时，他的<code>el-table</code>组件出了一个bug，在删减列后增加列，会导致index窜行或者窜位，导致有两排index同时出现的dom树中，后来向官方反应后，今年2月份的时候，我在看，bug已经消除了。</p><h3 id="使用一下element-ui"><a href="#使用一下element-ui" class="headerlink" title="使用一下element-ui"></a>使用一下element-ui</h3><p>在使用之前，我们要先去给项目添加element的依赖，有两种方式，可以去到我们的vue-ui面板，去插件与依赖中分别搜索element，去安装，也可以使用终端的npm工具进行下载依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i element-ui -S</span><br></pre></td></tr></table></figure><p>完后去element抄一段代码，随便写在页面中（我写在了app.vue中）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-row&gt;</span><br><span class="line">  &lt;el-button&gt;默认按钮&lt;/el-button&gt;</span><br><span class="line">  &lt;el-button type=&quot;primary&quot;&gt;主要按钮&lt;/el-button&gt;</span><br><span class="line">  &lt;el-button type=&quot;success&quot;&gt;成功按钮&lt;/el-button&gt;</span><br><span class="line">  &lt;el-button type=&quot;info&quot;&gt;信息按钮&lt;/el-button&gt;</span><br><span class="line">  &lt;el-button type=&quot;warning&quot;&gt;警告按钮&lt;/el-button&gt;</span><br><span class="line">  &lt;el-button type=&quot;danger&quot;&gt;危险按钮&lt;/el-button&gt;</span><br><span class="line">&lt;/el-row&gt;</span><br></pre></td></tr></table></figure><p>我直接复制过来了。</p><p>粘贴完，直接<code>npm run serve</code></p><p>是不是报错了？当然，因为我们还没有引入element到我们的项目中，我们只是安装了他的依赖而已。</p><p>在main.js中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import ElementUI from &#x27;element-ui&#x27;</span><br><span class="line">import &#x27;element-ui/lib/theme-chalk/index.css&#x27;</span><br><span class="line"></span><br><span class="line">Vue.use(ElementUI)</span><br></pre></td></tr></table></figure><p>上面两句是引入，下面的那句是使用。缺一不可。</p><p>假如在运行中遇到了这个错误，不要慌，这是你缺少了core.js的生产环境</p><p><img src="https://wangez.site/img/shangke/core-js.png" alt="core-js"></p><p>在终端运行这个之后，继续运行你的vue项目，就不会报错了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save core-js</span><br></pre></td></tr></table></figure><p>好啦，让我们看看element的样子吧！</p><p>我的app.js：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">      &lt;el-row&gt;</span><br><span class="line">        &lt;el-button&gt;默认按钮&lt;/el-button&gt;</span><br><span class="line">        &lt;el-button type=&quot;primary&quot;&gt;主要按钮&lt;/el-button&gt;</span><br><span class="line">        &lt;el-button type=&quot;success&quot;&gt;成功按钮&lt;/el-button&gt;</span><br><span class="line">        &lt;el-button type=&quot;info&quot;&gt;信息按钮&lt;/el-button&gt;</span><br><span class="line">        &lt;el-button type=&quot;warning&quot;&gt;警告按钮&lt;/el-button&gt;</span><br><span class="line">        &lt;el-button type=&quot;danger&quot;&gt;危险按钮&lt;/el-button&gt;</span><br><span class="line">      &lt;/el-row&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了方便看效果，我把其他的都删了。</p><p><img src="https://wangez.site/img/shangke/element.png" alt="element"></p><p>这样，我们的element就是引用成功的。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>组件库提高了前端人员的开发效率，这个是肯定的，但是这并不是说前端开发就不需要掌握CSS的知识了，组件不是万能的，在项目中，肯定要依据项目状态对组件有或多或少的修改，所以还是建议想学前端的同学要学好CSS，打好基础很重要（以后封装一个自己的组件库，还不是想怎么改就怎么改）。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Hexo使用Next主题的一些优化</title>
      <link href="/posts/1559886533.html/"/>
      <url>/posts/1559886533.html/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>肯定还会跟我一样，使用主题之后还不满意的小伙伴，不光想要好，还想要更好！</p><p>那就来看看如何优化你的博客，让他变得更富有细节吧 ~</p><h4 id="优化文章链接"><a href="#优化文章链接" class="headerlink" title="优化文章链接"></a>优化文章链接</h4><p>优化文章链接，为了避免链接中出现中文导致太长或者死链的情况出现，可以使用一个插件来避免这种情况</p><p>插件：<code>hexo-abbrlink</code></p><span id="more"></span><p>首先在博客根目录运行Git Bash，输入以下指令安装<code>hexo-abbrlink</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>打开站点配置文件<code>_config.yml</code>，修改permalink为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">permalink: posts/:abbrlink.html/</span><br></pre></td></tr></table></figure><p>记得将原有的permalink注释掉或者删掉</p><p>在站点配置文件<code>_config.yml</code>中添加以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#abbrlink配置</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32 #support crc16(default) and crc32</span><br><span class="line">  rep: dec   #support dec(default) and hex</span><br></pre></td></tr></table></figure><p>到这，关于优化文章链接的操作我们就做完啦！</p><h4 id="自定义文本内容"><a href="#自定义文本内容" class="headerlink" title="自定义文本内容"></a>自定义文本内容</h4><p>文件路径：<code>themes/next/languages/zh-CN.yml</code></p><p>需要打开这个文件进行修改。</p><p>选择哪个语言文档取决于你的站点配置文件上的语言写的是什么！</p><p>我将所有的<code>日志</code>换成了<code>文章</code>理由是我觉得日志怪怪的，还是文章比较正常。</p><p>Ctrl+H 进行批量替换。（不会真有人一个一个改吧，不会吧不会吧）</p><h4 id="添加访客统计、访问次数统计、文章阅读次数统计"><a href="#添加访客统计、访问次数统计、文章阅读次数统计" class="headerlink" title="添加访客统计、访问次数统计、文章阅读次数统计"></a>添加访客统计、访问次数统计、文章阅读次数统计</h4><p>打开主题配置文件</p><p>搜索找到<code>busuanzi_count</code>，把<code>enable</code>设置为<code>true</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Show Views / Visitors of the website / page with busuanzi.#展示访问数</span><br><span class="line"># Get more information on http://ibruce.info/2015/04/04/busuanzi</span><br><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true   #统计访客数</span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  total_views: true    #统计访问数</span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  post_views: true   #统计文章阅读数</span><br><span class="line">  post_views_icon: eye</span><br></pre></td></tr></table></figure><p>同样是在主题配置文件下，搜索<code>footer</code>，在它底下添加<code>counter</code>，设值为<code>true</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#统计</span><br><span class="line">counter: true</span><br></pre></td></tr></table></figure><p><strong>这个我一开始配置了，但是不生效，最后将它删了才生效的，如果你配置完有问题也可以将其删了试一试</strong></p><p>来到<code>themes\next\layout_partials</code>，找到<code>footer.swig</code>文件，打开编辑，在底下添加代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.footer.counter %&#125;</span><br><span class="line">    &lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>这样，就设置完成了，站点访客数、访问次数显示在网址底部，文章阅读次数在文章开头。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Hexo配置使用Next主题</title>
      <link href="/posts/2781919463.html/"/>
      <url>/posts/2781919463.html/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前写了个如何搭建Hexo的博客，后来想了想，既然写了就写到底吧，我自己用的是next这款主题，所以就说一下有关next的配置问题。并且，使用这个主题的过程中，我真的踩了不少的水坑！</p><h3 id="确认一下版本号"><a href="#确认一下版本号" class="headerlink" title="确认一下版本号"></a>确认一下版本号</h3><p><code>Hexo5.4.0</code></p><p><code>Next8.2.0</code></p><p>版本不同可能会有些差异</p><span id="more"></span><h3 id="安装next主题"><a href="#安装next主题" class="headerlink" title="安装next主题"></a>安装next主题</h3><p>去next团队的主页去下载一个zip压缩包</p><p><img src="https://wangez.site/img/next.png" alt="image-20210216103416503"></p><p>完后将他放在<code>themes</code>目录下并且解压，重命名文件夹为<code>next</code></p><p><code>themes/</code>下是Hexo用来放主题的</p><h3 id="修改站点配置文件"><a href="#修改站点配置文件" class="headerlink" title="修改站点配置文件"></a>修改站点配置文件</h3><p>站点配置文件：<code>_config.yml</code></p><p>参考Hexo文档中的说明，我们需要给博客设定主标题以及副标题、作者名称、语言、时区等，你可以参考以下我的设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: Wangez-Blog  #网站标题</span><br><span class="line">subtitle: &#x27;Ned的个人博客&#x27;  #网站副标题</span><br><span class="line">description: &#x27;Ned的个人博客&#x27;  #网站描述</span><br><span class="line">keywords:  #网站关键词</span><br><span class="line">author: Ned  #您的名字</span><br><span class="line">language: zh-CN  #语言</span><br><span class="line">timezone: &#x27;Asia/Shanghai&#x27;  #时区</span><br></pre></td></tr></table></figure><h4 id="启用Next主题"><a href="#启用Next主题" class="headerlink" title="启用Next主题"></a>启用Next主题</h4><p>在站点配置文件中，找到 theme 属性，然后修改为 next 即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure><h3 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h3><p>主题配置文件：<code>themes/next/_config.yml</code></p><h4 id="设定主题风格"><a href="#设定主题风格" class="headerlink" title="设定主题风格"></a>设定主题风格</h4><p>Next提供了4种风格样式供我们选择。我个人偏好最经典且极简的Muse风格。你可以4种都体验以下。选择哪个风格，就删除掉对应风格名所在行前面的# ，可以参考我的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Schemes</span><br><span class="line"># scheme: Muse</span><br><span class="line"># scheme: Mist</span><br><span class="line">scheme: Pisces</span><br><span class="line"># scheme: Gemini</span><br></pre></td></tr></table></figure><h4 id="博客主标题上方的logo"><a href="#博客主标题上方的logo" class="headerlink" title="博客主标题上方的logo"></a>博客主标题上方的logo</h4><p>这个我是没有设置的，有需要的可以自己设置一下，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Custom Logo (Warning: Do not support scheme Mist)主页logo</span><br><span class="line">custom_logo: /uploads/logo.png</span><br></pre></td></tr></table></figure><p>顺便一提，后面我们还会遇到 引用图片地址 的类似设置。<code>/uploads/logo.png </code>对应的本地blog文件夹中位置是 <code>\blog\themes\next\source\uploads\logo.png</code> 其中 <code>uploads</code> 文件夹，和<code>logo.png</code>文件，都需要自己创建。</p><h4 id="版权信息说明"><a href="#版权信息说明" class="headerlink" title="版权信息说明"></a>版权信息说明</h4><p>网上的太繁琐了，其实不用改太多。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Creative Commons 4.0 International License.</span><br><span class="line"># See: https://creativecommons.org/share-your-work/licensing-types-examples</span><br><span class="line"># Available values of license: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span><br><span class="line"># You can set a language value if you prefer a translated version of CC license, e.g. deed.zh</span><br><span class="line"># CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https://creativecommons.org</span><br><span class="line">creative_commons:</span><br><span class="line">  license: by-nc-sa</span><br><span class="line">  sidebar: true</span><br><span class="line">  post: true</span><br><span class="line">  language:</span><br></pre></td></tr></table></figure><p>版权声明文本是可以修改的，后面会介绍到。</p><h4 id="设置导航栏菜单"><a href="#设置导航栏菜单" class="headerlink" title="设置导航栏菜单"></a>设置导航栏菜单</h4><p>我觉得设置多了太麻烦，于是就保留了<code>主页</code> <code>标签</code> <code>关于</code> <code>归档</code>四个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  about: /about/ || fa fa-user</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  #categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br><span class="line">  #schedule: /schedule/ || fa fa-calendar</span><br><span class="line">  #sitemap: /sitemap.xml || fa fa-sitemap</span><br><span class="line">  #commonweal: /404/ || fa fa-heartbeat</span><br><span class="line"></span><br><span class="line"># Enable / Disable menu icons / item badges.</span><br><span class="line">menu_settings:</span><br><span class="line">  icons: true</span><br><span class="line">  badges: false</span><br></pre></td></tr></table></figure><p>启用哪个功能，就删除对应行前面的 # </p><h4 id="侧边栏设置"><a href="#侧边栏设置" class="headerlink" title="侧边栏设置"></a>侧边栏设置</h4><p>我觉得左边挺好的，就没有改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sidebar:</span><br><span class="line">  # Sidebar Position.</span><br><span class="line">  position: left</span><br><span class="line">  # position: right</span><br></pre></td></tr></table></figure><p>设置侧边栏的头像，一般为作者的头像，和博客的logo有区别。</p><p>可以是方形或圆形，还可以选择鼠标停留时，魔性的转动（我没设置）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line">avatar:</span><br><span class="line">  # Replace the default image and set the url here.</span><br><span class="line">  url: /uploads/avatar.jpg #头像图片地址 </span><br><span class="line">  # If true, the avatar will be dispalyed in circle.圆形选true 方形选false</span><br><span class="line">  rounded: true</span><br><span class="line">  # If true, the avatar will be rotated with the cursor.魔性转动，打开选true</span><br><span class="line">  rotated: false</span><br></pre></td></tr></table></figure><p>侧边栏外链，可以指向某篇文章，或某个网址。这里可以用来展示其他发布渠道。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  #GitHub: https://github.com/yourname || fab fa-github</span><br><span class="line">  #E-Mail: mailto:yourname@gmail.com || fa fa-envelope</span><br><span class="line">  #Weibo: https://weibo.com/yourname || fab fa-weibo</span><br><span class="line">  #Google: https://plus.google.com/yourname || fab fa-google</span><br><span class="line">  #Twitter: https://twitter.com/yourname || fab fa-twitter</span><br><span class="line">  #FB Page: https://www.facebook.com/yourname || fab fa-facebook</span><br><span class="line">  #StackOverflow: https://stackoverflow.com/yourname || fab fa-stack-overflow</span><br><span class="line">  #YouTube: https://youtube.com/yourname || fab fa-youtube</span><br><span class="line">  #Instagram: https://instagram.com/yourname || fab fa-instagram</span><br><span class="line">  #Skype: skype:yourname?call|chat || fab fa-skype</span><br><span class="line"></span><br><span class="line">social_icons:</span><br><span class="line">  enable: true  #用来控制是否显示图标的</span><br><span class="line">  icons_only: false</span><br><span class="line">  transition: false</span><br></pre></td></tr></table></figure><p>和外链样式不同的是友链。默认显示为<code>友情链接</code>我将其修改为<code>我的朋友</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Blog rolls</span><br><span class="line">links_settings:</span><br><span class="line">  icon: fa fa-link</span><br><span class="line">  title: 我的朋友</span><br><span class="line">  # Available values: block | inline</span><br><span class="line">  layout: block</span><br><span class="line">#友情链接</span><br><span class="line">links:</span><br><span class="line">  Ned: https://wangez.site</span><br></pre></td></tr></table></figure><h4 id="返回顶部按钮显示阅读进度"><a href="#返回顶部按钮显示阅读进度" class="headerlink" title="返回顶部按钮显示阅读进度"></a>返回顶部按钮显示阅读进度</h4><p>觉得没什么用，不过我还是用了（打脸ing）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  # Back to top in sidebar.</span><br><span class="line">  sidebar: false</span><br><span class="line">  # Scroll percent label in b2t button.</span><br><span class="line">  scrollpercent: true</span><br></pre></td></tr></table></figure><h4 id="关闭动画效果"><a href="#关闭动画效果" class="headerlink" title="关闭动画效果"></a>关闭动画效果</h4><p>我觉得博客，渲染的太华丽反而不好，于是就将其关了，如果想打开可以将enable的值设置为<code>true</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">motion:</span><br><span class="line">  enable: false</span><br><span class="line">  async: false</span><br></pre></td></tr></table></figure><p>到此，配置差不多就结束了，如果你还想优化你的博客，可以继续看下去。</p><h3 id="优化你的博客"><a href="#优化你的博客" class="headerlink" title="优化你的博客"></a>优化你的博客</h3><h4 id="优化文章链接"><a href="#优化文章链接" class="headerlink" title="优化文章链接"></a>优化文章链接</h4><p>优化文章链接，为了避免链接中出现中文导致太长或者死链的情况出现，可以使用一个插件来避免这种情况</p><p>插件：<code>hexo-abbrlink</code></p><p>首先在博客根目录运行Git Bash，输入以下指令安装<code>hexo-abbrlink</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>打开站点配置文件<code>_config.yml</code>，修改permalink为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">permalink: posts/:abbrlink.html/</span><br></pre></td></tr></table></figure><p>记得将原有的permalink注释掉或者删掉</p><p>在站点配置文件<code>_config.yml</code>中添加以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#abbrlink配置</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32 #support crc16(default) and crc32</span><br><span class="line">  rep: dec   #support dec(default) and hex</span><br></pre></td></tr></table></figure><p>到这，关于优化文章链接的操作我们就做完啦！</p><h4 id="自定义文本内容"><a href="#自定义文本内容" class="headerlink" title="自定义文本内容"></a>自定义文本内容</h4><p>文件路径：<code>themes/next/languages/zh-CN.yml</code></p><p>需要打开这个文件进行修改。</p><p>选择哪个语言文档取决于你的站点配置文件上的语言写的是什么！</p><p>我将所有的<code>日志</code>换成了<code>文章</code>理由是我觉得日志怪怪的，还是文章比较正常。</p><p>Ctrl+H 进行批量替换。（不会真有人一个一个改吧，不会吧不会吧）</p><h4 id="添加访客统计、访问次数统计、文章阅读次数统计"><a href="#添加访客统计、访问次数统计、文章阅读次数统计" class="headerlink" title="添加访客统计、访问次数统计、文章阅读次数统计"></a>添加访客统计、访问次数统计、文章阅读次数统计</h4><p>打开主题配置文件</p><p>搜索找到<code>busuanzi_count</code>，把<code>enable</code>设置为<code>true</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Show Views / Visitors of the website / page with busuanzi.#展示访问数</span><br><span class="line"># Get more information on http://ibruce.info/2015/04/04/busuanzi</span><br><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true   #统计访客数</span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  total_views: true    #统计访问数</span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  post_views: true   #统计文章阅读数</span><br><span class="line">  post_views_icon: eye</span><br></pre></td></tr></table></figure><p>同样是在主题配置文件下，搜索<code>footer</code>，在它底下添加<code>counter</code>，设值为<code>true</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#统计</span><br><span class="line">counter: true</span><br></pre></td></tr></table></figure><p><strong>这个我一开始配置了，但是不生效，最后将它删了才生效的，如果你配置完有问题也可以将其删了试一试</strong></p><p>来到<code>themes\next\layout_partials</code>，找到<code>footer.swig</code>文件，打开编辑，在底下添加代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.footer.counter %&#125;</span><br><span class="line">    &lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>这样，就设置完成了，站点访客数、访问次数显示在网址底部，文章阅读次数在文章开头。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo搭建自己的博客</title>
      <link href="/posts/735412972.html/"/>
      <url>/posts/735412972.html/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前一直在用typecho来做自己的博客，因为他操作比较简单，但是前几日修改一些配置的时候，看着满屏的php代码实在有些头疼，在朋友的推荐下，我成功的入坑了hexo，下面分享一些自己搭建博客的过程，尽量让读者避开一些坑。</p><h3 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h3><p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入<a href="https://hexo.io/zh-cn/">hexo官网</a>进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。</p><span id="more"></span><h3 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h3><p>在安装hexo前，电脑上具备有git与node两个环境才行</p><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><p>Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。Git非常强大，我觉得建议每个人都去了解一下。廖雪峰老师的Git教程写的非常好，大家可以了解一下。<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">Git教程</a></p><p>windows：到git官网上下载,<a href="https://gitforwindows.org/">Download git</a>,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。</p><p>linux：对linux来说实在是太简单了，因为最早的git就是在linux上编写的，只需要一行代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><h4 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h4><p>Hexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。</p><p>windows：<a href="https://nodejs.org/en/download/">nodejs</a>  </p><p>linux:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure><p>安装完后，打开命令行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>检查一下有没有安装成功</p><p>顺便说一下，windows在git安装完后，就可以直接使用git bash来敲命令行了。</p><h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><p>现在我们就可以安装hexo了</p><p>前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹blog，然后<code>cd</code>到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。</p><p>输入命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>依旧用<code>hexo -v</code>查看一下版本</p><p>至此就全部安装完了。</p><p>接下来初始化一个blog吧！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init myblog(myblog是你创建的文件夹的名字，可以随意命名)</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd myblog //进入这个myblog文件夹</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹目录下有：</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>_config.yml: 博客的配置文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>打开hexo的服务，在浏览器输入<code>localhost:4000</code>就可以看到你生成的博客了。</p><p>使用ctrl+c可以把服务关掉。</p><p>注：可以使用 <code>hexo command</code> 来查看hexo全部命令</p><h3 id="准备好GitHub"><a href="#准备好GitHub" class="headerlink" title="准备好GitHub"></a>准备好GitHub</h3><p>首先，你先要有一个GitHub账户，去注册一个吧。</p><p>注册完登录后，在GitHub.com中看到一个New repository，新建仓库</p><p>创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，xxx.github.io，其中xxx就是你注册GitHub的用户名。</p><p>点击create repository。</p><p>回到你的git bash中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure><p>这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。</p><p>可以用以下两条，检查一下你有没有输对:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><h3 id="将hexo部署到GitHub"><a href="#将hexo部署到GitHub" class="headerlink" title="将hexo部署到GitHub"></a>将hexo部署到GitHub</h3><p>这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 <code>_config.yml</code>，翻到最后，修改为<br>YourgithubName就是你的GitHub账户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/YourgithubName/YourgithubName.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>其中 <code>hexo clean</code>清除了你之前生成的东西，也可以不加。<br><code>hexo generate</code> 顾名思义，生成静态文章，可以用 <code>hexo g</code>缩写<br><code>hexo deploy</code> 部署文章，可以用<code>hexo d</code>缩写</p><p>注意deploy时可能要你输入username和password。</p><p>过一会儿就可以在<code>http://yourname.github.io</code> 这个网站看到你的博客了！</p><h3 id="关联个人域名"><a href="#关联个人域名" class="headerlink" title="关联个人域名"></a>关联个人域名</h3><p>如果你想自己的域名与博客也关联起来的话，可以看这里</p><p>在source里创建一个叫CNAME的文件（注意没有任何后缀，名字就叫CNAME）</p><p>在CNAME里面写上你的域名，例如：</p><blockquote><p>blog.wangez.site</p></blockquote><p>之后打开git bash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>在GitHub上你创建的仓库里就会多一个叫做CNAME的文件了</p><p>过不了多久，再打开你的浏览器，输入你自己的域名，就可以看到搭建的网站啦！</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑日记 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序相关</title>
      <link href="/posts/2713850416.html/"/>
      <url>/posts/2713850416.html/</url>
      
        <content type="html"><![CDATA[<h2 id="1-数据绑定"><a href="#1-数据绑定" class="headerlink" title="1. 数据绑定"></a>1. 数据绑定</h2><h4 id="1-小程序"><a href="#1-小程序" class="headerlink" title="1.小程序"></a>1.小程序</h4><p>1.data中初始化数据<br>2.修改数据： this.setData()</p><ul><li>1.修改数据的行为始终是同步的</li></ul><p>3.数据流：</p><ul><li>1.单项： Model —&gt; View</li></ul><span id="more"></span><h4 id="2-Vue"><a href="#2-Vue" class="headerlink" title="2. Vue"></a>2. Vue</h4><p>1.data中初始化数据<br>2.修改数据: this.key = value<br>3.数据流：</p><ul><li>1.Vue是单项数据流： Model —&gt; View</li><li>2.Vue中实现了双向数据绑定： v-model</li></ul><h4 id="3-React"><a href="#3-React" class="headerlink" title="3. React"></a>3. React</h4><p>1.state中初始化状态数据<br>2.修改数据: this.setState()</p><ul><li>1.自身钩子函数中(componentDidMount)异步的</li><li>2.非自身的钩子函数中(定时器的回调)同步的</li></ul><p>3.数据流：</p><ul><li>1.单项： Model —&gt; View</li></ul><h2 id="2-获取用户基本信息"><a href="#2-获取用户基本信息" class="headerlink" title="2. 获取用户基本信息"></a>2. 获取用户基本信息</h2><p>1.用户未授权(首次登陆)</p><ul><li>1.button open-type=‘getUserInfo’</li></ul><p>2.用户已经授权(再次登陆)</p><ul><li>1.wx.getUserInfo</li></ul><h2 id="3-前后端交互"><a href="#3-前后端交互" class="headerlink" title="3. 前后端交互"></a>3. 前后端交互</h2><p>1.语法: wx.request()<br>2.注意点:</p><ul><li>1.协议必须是https协议</li><li>2.一个接口最多配置20个域名</li><li>3.并发限制上限是10个</li><li><ol><li><strong>开发过程中设置不校验合法域名</strong>： 开发工具 —&gt; 右上角详情 —-&gt; 本地设置 —&gt; 不校验</li></ol></li></ul><h2 id="4-本地存储"><a href="#4-本地存储" class="headerlink" title="4. 本地存储"></a>4. 本地存储</h2><p>1.语法: wx.setStorage() || wx.setStorageSync() || …..<br>2.注意点：</p><ul><li>1.建议存储的数据为json数据</li><li>2.单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB</li><li>3.属于永久存储，同H5的localStorage一样</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Axios踩坑日记</title>
      <link href="/posts/2698809561.html/"/>
      <url>/posts/2698809561.html/</url>
      
        <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>自己写项目的时候，axios向后端发送post请求时，后端无法接收到数据，同样的请求在我使用postman测的时候是正常的，不信邪的我又用原生的form表单提交试了一试，也是正常的，想了想，也查了查百度，觉得可能是form表单与axios请求，有哪里不一样。</p><h4 id="去找了axios的介绍"><a href="#去找了axios的介绍" class="headerlink" title="去找了axios的介绍"></a>去找了axios的介绍</h4><p><img src="https://img-blog.csdnimg.cn/20190907170037504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3plbXByb2dyYW0=,size_16,color_FFFFFF,t_70" alt="axios"></p><p>由图片可以看出，它大概是对请求和响应的数据进行了一个转换，而且会对json进行自动转换，我去github上找了一下源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">transformRequest: [<span class="function"><span class="keyword">function</span> <span class="title">transformRequest</span>(<span class="params">data, headers</span>) </span>&#123;</span><br><span class="line">        normalizeHeaderName(headers, <span class="string">&#x27;Accept&#x27;</span>);</span><br><span class="line">        normalizeHeaderName(headers, <span class="string">&#x27;Content-Type&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (utils.isFormData(data) ||</span><br><span class="line">          utils.isArrayBuffer(data) ||</span><br><span class="line">          utils.isBuffer(data) ||</span><br><span class="line">          utils.isStream(data) ||</span><br><span class="line">          utils.isFile(data) ||</span><br><span class="line">          utils.isBlob(data)</span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (utils.isArrayBufferView(data)) &#123;</span><br><span class="line">          <span class="keyword">return</span> data.buffer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (utils.isURLSearchParams(data)) &#123;</span><br><span class="line">          setContentTypeIfUnset(headers, <span class="string">&#x27;application/x-www-form-urlencoded;charset=utf-8&#x27;</span>);</span><br><span class="line">          <span class="keyword">return</span> data.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 看这里------------------------------------------</span></span><br><span class="line">        <span class="keyword">if</span> (utils.isObject(data)) &#123;</span><br><span class="line">          setContentTypeIfUnset(headers, <span class="string">&#x27;application/json;charset=utf-8&#x27;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">      &#125;]</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>当判断为对象时，会把headers设置为application/json;charset=utf-8，也就是Content-Type，而根据后端同学所说的，服务端要求的是Content-Type’: ‘application/x-www-form-urlencoded，我试着在发送请求前将headers设置为application/x-www-form-urlencoded，结果还是不行，大概是因为源码中对headers的修改在自己的设置之后实现的，但是这样写的话，要写出一串很长的字符串，感觉挺麻烦的，那就可以尝试下面的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.headers.post[<span class="string">&#x27;Content-Type&#x27;</span>] = <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span></span><br><span class="line"> axios.interceptors.request.use(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (config.method === <span class="string">&#x27;post&#x27;</span>) &#123;</span><br><span class="line">    config.data = qs.stringify(config.data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样会在你post请求的时候，加上这个头，并调用了qs库，将你请求的数据转换为字符串，但是可能有问题，这段代码是要加在main.js中的，那么我项目中想使用其他的请求头，或者转换为字符串会导致我其他的请求会有bug，应该如何去解决呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> isFormData = config.data <span class="keyword">instanceof</span> FormData</span><br><span class="line">  <span class="keyword">if</span> (isFormData) &#123;</span><br><span class="line">    config.headers[<span class="string">&#x27;content-type&#x27;</span>] = <span class="string">&#x27;multipart/form-data&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config.method === <span class="string">&#x27;post&#x27;</span>) &#123;</span><br><span class="line">    config.data = qs.stringify(config.data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这是我在项目中，有一处请求对象需要是formData对象的时候，伙伴对上边代码做出的修改，避免了所有的请求都会被强制转换成字符串的问题。</p><h3 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h3><p>我百度查阅了一下，csdn上有一博主是这样做的，他在请求的时候修改了axios源码中的transformRequest方法，把对data的处理变成了自己想要的样子，我觉得这样也很好，但是我当初没想到emm<br>附上该博主的链接：<a href="https://blog.csdn.net/zemprogram/article/details/100599613">https://blog.csdn.net/zemprogram/article/details/100599613</a><br>附上本小白项目的链接，入门菜鸟，请多指教：<a href="https://gitee.com/wang-enze/rank">https://gitee.com/wang-enze/rank</a></p>]]></content>
      
      
      <categories>
          
          <category> 踩坑日记 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Axios </tag>
            
            <tag> 踩坑日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript变量提升</title>
      <link href="/posts/388126410.html/"/>
      <url>/posts/388126410.html/</url>
      
        <content type="html"><![CDATA[<h2 id="js变量提升"><a href="#js变量提升" class="headerlink" title="js变量提升"></a>js变量提升</h2><p>JavaScript是单线程语言，所以执行肯定是按顺序执行。但是并不是逐行的分析和执行，而是一段一段地分析执行，会先进行编译阶段然后才是执行阶段。在编译阶段阶段，代码真正执行前的几毫秒，会检测到所有的变量和函数声明，所有这些函数和变量声明都被添加到名为Lexical Environment的JavaScript数据结构内的内存中。所以这些变量和函数能在它们真正被声明之前使用。</p><p>先从一个简单的例子来入手：</p><blockquote><p>a = 2;<br>var a;<br>console.log(a);</p></blockquote><span id="more"></span><p>以上的代码会输出什么，假如这段代码是从上到下执行的话，肯定会输出undefined，然而JavaScript却不是自上而下执行的语言。<br>这段代码的输出结果是2，意外吗？那么，为什么会这样，这个关键点就在于–<strong>变量提升</strong>。他会将当前作用域的所有变量的声明，提升到程序的顶部，因此，上面的代码等价于以下代码，这样是不是就能明白一些了？</p><blockquote><p>var a;<br>a = 2;<br>console.log(a);</p></blockquote><p>那么我们再看一个例子：</p><blockquote><p>console.log(a);<br>var a = 2;</p></blockquote><p>这段代码又会输出什么？输出2吗？<br>其实这段代码会输出undefined。这又是为什么呢？刚刚说过，JavaScript会将变量的声明提升到顶部，但是赋值语句是不会提升的，对于js来说，var a = 2是分为<strong>两步解析</strong>的：<br>1.var a;<br>2.a = 2;<br>而js只会提升 var a 这句，所以刚刚的语句等价于：</p><blockquote><p>var a;<br>console.log(a);<br>a = 2;</p></blockquote><h3 id="那么，为什么会有变量提升？"><a href="#那么，为什么会有变量提升？" class="headerlink" title="那么，为什么会有变量提升？"></a>那么，为什么会有变量提升？</h3><p>为什么会出现变量提升这个现象呢？<br>因为js与其他语言一样，都要经历编译跟执行阶段。而js在编译阶段的时候，会搜集所有的变量声明并且提前声明变量，而其他的语句都不会改变他们的顺序，因此，在编译阶段的时候，第一步就已经执行了，而第二部则是在执行阶段执行到该语句的时候才执行。</p><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>js的变量声明应该大体上可以分三种：var声明、let与const声明和函数声明。<br>函数声明与其他声明一起出现的时候，就可能会引起一些冲突。我们接着往下看：</p><blockquote><p>fn();<br>function fn () {<br>console.log(‘fn’);<br>}<br>var fn = 2;</p></blockquote><p>你觉得会输出什么？这么写会报错吗？<br>其实输出的结果是fn。这就解释了我们刚刚的问题，当函数声明与其他声明一起出现的时候，是以谁为准呢？答案就是，<strong>函数声明高于一切，毕竟函数是js的贵族阶级</strong>。</p><p>那么多个函数声明怎么办呢？</p><blockquote><p>fn();<br>function fn () {<br>console.log(‘1’);<br>}<br>function fn () {<br>console.log(‘2’);<br>}</p></blockquote><p>以上代码输出结果为2。这是因为<strong>有多个函数声明的时候，是由最后的函数声明来替代前面的</strong>。</p><p>还有最后一个例子了：</p><blockquote><p>fn();<br>var fn = function () {<br>console.log(‘fn’);<br>}</p></blockquote><p>经过了上面的理解，再看这个是不是就很简单了呀？这个跟第二个例子是一样的，var fn = function() {}这种格式我们叫做函数表达式。<br>它其实也分为两部分：<br>1.var fn;<br>2.fn = function() {};<br>参考例2，我们可以知道，这个的结果应该是报错了(因为fn声明但未赋值，因此fn是undefined)。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>那么，来总结一下吧。<br>1.js会将变量的声明提升到js顶部执行，对于var a = 2这种语句，会拆分开，将var a这步进行提升。<br>2.变量提升的本质其实是js引擎在编译的时候，就将所有的变量声明了，因此在执行的时候，所有的变量都已经完成声明。<br>3.当有多个同名变量的时候，函数声明会覆盖其他的声明。如果有多个函数声明，则由最后一个函数声明覆盖之前的所有声明。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>弹性盒模型-flex</title>
      <link href="/posts/3659327966.html/"/>
      <url>/posts/3659327966.html/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最开始接触flex布局的时候，还是在阮一峰老师的博客上学习的，最近在看一本书，上面有提及到，于是就来整理一下所学，有理解的不对的地方还请指正。</p><h3 id="弹性盒模型"><a href="#弹性盒模型" class="headerlink" title="弹性盒模型"></a>弹性盒模型</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>弹性盒模型和盒模型的概念有一些区别，他不在是定义元素的，而是CSS3引入的一种布局方式，其核心思想是调整元素大小来适应不同空间，包含垂直方向的高度和水平方向的宽度。</p><span id="more"></span><p>弹性盒模型有两个重要的概念：容器（container）和项目（item）。其中容器属性用来设置项目的公共样式，比如排布方向、排布对齐方式；项目属性用来设置各个项目之间的相对关系，包括比例、顺序等。容器和项目是嵌套关系，一个容器可以有多个项目，其中容器的display的属性值应设为flex。</p><p>标准盒模型的排布包括水平和垂直方向，弹性盒模型也是如此。我们可以将水平方向理解为主轴，垂直方向理解为交叉轴，与传统盒模型有所不同的是，弹性和模型在排列方向上除了从左到右和从上到下，还支持反序排列，即从右到左和从下到上。</p><p>容器的属性有6个，我们下面一一介绍他们：</p><h5 id="1-justify-content"><a href="#1-justify-content" class="headerlink" title="1.justify-content"></a>1.justify-content</h5><p>定义主轴上项目的对齐方式。</p><ul><li>flex-start:默认值。项目靠近主轴首端的方向排列。</li><li>flex-end:项目靠近主轴末端首端的方向排列。</li><li>center:项目靠近主轴的中间位置排列。</li><li>space-between:两端对齐。第一个项目会紧贴主轴首端，最后一个项目会紧贴主轴末端，其余项目等间距排列。</li><li>space-around:每个项目外边距相等，项目之间的间距是项目与边框间距的两倍。</li><li>space-evenly:可以使得相邻项目、项目与边框之间的间距相等。</li></ul><h5 id="2-align-items"><a href="#2-align-items" class="headerlink" title="2.align-items"></a>2.align-items</h5><p>定义多个项目单行排列下的交叉轴对齐方式。</p><ul><li>flex-start:项目靠近交叉轴首端的方向。</li><li>flex-end:项目靠近交叉轴末端的方向。</li><li>center:项目与交叉轴中线对齐。</li><li>baseline:项目与第一行文字基线对齐。</li><li>stretch:将项目拉伸至与交叉轴两端对齐。</li></ul><h5 id="3-align-content"><a href="#3-align-content" class="headerlink" title="3.align-content"></a>3.align-content</h5><p>定义多个项目多行情况下在交叉轴的对齐方式，和主轴一样，也支持六中队旗方式，只是个别的名称有所变化。</p><ul><li>flex-start:项目靠近交叉轴首端的方向排列。</li><li>flex-end:项目靠近交叉轴末端的方向排列。</li><li>center:项目靠近交叉轴的中间位置排列。</li><li>space-between:两端对齐。第一个项目会紧贴交叉轴首端，最后一个项目会紧贴交叉轴末端，其余项目等间距排列。</li><li>space-around:每个项目外边距相等，项目之间的间距是项目与边框间距的两倍。</li><li>stretch:可以使得相邻箱门、项目与边框之间的间距相等。</li></ul><h5 id="4-flex-direction"><a href="#4-flex-direction" class="headerlink" title="4.flex-direction"></a>4.flex-direction</h5><p>定义容器主轴上项目的排列方向。</p><ul><li>row:默认值，水平方向从左往右排列。</li><li>row-reverse:水平方向从右往左排列。</li><li>column:垂直方向从上往下排列。</li><li>column-reverse:垂直方向从下往上排列。</li></ul><h5 id="5-flex-wrap"><a href="#5-flex-wrap" class="headerlink" title="5.flex-wrap"></a>5.flex-wrap</h5><p>用来控制项目在主轴上是否换行。</p><ul><li>nowrap:默认值，项目超出容器尺寸时不换行。这个尺寸根据排列方向而定，对于水平排列方式为宽度，垂直排列方式为高度。</li><li>wrap:项目超出容器尺寸时换行。</li><li>wrap-reverse:项目超出容器尺寸时换行，不过是反序排列。例如水平方向布局的话先从下面一行开始往上换行。</li></ul><h5 id="6-flex-flow"><a href="#6-flex-flow" class="headerlink" title="6.flex-flow"></a>6.flex-flow</h5><p>这个属性是一个简写属性，其第一个属性值用来设置flex-direction的值，第二个属性值用来设置flex-wrap的值，两个值用空格做分隔符。默认值为“row nowrap”。<br>如果需要对不同项目进行定制化设置，那么还需要用到项目属性。项目属性可分为三类，一类和项目顺序有关(order)，另一类和项目对齐方式有关(align-self)，最后一类和项目的尺寸相关（flex-grow,flex-shrink-flex-basis,flex）,具体介绍如下。</p><h5 id="7-order"><a href="#7-order" class="headerlink" title="7.order"></a>7.order</h5><p>它的值是一个整数，按照数值从大到小的顺序排列项目。默认值为零，即按照元素编写顺序排列。</p><h5 id="8-align-self"><a href="#8-align-self" class="headerlink" title="8.align-self"></a>8.align-self</h5><p>可以覆盖容器定义的align-items属性，为当前项目单独设置交叉轴的对齐方式，可选值同align-items。</p><h5 id="9-flex-grow"><a href="#9-flex-grow" class="headerlink" title="9.flex-grow"></a>9.flex-grow</h5><p>定义项目在容器拥有剩余空间时的放大比例。默认值为零，如果各个项目的值都相等，那么均分剩余空间，否则按照flex-grow定义的比例分配剩余空间。</p><h5 id="10-flex-shrink"><a href="#10-flex-shrink" class="headerlink" title="10.flex-shrink"></a>10.flex-shrink</h5><p>定义项目在容器空间不足时的缩小比例。默认值为1，如果各个项目的值都相等，那么均匀缩小各个空间，否则按照flex-shrink定义的比例进行缩小。</p><h5 id="11-flex-basis"><a href="#11-flex-basis" class="headerlink" title="11.flex-basis"></a>11.flex-basis</h5><p>定义项目的默认尺寸，可选值同width属性，默认值为auto。</p><h4 id="基础布局"><a href="#基础布局" class="headerlink" title="基础布局"></a>基础布局</h4><h5 id="1-单列布局"><a href="#1-单列布局" class="headerlink" title="1.单列布局"></a>1.单列布局</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- html --&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;item&quot;&gt;main&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">/*css*/</span><br><span class="line">.container &#123;</span><br><span class="line">  display:flex;</span><br><span class="line">  background-color:lightgrey;</span><br><span class="line">  justfy-content:center;</span><br><span class="line">&#125;</span><br><span class="line">.item &#123;</span><br><span class="line">  flex-basis:1000px;</span><br><span class="line">  background-color:yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路很简单，设置容器主轴项目对齐方式居中，同时设置好项目宽度即可。</p><h5 id="2-两列布局"><a href="#2-两列布局" class="headerlink" title="2.两列布局"></a>2.两列布局</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- html --&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;center&quot;&gt;center&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">/*css*/</span><br><span class="line">.container &#123;</span><br><span class="line">  display:flex;</span><br><span class="line">&#125;</span><br><span class="line">.center &#123;</span><br><span class="line">  flex-grow:1;</span><br><span class="line">  background-color:yellow;</span><br><span class="line">  order:1;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">  background-color:red;</span><br><span class="line">  flex-basis:200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两列布局的要点就是设置两个项目的宽度，其中左侧项目通过flex-basis属性设置为固定宽度，另一个项目将flex-grow设置为1，让其根据剩余空间自动撑满。为了让右侧元素先加载，可以使用order属性调整其位置。</p><h5 id="3-三列布局"><a href="#3-三列布局" class="headerlink" title="3.三列布局"></a>3.三列布局</h5><p>三列布局的处理思路和两列布局是一致的，这里就不多做阐述，都是利用项目之间的比例关系来实现。</p>]]></content>
      
      
      <categories>
          
          <category> Css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css </tag>
            
            <tag> Flex </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
