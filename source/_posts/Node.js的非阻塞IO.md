---
title: Node.js的非阻塞I/O
author: Ned
tags: Node.js
abbrlink: 212671180
---

> 写在最前
>
> 老早就想学Node.js了，觉得前端一定要是懂服务端知识，并且可以自己独立完成一个小型全栈项目的，但是碍于时间因素，上学期学了点基础之后，就再也没空学，正好今天科二过了，Node.js我又来卷你了！！！

- I/O就是input/output，一个系统的输入输出
- 阻塞I/O和非阻塞I/O的区别就在于**系统的接收输入，在到输出期间，能不能接收其他输入**

<!-- more -->

## 举个栗子🌰

- 去食堂吃饭：我们都要排队打饭

  我们的流程是：<font color="blue">排队------>等前面的人打饭-------->轮到我们自己打饭------->开始吃饭</font>

- 出去吃饭：餐厅点菜

  现在我们的流程是：<font color="red">坐下------->点菜------->等待-------->开始吃饭</font>

  > 尝试开始在markdown中使用一些奇奇怪怪的东西

- <font color="red" size="5">排队打饭 vs 餐厅点菜</font>

- <font>对于点菜人员的我们来说：</font>
  - 排队打饭是阻塞I/O
  - 餐厅点菜是非阻塞I/O

继续来看最上面那句话：

> 系统的接收输入，在到输出期间，能不能接收其他输入

在栗子中，系统=食堂打饭的阿姨或者是餐厅服务生，输入=点菜，输出=端菜（上菜）

食堂阿姨只能一份一份的打饭---------> <font color="red">阻塞I/O</font>

服务生点完菜之后还可以服务其他客人-------><font color="red">非阻塞I/O</font>

### 其实，这个问题小学老师就教过我们

> 小芳帮妈妈做家务，需要做：用洗衣机洗衣服（20分钟）、扫地（10分钟）、整理书桌（10分钟）、晾衣服（5分钟）。你能不能设计一个巧妙合理的新顺序，使小芳最少花（      ）分钟可以完成这些事？
>
> A.20
>
> B.25
>
> C.30
>
> D.35

没想到吧？（其实我也没想到~）

在这个过程中，我们用洗衣机洗衣服=输入，晾衣服=输出，在洗衣机洗衣服的过程中，我们是可以去做其他事情的，所以这个属于**非阻塞I/O**哟。

## 思考

理解非阻塞I/O，首先要确定的是什么？

- 我们要确定有一个输入/输出（input/output）的系统。
- 思考在I/O过程中，能不能进行其他I/O。
  - 能------>非阻塞
  - 不能------->阻塞

### 写个栗子🌰

先新建一个`index.js`，再打开我们前端人的vs-code，打开终端，执行`npm install glob`安装一个glob包，来帮我们更加方便去观察I/O是否阻塞。

<font size="4" color="red">先来看阻塞I/O</font>

代码先贴上：`index.js`

```javascript
const glob = require('glob');

var result = null;
console.time('glob')
result = glob.sync(__dirname + '/**/*')
console.timeEnd('glob')
console.log(result)

```

首先，先用require引入我们的glob包，接下来，用glob.sync去做一个打印目录的一个操作，将结果打印的同时，利用time/timeEnd，去记录时间，看node执行这个操作共花费多少时间。

在终端输入`node index.js`直接运行这个文件

![](https://wangez.site/img/img/E4C`~CXRE0ZX7OKAYH36QMX.png)

看第一行，在我的电脑上执行共花费20.93毫秒啊，这个数量在一个服务端来说，已经不小了。

<font size="4" color="red">再看非阻塞I/O</font>

直接上代码：

```javascript
const glob = require('glob');
var result = null;
console.time('glon')
glob(__dirname + '/**/*',function(err,res){
    result = res;
    // console.log(result)
    console.log('got result');
})
console.timeEnd('glob')
console.log('今天你卷了没？')
```

这次采用一个回调函数的方式来进行操作，因为result的打印出来实在太多行了，我们将其替换为打印出'got result'，并在计时完成后进行一个打印语句的操作，让我们来看看结果：

![1628690658](https://wangez.site/img/img/1628690658.jpg)

首先还是我们的时间：3.258ms，跟之前的20.93比起来，简直少了不要太多好嘛，完后是我们输出的语句，最后才打印了我们想要的操作结果，也就是说，它在输入输出之间进行了别的操作，对结果无影响，且用时少了好多！

## 结论

我的理解🐱‍🐉：非阻塞I/O让我们减少了许多等待的时间，并且在等待时间内，我们还可以进行一些其他的操作

> 凡事没有绝对，不是说非阻塞I/O就一定是好的，还是拿餐厅举例子，比如服务员中间发生意外，所有的客人都要等这一个服务员，这样就会影响餐厅整体质量（可以理解为服务器奔溃）；阻塞I/O由于有多个服务员，一对一的服务，即使有一个发生意外，也不会影响整体质量，而雇多个服务员也要相应的付出成本。

