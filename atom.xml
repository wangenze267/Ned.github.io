<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wangez-Blog</title>
  
  
  <link href="https://wangenze267.github.io/atom.xml" rel="self"/>
  
  <link href="https://wangenze267.github.io/"/>
  <updated>2021-11-25T10:52:48.481Z</updated>
  <id>https://wangenze267.github.io/</id>
  
  <author>
    <name>Ned</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>整活系列(一)——做个PC端打字小游戏</title>
    <link href="https://wangenze267.github.io/posts/2621331394.html/"/>
    <id>https://wangenze267.github.io/posts/2621331394.html/</id>
    <published>2021-11-25T10:52:22.865Z</published>
    <updated>2021-11-25T10:52:48.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>代码不光是我们用来工作的，也应该是我们用来娱乐的，今天就带着小伙伴们整个活！</p><p>看完这篇文章，你会学会如何整活~</p><p>小时候我记得有个软件叫做<code>金山打字通</code>，里面有个打字的飞机大战不知道有没有小伙伴玩过，当然我整不来他那么优秀，我只能做一个较为简单的（<strong>低配版</strong>），低的好像还真挺低。</p><p>先来看看效果吧：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/408057b8b3e548bf9f6715d512324fe6~tplv-k3u1fbpfcp-watermark.image" alt="打字游戏效果图.gif"></p><h2 id="开始整活"><a href="#开始整活" class="headerlink" title="开始整活"></a>开始整活</h2><p>页面构成比较简单，一个是我们要打的字母，一个是下面的那行小字，用来做提示用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;char&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span>&gt;</span>请在按键上按下屏幕上显示的字母<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来是做一些简单的布局，就是将内容居中，颜色等做一下调整，我们先贴代码，完后在进行一个细说。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*开启弹性布局，并让弹性布局中的子元素</span></span><br><span class="line"><span class="comment">    水平居中对齐，垂直居中对齐*/</span></span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="comment">/* 用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式 */</span></span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="comment">/*文字居中*/</span></span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="comment">/*设置背景颜色的经向渐变*/</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">radial-gradient</span>(circle,<span class="number">#444</span>,<span class="number">#000</span>,<span class="number">#000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#char</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="comment">/*color: lightgreen;*/</span></span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#90EE90</span>;</span><br><span class="line">    <span class="comment">/*设置文字阴影*/</span></span><br><span class="line">    <span class="comment">/*text-shadow: 水平位置 垂直位置 模糊距离 阴影颜色*/</span></span><br><span class="line">    <span class="comment">/*位置可以为负值*/</span></span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">50px</span> <span class="number">#666</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#result</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#888</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*找到id为char及类名为error的div元素*/</span></span><br><span class="line"><span class="selector-id">#char</span><span class="selector-class">.error</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义了一个<code>error</code>类，用来做用户输入错的时候，将字母变成红色来给与用户提示。</p><p>背景用的径向渐变也挺有意思的，你必须要设定两个终止色，由中心到四周产生渐变色的效果，他的第一个参数有两种情况，椭圆跟圆，我们是可以自己进行选择的。</p><p>如果对此感兴趣也可以去菜鸟教程<a href="https://www.runoob.com/cssref/func-radial-gradient.html">径向渐变</a>看一看。</p><p>接下来我们来写我们的js逻辑处理。</p><p>先定义和获取我们需要的变量跟Dom节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示正确的次数</span></span><br><span class="line"><span class="keyword">var</span> okCount=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//错误的次数</span></span><br><span class="line"><span class="keyword">var</span> errorCount=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//获取显示字符的div</span></span><br><span class="line"><span class="keyword">var</span> charBox=<span class="built_in">document</span>.getElementById(<span class="string">&#x27;char&#x27;</span>);</span><br><span class="line"><span class="comment">//获取显示结果的div</span></span><br><span class="line"><span class="keyword">var</span> result=<span class="built_in">document</span>.getElementById(<span class="string">&#x27;result&#x27;</span>);</span><br></pre></td></tr></table></figure><p>正确率=正确的次数/总次数，我们再写一个函数来显示判断结果，显示正确跟错误的个数，还有正确率。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//展示计算的结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showResult</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rate=<span class="number">100</span>*okCount/(okCount+errorCount);</span><br><span class="line">    <span class="comment">//显示正确个数 错误个数 及正确率</span></span><br><span class="line">    result.innerHTML=<span class="string">&#x27;正确&#x27;</span>+okCount+<span class="string">&#x27;个&#x27;</span>+<span class="string">&#x27;错误&#x27;</span>+errorCount+<span class="string">&#x27;个&#x27;</span>+<span class="string">&#x27;正确率&#x27;</span>+rate.toFixed(<span class="number">2</span>)+<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>toFixed(2)的作用是保留两位小数</p></blockquote><p>我们再写一个函数去随机获取A~Z这些英文字母的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> code = <span class="number">0</span>; <span class="comment">// 存放随机数</span></span><br><span class="line"> <span class="comment">//获取A~Z之间的任意一个字符</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//获取[0,1)之间的一个随机数</span></span><br><span class="line">        <span class="keyword">var</span> rand=<span class="built_in">Math</span>.random();</span><br><span class="line">        <span class="comment">//获取一个0到26之间的一个随机数（不包含26）</span></span><br><span class="line">        code=rand*<span class="number">26</span>;</span><br><span class="line">        <span class="comment">//Math.floor(a)对数字a向下取整，获取到一个小于等于a最近的整数</span></span><br><span class="line">        <span class="comment">//获取0~25之间任意一个整数</span></span><br><span class="line">        code=<span class="built_in">Math</span>.floor(code);</span><br><span class="line">        <span class="comment">//获取到65~90之间的任意整数</span></span><br><span class="line">        code=code+<span class="number">65</span>;</span><br><span class="line">        <span class="comment">//把ASCII的十进制编码转化成对应的字符</span></span><br><span class="line">        <span class="comment">//获取A~Z的任意一个字符</span></span><br><span class="line">        <span class="keyword">var</span> char=<span class="built_in">String</span>.fromCharCode(code);</span><br><span class="line">        <span class="comment">//把字符显示在界面上</span></span><br><span class="line">        charBox.innerHTML=char;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>利用随机数生成A~Z的ASCII码值，完后用<code>String.fromCharCode</code>转成英文字母并显示到页面上。</p><p>还有最后一个步骤就是监听用户的键盘按键事件,利用<code>window.onkeydown</code>事件来做。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//键盘按下来的事件</span></span><br><span class="line"><span class="built_in">window</span>.onkeydown=<span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//获取按键所对应的ASCII编码</span></span><br><span class="line">    <span class="keyword">var</span> key=ev.keyCode;</span><br><span class="line">    <span class="comment">//判断按键字母所对应的数字和随机获取的数字是否相等</span></span><br><span class="line">    <span class="keyword">if</span>(key==code)&#123;</span><br><span class="line">        <span class="comment">//按键正确，正确次数+1</span></span><br><span class="line">        okCount ++;</span><br><span class="line">        <span class="comment">//当按键正确时，重新显示新的字符</span></span><br><span class="line">        show();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//按键错误，错误次数+1</span></span><br><span class="line">        errorCount ++;</span><br><span class="line">    &#125;   </span><br><span class="line">    showResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在已经成功了，来看看效果吧！</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a242ddcc4630449f99bfa08c864b99bb~tplv-k3u1fbpfcp-watermark.image" alt="打字游戏效果.gif"></p><p>但是我们优秀的程序员当然想给用户<strong>略微</strong>（更好）的用户体验！所以我们来引入一个<a href="https://animate.style/">Animate.css</a>动画库。</p><p>结合我们的小游戏，选择了<code>zoomIn</code>与<code>shake</code>两个动画，一个作为英文字母的出现伴随动画，另一个作为错误的时候提示用户的动画。我们在监听用户按键做出判断的时候来给我们的元素加上相对应动画的类名，并且在0.5s过后移除对应的类名就行了，防止发生冲突。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//键盘按下来的事件</span></span><br><span class="line"><span class="built_in">window</span>.onkeydown=<span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//获取按键所对应的ASCII十进制编码</span></span><br><span class="line">    <span class="keyword">var</span> key=ev.keyCode;</span><br><span class="line">    <span class="comment">//判断按键字母所对应的数字和随机获取的数字是否相等</span></span><br><span class="line">    <span class="keyword">if</span>(key==code)&#123;</span><br><span class="line">        <span class="comment">//按键正确，正确次数+1</span></span><br><span class="line">        okCount ++;</span><br><span class="line">        <span class="comment">//当按键正确时，重新显示新的字符</span></span><br><span class="line">        show();</span><br><span class="line">        <span class="comment">//添加正确的动画 通过js给div添加类名</span></span><br><span class="line">        charBox.className =<span class="string">&#x27;animated zoomIn&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//按键错误，错误次数+1</span></span><br><span class="line">        errorCount ++;</span><br><span class="line">        <span class="comment">//添加按键错误的动画</span></span><br><span class="line">        charBox.className=<span class="string">&#x27;animated shake error&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    showResult();</span><br><span class="line">    <span class="comment">//0.5秒之后清除动画</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(clearAnimated,<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clearAnimated</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//负责清除动画</span></span><br><span class="line">    charBox.className=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，我们今日的整活就结束啦~</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>希望大家快乐起来呀，老想着如何去实现产品经理给的需求会十分疲惫，在空闲之余不如来用我们擅长的代码整个活~</p><p>让自己，也让周围的人开心开心，也能让自己的心情变得轻松起来！</p><p>本文首发于<a href="https://juejin.cn/user/105972016875911">掘金 </a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;代码不光是我们用来工作的，也应该是我们用来娱乐的，今天就带着小伙伴们整个活！&lt;/p&gt;
&lt;p&gt;看完这篇文章，你会学会如何整活~&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://wangenze267.github.io/tags/JavaScript/"/>
    
    <category term="整活系列" scheme="https://wangenze267.github.io/tags/%E6%95%B4%E6%B4%BB%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Vue都使用那么久了，还不了解它的生命周期吗？</title>
    <link href="https://wangenze267.github.io/posts/2631169793.html/"/>
    <id>https://wangenze267.github.io/posts/2631169793.html/</id>
    <published>2021-11-25T10:52:22.858Z</published>
    <updated>2021-11-25T10:52:48.472Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我记得尤大曾经说过，你看Vue源码干嘛？你使用Vue又不需要它的源码，你只需要会用就行了！</p><p>但是我们得卷啊，不卷怎么脱颖而出😥，我还记得在今年的蓝桥杯群里，有一同届的还不知道哪个大学的哥们，已经在读Vue/React/Node的源码了…..作为小菜鸡的我看着大佬侃侃而谈，在群角落里瑟瑟发抖。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c4b08a27fe84971933ea05de0e58d97~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>最近有在牛客上复习Vue的知识，整理出这篇文章，一是方便自己未来复习，二是希望能够帮助一些跟我一样的朋友们复习一边知识点，学习在什么时候都不晚。</p><p>这篇文章会讲到：</p><ul><li>Vue的生命周期到底是什么</li><li>Vue生命周期的执行顺序</li><li>生命周期的每个阶段适合做什么</li><li>我们的请求放在哪个生命周期会更合适</li></ul><blockquote><p>当然我只会讲我理解的emm，可能会很浅，还请多包涵。</p></blockquote><h2 id="Vue的生命周期到底是什么？"><a href="#Vue的生命周期到底是什么？" class="headerlink" title="Vue的生命周期到底是什么？"></a>Vue的生命周期到底是什么？</h2><p>与其说是Vue的生命周期，我觉得不如说是其内组件的生命周期。<br>简单来说，它的生命周期就是用来描述一个组件从引入到退出的全过程。<br>那复杂来说呢？就是一个组件从<strong>创建</strong>开始经历了<strong>数据初始化</strong>，<strong>挂载</strong>，<strong>更新</strong>等步骤后，最后被<strong>销毁</strong>。</p><h2 id="Vue生命周期的执行顺序"><a href="#Vue生命周期的执行顺序" class="headerlink" title="Vue生命周期的执行顺序"></a>Vue生命周期的执行顺序</h2><p>他整体是分为三个大阶段的，在三个大阶段中，有细分为若干的小阶段。我们可以在不同的阶段去做不同的事情，后文也会讲到不同的阶段适合我们去做具体什么事情的。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd5da0f04d1240a38fccce2ac062b25b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>我们先来看看它的执行顺序吧：</p><p>有两种方法，一种就是<a href="https://cn.vuejs.org/v2/guide/instance.html#%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90">Vue的官方文档</a>上面有一个图是专门解释生命周期的，但鉴于可能许多小伙伴们都是跟我一样，看英文文档都要伴随着翻译的水平，所以特意在网上找了个翻译过后的汉化版，放在这里给大家做参考：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ccd16fe2d1942e699bde7a7971c26a2~tplv-k3u1fbpfcp-watermark.image" alt="生命周期.webp"><br>这个图详细的解释了一个Vue实例从创建到销毁的全过程。</p><p>第二种方法，就是我们在Vue项目中打印一下，在控制台中我们就能清晰的看出，谁执行的早，谁执行的晚，甚至能看出他们有什么区别：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.group(<span class="string">&#x27;------beforeCreate创建前状态------&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>, <span class="string">&quot;el     : &quot;</span> + <span class="built_in">this</span>.$el); <span class="comment">//undefined</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>, <span class="string">&quot;data   : &quot;</span> + <span class="built_in">this</span>.$data); <span class="comment">//undefined </span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>, <span class="string">&quot;message: &quot;</span> + <span class="built_in">this</span>.message)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">created</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.group(<span class="string">&#x27;------created创建完毕状态------&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>, <span class="string">&quot;el     : &quot;</span> + <span class="built_in">this</span>.$el); <span class="comment">//undefined</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>, <span class="string">&quot;data   : &quot;</span> + <span class="built_in">this</span>.$data); <span class="comment">//已被初始化 </span></span><br><span class="line">        <span class="built_in">console</span>.dir(<span class="built_in">this</span>.$data)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>, <span class="string">&quot;message: &quot;</span> + <span class="built_in">this</span>.message); <span class="comment">//已被初始化</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">beforeMount</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.group(<span class="string">&#x27;------beforeMount挂载前状态------&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>, <span class="string">&quot;el     : &quot;</span> + (<span class="built_in">this</span>.$el)); <span class="comment">//undefined</span></span><br><span class="line">        <span class="built_in">console</span>.dir(<span class="built_in">this</span>.$el)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>, <span class="string">&quot;data   : &quot;</span> + <span class="built_in">this</span>.$data); <span class="comment">//已被初始化  </span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>, <span class="string">&quot;message: &quot;</span> + <span class="built_in">this</span>.message); <span class="comment">//已被初始化  </span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mounted</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.group(<span class="string">&#x27;------mounted 挂载结束状态------&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>, <span class="string">&quot;el     : &quot;</span> + <span class="built_in">this</span>.$el); <span class="comment">//已被初始化</span></span><br><span class="line">        <span class="built_in">console</span>.dir(<span class="built_in">this</span>.$el)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>, <span class="string">&quot;data   : &quot;</span> + <span class="built_in">this</span>.$data); <span class="comment">//已被初始化</span></span><br><span class="line">        <span class="built_in">console</span>.dir(<span class="built_in">this</span>.$data)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>, <span class="string">&quot;message: &quot;</span> + <span class="built_in">this</span>.message); <span class="comment">//已被初始化 </span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">beforeUpdate</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.group(<span class="string">&#x27;beforeUpdate 更新前状态===============》&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>, <span class="string">&quot;el     : &quot;</span> + <span class="built_in">this</span>.$el);</span><br><span class="line">        <span class="built_in">console</span>.dir(<span class="built_in">this</span>.$el)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>, <span class="string">&quot;data   : &quot;</span> + <span class="built_in">this</span>.$data);</span><br><span class="line">        <span class="built_in">console</span>.dir(<span class="built_in">this</span>.$data)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>, <span class="string">&quot;message: &quot;</span> + <span class="built_in">this</span>.message);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">updated</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.group(<span class="string">&#x27;updated 更新完成状态===============》&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>, <span class="string">&quot;el     : &quot;</span> + <span class="built_in">this</span>.$el);</span><br><span class="line">        <span class="built_in">console</span>.dir(<span class="built_in">this</span>.$el)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>, <span class="string">&quot;data   : &quot;</span> + <span class="built_in">this</span>.$data);</span><br><span class="line">        <span class="built_in">console</span>.dir(<span class="built_in">this</span>.$data)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>, <span class="string">&quot;message: &quot;</span> + <span class="built_in">this</span>.message);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">beforeDestroy</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.group(<span class="string">&#x27;beforeDestroy 销毁前状态===============》&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>, <span class="string">&quot;el     : &quot;</span> + <span class="built_in">this</span>.$el);</span><br><span class="line">         <span class="built_in">console</span>.dir(<span class="built_in">this</span>.$el)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>, <span class="string">&quot;data   : &quot;</span> + <span class="built_in">this</span>.$data);</span><br><span class="line">        <span class="built_in">console</span>.dir(<span class="built_in">this</span>.$data)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>, <span class="string">&quot;message: &quot;</span> + <span class="built_in">this</span>.message);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">destroyed</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.group(<span class="string">&#x27;destroyed 销毁完成状态===============》&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>, <span class="string">&quot;el     : &quot;</span> + <span class="built_in">this</span>.$el);</span><br><span class="line">         <span class="built_in">console</span>.dir(<span class="built_in">this</span>.$el)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>, <span class="string">&quot;data   : &quot;</span> + <span class="built_in">this</span>.$data);</span><br><span class="line">        <span class="built_in">console</span>.dir(<span class="built_in">this</span>.$data)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>, <span class="string">&quot;message: &quot;</span> + <span class="built_in">this</span>.message)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h3><p>其实这个代码的先后顺序就是他执行的先后顺序了，为了能有更新的状态，所以我找了个todolist的demo，可以添加跟删除的，方便我们来看，首先是刚进入页面：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daf49b4c7be647bd8bc9fb0229dde02b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>我们可以看到<code>beforeCreate</code>是最先的，并且在此时的状态下，我们打印的信息什么都拿不到。</p><p>之后进入了<code>created</code>状态，在这个状态中我们的<code>el</code>，也就是Dom元素依旧是拿不到的，但是我们已经可以拿到<code>data</code>了，这意味着 <strong><code>created</code>已经将数据加载进来了</strong> ，已经为这个Vue实例开辟了内存空间。</p><p><code>beforeMount</code>，挂载前状态，在我的理解挂载就是将虚拟Dom转变成真实Dom的过程，所以在这之前，我们的<code>el</code>当然还是拿不到的。</p><p><code>mounted</code>，挂载结束，意味着虚拟Dom已经挂载在了真实的元素上，所以从此开始我们就可以拿到<code>el</code>了。我们可以用<code>console.dir</code>去打印一些我们需要的元素的属性。</p><p>至此，我们的挂载阶段就结束了。</p><h3 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h3><p>下面我们删除一个list，来看一下更新状态。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2f5e3a3a3d34cf7afb73ae608a08483~tplv-k3u1fbpfcp-watermark.image" alt="更新状态.gif"></p><p>每当我们去改变页面元素的时候，就会进入更新阶段，也就是<code>beforeUpdate</code>,<code>updated</code>这两个状态。</p><h3 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h3><p>下面我们再来看一下最后的销毁阶段。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f305953a91514e02bf708602d4400e0b~tplv-k3u1fbpfcp-watermark.image" alt="销毁状态.gif"></p><p><code>beforeDestroy</code>，销毁前状态，在销毁之前，所以我们的元素、data都是如同挂载之后的阶段一样，都是可以打印出来的。</p><p><code>destroyed</code>,其实最让我震惊的是这个，销毁完成的状态，我以为销毁了，那应该什么都打印不出来了，其实不然，他还是什么都可以打印出来的。</p><p><code>beforeDestroy</code>和<code>destroyed</code>，都是我们离开这个组件才会被调用的生命周期。</p><h2 id="生命周期的每个阶段适合做什么"><a href="#生命周期的每个阶段适合做什么" class="headerlink" title="生命周期的每个阶段适合做什么"></a>生命周期的每个阶段适合做什么</h2><p>下面我们来讲讲，在不同的阶段我们可以做些什么：</p><p><strong>created：</strong><br>在Vue实例创建完毕状态，我们可以去访问data、computed、watch、methods上的方法和数据，但现在还没有将虚拟Dom挂载到真实Dom上，所以我们在此时访问不到我们的Dom元素（el属性，ref属性此时都为空）。</p><blockquote><p>我们在此时可以进行一些简单的Ajax，并可以对页面进行初始化之类的操作</p></blockquote><p><strong>beforeMount：</strong><br>它是在挂载之前被调用的，会在此时去找到虚拟Dom，并将其编译成Render</p><p><strong>mounted：</strong><br>虚拟Dom已经被挂载到真实Dom上，此时我们可以获取Dom节点，<code>$ref</code>在此时也是可以访问的。</p><blockquote><p>我们在此时可以去获取节点信息，做Ajax请求，对节点做一些操作</p></blockquote><p><strong>beforeupdate：</strong><br>响应式数据更新的时候会被调用，<code>beforeupdate</code>的阶段虚拟Dom还没更新，所以在此时依旧可以访问现有的Dom。</p><blockquote><p>我们可以在此时访问现有的Dom，手动移除一些添加的监听事件</p></blockquote><p><strong>updated：</strong><br>此时补丁已经打完了，Dom已经更新完毕，可以执行一些依赖新Dom的操作。</p><blockquote><p>但还是不建议在此时进行数据操作，避免进入死循环（这个坑我曾经踩过）</p></blockquote><p><strong>beforeDestroy：</strong><br>在Vue实例销毁之前被调用，在此时我们的实例还未被销毁。</p><blockquote><p>在此时可以做一些操作，比如销毁定时器，解绑全局事件，销毁插件对象等</p></blockquote><h2 id="父子组件的生命周期"><a href="#父子组件的生命周期" class="headerlink" title="父子组件的生命周期"></a>父子组件的生命周期</h2><p>刚刚说的都是单页面，那么父子组件的生命周期会是什么样子呢？我们仅做一个简单的补充。</p><p>不知道大家在刚刚的图中是否注意到了这两行：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26cbab3395474539b391b678dd63acc9~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>我们页面中的小<code>li</code>就是一个被嵌入在这个大页面内部的一个子组件，我们也打印了它的生命周期：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;list created&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;list mounted&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">beforeUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;list before update&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">updated</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;list updated&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">beforeDestroy</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 及时销毁，否则可能造成内存泄露</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;list beforeDestroy&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">destroyed</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;list Destroy&#x27;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由此可得，在父组件挂载前阶段，子组件已经挂载完成了。</p><p>不光是挂载阶段，其他两个阶段我们也可以打印出来，但是在这里我就不细说了，直接上结论：</p><ul><li>挂载阶段：父组件 beforeMount -&gt; 子组件 created -&gt; 子组件 mounted -&gt; 父组件 mounted</li><li>更新阶段：父组件 beforeUpdate -&gt; 子组件 beforeUpdated -&gt; 子组件 updated -&gt; 父组件 updated</li><li>销毁阶段：父组件 beforeDestroy -&gt; 子组件 beforeDestroy -&gt; 子组件 destroyed -&gt; 父组件 destroyed<h2 id="我们的请求放在哪个生命周期会更合适"><a href="#我们的请求放在哪个生命周期会更合适" class="headerlink" title="我们的请求放在哪个生命周期会更合适"></a>我们的请求放在哪个生命周期会更合适</h2>那么至此我们已经对于Vue的生命周期有了一个基本的了解，现在我们来说一说，我们的请求应该放到哪个生命周期中才最为合适。</li></ul><p>一般来说，会有两种回答：<code>created</code>和<code>mounted</code>。<br>上文已经讲了，这两个回答，前者是数据已经准备好了，后者是连dom也已经加载完成了，那么到底哪个才是正确答案呢？</p><p>其实，两个都是可以的，但是<code>mounted</code>会更好。</p><blockquote><p>可能有人会说：<code>created</code>的时间会更早，早些调用不是会省很多时间吗？这样性能会不会更高一点</p><p>别急，我们一点一点来看</p></blockquote><ul><li>首先，它确实是早了，但是早不了几微秒，所以这其实没有提高性能</li><li>其次，我们在<code>created</code>阶段并没有去做渲染，所以在接下来我们会去做Dom渲染，但是如果此时我们还做了Ajax操作，在Ajax结束之后就会返回数据，我们就会将其插入到主线程中去运行，去处理数据，但是我们要知道，<strong>在浏览器机制中，渲染线程跟js线程是互斥的</strong>，所以<strong>有可能</strong>我们做渲染的同时，另一边可能要处理Ajax返回的数据了，这时候渲染就<strong>有可能被打断</strong>，在处理完数组后，去进行重新渲染。<br>那如果在<code>created</code>中有多个Ajax呢？我们又要重新进行渲染，所以在<code>created</code>去做Ajax请求这明显不太合适。</li><li>还有，有的时候我们接到返回的数据的时候可能要在回调函数中去进行一些Dom的操作，可是<code>created</code>阶段我们还没有将真实Dom加载出来，所以相对而言我们还是在<code>mounted</code>去调用要好一些<blockquote><p>如果是服务端渲染，我们将其放入<code>created</code>中进行，因为服务端不支持<code>mounted</code>。</p></blockquote><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2>Vue算是前端学习旅途上陪伴我最长的东西了，但是至今还是没有将其学明白hhhh。</li></ul><blockquote><p>要更加努力呀，加油~</p></blockquote><p>本文首发于<a href="https://juejin.cn/user/105972016875911">掘金 </a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我记得尤大曾经说过，你看Vue源码干嘛？你使用Vue又不需要它的源码，你只需要会用就行了！&lt;/p&gt;
&lt;p&gt;但是我们得卷啊，不卷怎么脱颖而出�</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://wangenze267.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>我的第一次PR，一个炫酷的个人介绍页面</title>
    <link href="https://wangenze267.github.io/posts/3328562731.html/"/>
    <id>https://wangenze267.github.io/posts/3328562731.html/</id>
    <published>2021-11-25T10:52:22.858Z</published>
    <updated>2021-11-25T10:52:48.477Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一直想做个关于介绍的个人页面，挂在域名的根路径下面，当home页用，还不想手动的去自己从0到1的去做一个，觉得那很浪费时间，直到我前几天逛github，发现了这个项目，瞬间觉得，它就是我想要的样子~</p><h2 id="个人简介页面模板"><a href="#个人简介页面模板" class="headerlink" title="个人简介页面模板"></a>个人简介页面模板</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b0b33078d5040db84a282baf0c479b5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>女生自用99新？？？？引起了我极大的好奇心，连忙点进去。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c492f3828bc443dfb1d532e1150759c7~tplv-k3u1fbpfcp-watermark.image" alt="111.jfif"></p><p>这个项目是Vue做的，READEME里面给与了充足的介绍，跟效果图，demo网址等，给了小白充足的了解去把这个项目更改成为自己的一个介绍网页，里面的功能也是十分的齐全。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c1a0dcbefde4e5bbcffcf2cb7b13224~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><blockquote><p>如果有需要可以直接点击传送门：<a href="https://github.com/Jiaocz/Personal-page">Jiaocz/Personal-page</a></p></blockquote><p>我也是十分的欣喜，终于找到了我喜欢的样子，于是直接<code>git clone</code>，将项目拉下来，进去照着注释，文档，各种改了改，于是他最后成了这个样子：</p><blockquote><p>传送门查看效果：<a href="https://www.wangez.site/">Ned</a></p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd47c232658c4063a6523945c9c2112e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>这里我又要说一件事情了，这个项目原来，下方的icon不是我截屏中的这样，而是这个效果：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adc7704ce85044ea835363ccc9e133c6~tplv-k3u1fbpfcp-watermark.image" alt="原来.gif"></p><p>而我心中的页面，下方想要放一些自己的站点，点击可以直接跳转的那种，并且我觉得他原来做的动效也很好看，可以保留，于是就想着，我能不能自己给他改动一下，使得🐟和🐻可以兼得呢？</p><blockquote><p>是不是做出来还可以提个PR，满足我的开源梦~</p></blockquote><h2 id="我的第一次PR"><a href="#我的第一次PR" class="headerlink" title="我的第一次PR"></a>我的第一次PR</h2><p>说做就做，我去找到了有关icon的函数，查了一下相关的配置，发现我这个需求其实不难实现。<br>用到的原本的数据格式是这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">&quot;Github&quot;</span>,</span><br><span class="line">      icon: <span class="string">&quot;icon brands fa-github&quot;</span>,</span><br><span class="line">      desc: <span class="string">&quot;Github&quot;</span>,</span><br><span class="line">      content: <span class="string">&quot;https://www.wangez.site/&quot;</span>,</span><br><span class="line">      show: <span class="literal">false</span>,</span><br><span class="line">      <span class="comment">// jump: true,</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>下面函数是获知用户点击了哪个icon，传入对应的name，从而去将show改成true，将其内部的content显示出来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">showContact: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.contacts.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.contacts[i].name == name) &#123;</span><br><span class="line">        num = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.hideContact(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">this</span>.defaults = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(<span class="built_in">this</span>.timer);</span><br><span class="line">    <span class="built_in">this</span>.timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.contacts[num].show = <span class="literal">true</span>;</span><br><span class="line">      <span class="built_in">this</span>.backButton = <span class="literal">true</span>;</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在这个数据中加入一个jump字段，也是有着<code>true</code>，<code>false</code>，两个值，如果根据name得到的那组数据中的jump字段是true，就将其跳转，false我们就不管，继续执行他原本的动效操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">showContact: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.contacts.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.contacts[i].name == name) &#123;</span><br><span class="line">        num = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.contacts[num].jump == <span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="built_in">window</span>.open(<span class="built_in">this</span>.contacts[num].content);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.hideContact(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">this</span>.defaults = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(<span class="built_in">this</span>.timer);</span><br><span class="line">    <span class="built_in">this</span>.timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.contacts[num].show = <span class="literal">true</span>;</span><br><span class="line">      <span class="built_in">this</span>.backButton = <span class="literal">true</span>;</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改完，测试完的我，就兴致勃勃的提交了我人生中的第一个PR，后来跟项目作者在github上交流了几次，也做了部分修改后，我的PR成功被采纳了！！！！！</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9f6bc5979df4a659b1d38a45e5e12e3~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>虽然改动的地方不多，可能还不够完善，但是今后我会持续发光发热，争取把我的想法输出在这个项目中，也是给那些像我一样，懒的自己做，只想找一个自定义更丰富的个人页面的人一个满意的结果。</p><h2 id="至于我的页面"><a href="#至于我的页面" class="headerlink" title="至于我的页面"></a>至于我的页面</h2><p>我的icon跟作者使用的不同，使用的阿里矢量库中的icon，所以我将其中的a标签换成了span，并更改了一些样式，可能后续的我会把我下方icon的部分也提交到仓库中，供给更多的朋友们使用。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>第一次成为Contributor呀~，十分的激动hhhhh</p><p>给以后的自己，加个油吧，要更加努力！</p><p>本文首发于<a href="https://juejin.cn/user/105972016875911">掘金 </a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;一直想做个关于介绍的个人页面，挂在域名的根路径下面，当home页用，还不想手动的去自己从0到1的去做一个，觉得那很浪费时间，直到我前几天逛g</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://wangenze267.github.io/tags/Vue/"/>
    
    <category term="经历" scheme="https://wangenze267.github.io/tags/%E7%BB%8F%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>封装一个日期格式化的工具函数</title>
    <link href="https://wangenze267.github.io/posts/1068581590.html/"/>
    <id>https://wangenze267.github.io/posts/1068581590.html/</id>
    <published>2021-11-07T05:52:47.453Z</published>
    <updated>2021-11-07T05:59:09.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近还是在做那个练习的小项目，做完接收数据并渲染到页面上的时候，发现后端小伙伴又在给我找活干了，渲染这当然是小kiss啦，可这个字段是什么东西？</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;createTime&quot;</span> : <span class="string">&quot;2021-01-17T13:32:06.381Z&quot;</span>,</span><br><span class="line"><span class="string">&quot;lastLoginTime&quot;</span> : <span class="string">&quot;2021-01-17T13:32:06.381Z&quot;</span></span><br></pre></td></tr></table></figure><p>直接CV到百度，查出来这一串是一种时间格式，下面放上它的解释：</p><blockquote><p>T表示分隔符，Z表示的是UTC.<br>UTC：世界标准时间，在标准时间上加上8小时，即东八区时间，也就是北京时间。</p><p>另：还有别的时间格式和时间戳，想了解的小伙伴可以百度了解一下哦，免得跟我一样，看到了才想着去百度了解，事先了解一下，没坏处的。</p></blockquote><p>了解完了，现在我应该做的，就是将这个时间变成我们大家看得懂的那种格式，并将它渲染到页面上。</p><h2 id="开始上手"><a href="#开始上手" class="headerlink" title="开始上手"></a>开始上手</h2><p>JavaScript中，处理日期和时间，当然要用到我们的Date对象，所以我们先来写出这个函数的雏形：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> formateDate = <span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面要做的应该是定义日期的格式了，这里我用的是<code>yyyy-MM-dd hh:mm:ss</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fmt = <span class="string">&#x27;yyyy-MM-dd hh:mm:ss&#x27;</span></span><br></pre></td></tr></table></figure><p>因为年月日时分秒这里都是两位或者两位以上的，所以在获取的时候我是这样定义的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="string">&#x27;y+&#x27;</span>: date.getFullYear(),</span><br><span class="line">  <span class="string">&#x27;M+&#x27;</span>: date.getMonth()+<span class="number">1</span>,</span><br><span class="line">  <span class="string">&#x27;d+&#x27;</span>: date.getDate(),</span><br><span class="line">  <span class="string">&#x27;h+&#x27;</span>: date.getHours(),</span><br><span class="line">  <span class="string">&#x27;m+&#x27;</span>: date.getMinutes(),</span><br><span class="line">  <span class="string">&#x27;s+&#x27;</span>: date.getSeconds()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先先解释一下<code>getMonth()+1</code>，去查看Date文档就知道，这个函数的返回是0-11，我们正常月份都是1-12，所以加上1，才是正确的月份。</p><p>定义了规则之后，我们循环它，应该就可以得到我们想要的结果了吧。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> o )&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`(<span class="subst">$&#123;k&#125;</span>)`</span>).test(fmt))&#123;</span><br><span class="line">    <span class="keyword">const</span> val = o[k] + <span class="string">&#x27;&#x27;</span></span><br><span class="line">    fmt = fmt.replace(<span class="built_in">RegExp</span>.$1,val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们继续来解释一下代码，首先<code>fmt.replace</code>是代表我们要做一个替换，<code>RegExp.$1</code>就是获取到上面的值表达式内容，将这个内容，换成val中的值，之所以上面加了一个空字符串，是为了将val变成字符串的形式，以防再出纰漏。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd84f81d748a407d8875e03d30149499~tplv-k3u1fbpfcp-watermark.awebp" alt="$1"></p><p>我们渲染上去，看看结果如何？</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6146da5250c4b7dac1b34b6e704a900~tplv-k3u1fbpfcp-watermark.awebp" alt="秒未补零"></p><p>日期被我们成功的转化为了，我们能看得懂的东西，但是我们可以看到，秒这里，只有一位，也就是说，在秒只有个位数的情况下，我们应该给予它一个<strong>补零</strong>的操作。</p><blockquote><p>不光是秒，其他也应该是这个道理哦！</p></blockquote><h3 id="关于补零"><a href="#关于补零" class="headerlink" title="关于补零"></a>关于补零</h3><p>补零的话，有两种方式，先来说说笨笨的这种吧：</p><p>我们去判断这个字符串的长度，如果是1，我们就加个零，如果不是1，那么就不用加。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;6&#x27;</span></span><br><span class="line">a.length = <span class="number">1</span>?<span class="string">&#x27;0&#x27;</span>+a:a <span class="comment">// &#x27;06&#x27;</span></span><br></pre></td></tr></table></figure><p>再来说个略微比这个高级一点的：</p><p>我们需要两位，所以直接给字符串补上两个零，再用substr去分割一下字符串，就能得到我们想要的了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;6&#x27;</span></span><br><span class="line"><span class="keyword">var</span> result = (<span class="string">&#x27;00&#x27;</span>+b).substr(b.length) <span class="comment">// &#x27;06&#x27;</span></span><br></pre></td></tr></table></figure><p>那么我们去改一下上面的代码，就得到了下面的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> formateDate = <span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(value)</span><br><span class="line"><span class="keyword">let</span> fmt = <span class="string">&#x27;yyyy-MM-dd hh:mm:ss&#x27;</span></span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">      <span class="string">&#x27;y+&#x27;</span>: date.getFullYear(),</span><br><span class="line">      <span class="string">&#x27;M+&#x27;</span>: date.getMonth()+<span class="number">1</span>,</span><br><span class="line">      <span class="string">&#x27;d+&#x27;</span>: date.getDate(),</span><br><span class="line">      <span class="string">&#x27;h+&#x27;</span>: date.getHours(),</span><br><span class="line">      <span class="string">&#x27;m+&#x27;</span>: date.getMinutes(),</span><br><span class="line">      <span class="string">&#x27;s+&#x27;</span>: date.getSeconds()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> o )&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`(<span class="subst">$&#123;k&#125;</span>)`</span>).test(fmt))&#123;</span><br><span class="line">        <span class="keyword">const</span> val = o[k] + <span class="string">&#x27;&#x27;</span></span><br><span class="line">        fmt = fmt.replace(<span class="built_in">RegExp</span>.$1,<span class="built_in">RegExp</span>.$1.length==<span class="number">1</span>?val:(<span class="string">&#x27;00&#x27;</span>+val).substr(val.length))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在刷新一下网页，看看我们成功了没！</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5736f800051848e3927862c98b38ea39~tplv-k3u1fbpfcp-watermark.awebp" alt="补零结束"></p><p>成功是成功了，但是我们发现，前面的年竟然被干掉了，他也变成了两位的样子，这可不行啊，我们定义的年份格式可是四位的。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/334e130734f848d58c3c72aa4491f4d8~tplv-k3u1fbpfcp-watermark.awebp"></p><p>但是别慌，这个只需要把年份单独的去做判断，不与其他2位的格式一起进行操作就能解决啦，所以我们最终的函数是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> formateDate = <span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(value)</span><br><span class="line"><span class="keyword">let</span> fmt = <span class="string">&#x27;yyyy-MM-dd hh:mm:ss&#x27;</span></span><br><span class="line"><span class="keyword">if</span>(<span class="regexp">/(y+)/</span>.test(fmt))&#123;</span><br><span class="line">        fmt = fmt.replace(<span class="built_in">RegExp</span>.$1,date.getFullYear())</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">      <span class="string">&#x27;M+&#x27;</span>: date.getMonth()+<span class="number">1</span>,</span><br><span class="line">      <span class="string">&#x27;d+&#x27;</span>: date.getDate(),</span><br><span class="line">      <span class="string">&#x27;h+&#x27;</span>: date.getHours(),</span><br><span class="line">      <span class="string">&#x27;m+&#x27;</span>: date.getMinutes(),</span><br><span class="line">      <span class="string">&#x27;s+&#x27;</span>: date.getSeconds()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> o )&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`(<span class="subst">$&#123;k&#125;</span>)`</span>).test(fmt))&#123;</span><br><span class="line">        <span class="keyword">const</span> val = o[k] + <span class="string">&#x27;&#x27;</span></span><br><span class="line">        fmt = fmt.replace(<span class="built_in">RegExp</span>.$1,<span class="built_in">RegExp</span>.$1.length==<span class="number">1</span>?val:(<span class="string">&#x27;00&#x27;</span>+val).substr(val.length))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下结果吧：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a9273e03c4748d1b012f97be1cb11a6~tplv-k3u1fbpfcp-watermark.awebp"></p><p>如果再严谨一点，可以再给函数加个参数，传递一个<code>rule</code>，这样方便我们后期进行调整数据格式，在定义格式的时候用<code>||</code>就好了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fmt = <span class="string">&#x27;传入的新格式&#x27;</span> || <span class="string">&#x27;默认的格式&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近还是在做那个练习的小项目，做完接收数据并渲染到页面上的时候，发现后端小伙伴又在给我找活干了，渲染这当然是小kiss啦，可这个字段是什么东</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://wangenze267.github.io/tags/JavaScript/"/>
    
    <category term="Vue" scheme="https://wangenze267.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>对el-table-column的简单封装</title>
    <link href="https://wangenze267.github.io/posts/82139994.html/"/>
    <id>https://wangenze267.github.io/posts/82139994.html/</id>
    <published>2021-11-06T08:01:37.513Z</published>
    <updated>2021-11-06T08:04:52.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在写一个练手项目，接触到了一个问题，就是<code>el-table</code>中的项太多了，我写了一堆<code>el-table-column</code>，导致代码太长了，看起来特别费劲，后来发现了一个让人眼前一亮的方法，瞬间挽救了我的眼睛。</p><p>下面就来分享一下！</p><h2 id="进入正题"><a href="#进入正题" class="headerlink" title="进入正题"></a>进入正题</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f18a5d8bbfd4eeca413208315f79572~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>上面就是table中的全部项，去除第一个复选框，最后一个操作的插槽，一共七项，也就是说<code>el-table-column</code>一共要写9对。这简直不能忍！</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c4696a1cdb64e0b9c5a80e959f9b0e4~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><blockquote><p>这个图只作举一个例子用，跟上面不产生对应关系。</p></blockquote><p>其中就有5个<code>el-form-item</code>，就这么一大堆。</p><p>所以，我当时就想，可不可以用<code>v-for</code>去渲染<code>el-table-column</code>这个标签呢？保留复选框和最后的操作插槽，我们只需要渲染中间的那几项就行。</p><p>经过我的实验，确实是可以实现的。</p><blockquote><p>这么写之后就开始质疑之前的我为什么没有这个想法? 要不就能少写一堆💩啦<br><strong>实现代码如下（标签部分）：</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-table-column</span><br><span class="line">            v-for=&quot;item in columns&quot;</span><br><span class="line">            :key=&quot;item.prop&quot;</span><br><span class="line">            :prop=&quot;item.prop&quot;</span><br><span class="line">            :label=&quot;item.label&quot;</span><br><span class="line">            :formatter=&quot;item.formatter&quot;</span><br><span class="line">            :width=&quot;item.width&quot;&gt;</span><br><span class="line">&lt;/el-table-column&gt;</span><br></pre></td></tr></table></figure><p>思路是这样，把标签需要显示的定义在一个数组中，遍历数组来达到我们想要的效果，<code>formatter</code>是我们完成提交的数据和页面显示数据的一个转换所用到的。具体写法在下面<strong>js</strong>部分有写。</p><p>定义数组的写法是<strong>vue3 composition api</strong>的写法，这个思路的话，用Vue2的写法也能实现的，重要的毕竟是思想（啊，我之前还是想不到这种思路）。</p><blockquote><p>再吐槽一下下，这种写法每写一个函数或者变量就要return回去，也挺麻烦的感觉，hhhhh</p></blockquote><p><strong>实现代码如下（JS部分）：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">const columns = reactive([</span><br><span class="line">      &#123;</span><br><span class="line">        label:&#x27;用户ID&#x27;,</span><br><span class="line">        prop:&#x27;userId&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        label:&#x27;用户名&#x27;,</span><br><span class="line">        prop:&#x27;userName&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        label:&#x27;用户邮箱&#x27;,</span><br><span class="line">        prop:&#x27;userEmail&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        label:&#x27;用户角色&#x27;,</span><br><span class="line">        prop:&#x27;role&#x27;,</span><br><span class="line">        formatter(row,column,value)&#123;</span><br><span class="line">          return &#123;</span><br><span class="line">            0:&quot;管理员&quot;,</span><br><span class="line">            1:&quot;普通用户&quot;</span><br><span class="line">          &#125;[value]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        label:&#x27;用户状态&#x27;,</span><br><span class="line">        prop:&#x27;state&#x27;,</span><br><span class="line">        formatter(row,column,value)&#123;</span><br><span class="line">          return &#123;</span><br><span class="line">            1:&quot;在职&quot;,</span><br><span class="line">            2:&quot;离职&quot;,</span><br><span class="line">            3:&quot;试用期&quot;</span><br><span class="line">          &#125;[value]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        label:&#x27;注册时间&#x27;,</span><br><span class="line">        prop:&#x27;createTime&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        label:&#x27;最后登陆时间&#x27;,</span><br><span class="line">        prop:&#x27;lastLoginTime&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>文章首发于掘金，后来整理到博客上的，掘金评论区许多大佬都给予了指点，所以有兴趣的可以点击链接过去瞅一瞅大佬们的发言呀~</p><p>掘金：<a href="https://juejin.cn/user/105972016875911">Ned - - 掘金 </a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在写一个练手项目，接触到了一个问题，就是&lt;code&gt;el-table&lt;/code&gt;中的项太多了，我写了一堆&lt;code&gt;el-table-</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://wangenze267.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript | 让数组扁平化的三个方法</title>
    <link href="https://wangenze267.github.io/posts/1583006393.html/"/>
    <id>https://wangenze267.github.io/posts/1583006393.html/</id>
    <published>2021-10-23T09:00:32.433Z</published>
    <updated>2021-10-23T09:00:56.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是扁平化"><a href="#什么是扁平化" class="headerlink" title="什么是扁平化"></a>什么是扁平化</h2><p><strong>定义： 数组的扁平化，就是将一个嵌套多层的数组 (嵌套有多少层都行)转换为只有一层的数组。</strong></p><p>举个例子如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr)) <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>其中，<code>faltten</code>函数的作用，就是让数组扁平化。</p><p>所以，我们已经知道这个函数起的是什么作用了，下面我们去试着写一个出来！</p><blockquote><p>造轮子的每一天~</p></blockquote><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>首先，我们循环这个数组，将不为数组的元素推入<code>result</code>中，如果元素还是数组，那么就使用递归来解决。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr[i])) &#123;</span><br><span class="line">            result = result.concat(flatten(arr[i]))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr))</span><br></pre></td></tr></table></figure><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><p><strong>如果数组中存储元素都为数字</strong>，那么我们可以取巧，使用<code>toString</code>方法来解决。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]].toString() <span class="comment">// &quot;1,2,3,4&quot;</span></span><br></pre></td></tr></table></figure><p>调用toString方法后，返回的是如上面一样的字符串。</p><p>我们使用<code>split</code>，以逗号为分割成数组，这样就可以实现扁平化了呀！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> arr.toString().split(<span class="string">&#x27;,&#x27;</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> item;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr)); <span class="comment">//[ &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27; ]</span></span><br></pre></td></tr></table></figure><p>但是我们很快发现不对，我们转成的是字符串数组，我们要的是数字，所以还需要做一下小修改。</p><p>将<code>return item</code>改成<code>return item * 1</code>就好，我们这样得到的结果就是个数字的数组了。</p><h2 id="…扩展运算符"><a href="#…扩展运算符" class="headerlink" title="…扩展运算符"></a>…扩展运算符</h2><p>ES6增加了这个运算符，用于取出对象所有可遍历的属性，放到当前对象内，我们来试试这个方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>]]];</span><br><span class="line"><span class="built_in">console</span>.log([].concat(...arr)); <span class="comment">//[ 1, 2, [ 3, 4 ] ]</span></span><br></pre></td></tr></table></figure><p>上面代码的意思是，将取出arr中所有可以遍历的属性，将他们放到一个新数组中。</p><p>我们拿结果和之前比对，发现只扁平了一层。</p><p>那么我们是否可以写一个函数，让它循环的扁平下去呢？</p><p>答案是，可以。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>]]];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(arr.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item)))&#123;</span><br><span class="line">arr = [].concat(...arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure><p>去查找数组里是否有属性是数组，反复的去扁平，最后返回的数组就是我们想要的了。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><blockquote><p>明天就是1024了，大家记得对自己好一点哇♥</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是扁平化&quot;&gt;&lt;a href=&quot;#什么是扁平化&quot; class=&quot;headerlink&quot; title=&quot;什么是扁平化&quot;&gt;&lt;/a&gt;什么是扁平化&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;定义： 数组的扁平化，就是将一个嵌套多层的数组 (嵌套有多少层都行)转换为只有一层的数组。&lt;</summary>
      
    
    
    
    
    <category term="ES6" scheme="https://wangenze267.github.io/tags/ES6/"/>
    
    <category term="JavaScript" scheme="https://wangenze267.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>恭喜你，Node后端学习经验值+1</title>
    <link href="https://wangenze267.github.io/posts/3366338322.html/"/>
    <id>https://wangenze267.github.io/posts/3366338322.html/</id>
    <published>2021-10-23T05:49:03.973Z</published>
    <updated>2021-10-23T05:49:39.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次整理了一些写node中遇到的知识点呀，查缺补漏，才能让自己成长的更稳哦！</p><blockquote><p>最近有在参加蓝桥杯web方向的模拟赛哦，来抓一波也在参加的小伙伴~</p></blockquote><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>遇到很多都是模块化的写法，之前自己写的时候确实这方面不是很注重，因为自己写自己看，当然怎么舒服怎么来了，它提醒我要**优雅一点<del>**，但是确实，这么写之后香的一批</del></p><h2 id="一些工具知识"><a href="#一些工具知识" class="headerlink" title="一些工具知识"></a>一些工具知识</h2><h3 id="Koa初始化"><a href="#Koa初始化" class="headerlink" title="Koa初始化"></a>Koa初始化</h3><blockquote><p>1.1 全局安装脚手架工具</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g koa-generator </span><br><span class="line"># or </span><br><span class="line">yarn global add koa-generator </span><br></pre></td></tr></table></figure><blockquote><p>1.2 进入到项目文件夹目录,执行生成命令</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># koa2+项目名</span><br><span class="line">koa2 manager-server</span><br></pre></td></tr></table></figure><blockquote><p>1.3 安装依赖</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install </span><br><span class="line"># or</span><br><span class="line">cnpm install</span><br><span class="line"># or</span><br><span class="line">yarn</span><br></pre></td></tr></table></figure><h3 id="使用pm2部署Koa项目并实现启动、关闭、自动重启"><a href="#使用pm2部署Koa项目并实现启动、关闭、自动重启" class="headerlink" title="使用pm2部署Koa项目并实现启动、关闭、自动重启"></a>使用pm2部署Koa项目并实现启动、关闭、自动重启</h3><p><strong>1. 全局安装</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g pm2</span><br></pre></td></tr></table></figure><p><strong>2. 启动项目</strong></p><blockquote><p>进入项目目录，然后使用pm2启动项目。这里要特别注意：启动<strong>单文件</strong>时用（app.js是项目文件名）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start app.js       #启动单文件</span><br></pre></td></tr></table></figure><blockquote><p>但是在koa2中需要这样启动：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start ./bin/www #启动koa2项目</span><br></pre></td></tr></table></figure><p><strong>3. pm2自动重启</strong></p><blockquote><p>把pm2的服务先停下,然后起来的时候带上–watch就可以了</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start ./bin/www --watch</span><br></pre></td></tr></table></figure><p><strong>4. pm2相关命令(www是项目名)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pm2 list           #查看所用已启动项目</span><br><span class="line">pm2 start          #启动</span><br><span class="line">pm2 restart www    #重启</span><br><span class="line">pm2 stop www       #停止</span><br><span class="line">pm2 delete www     #删除</span><br></pre></td></tr></table></figure><h2 id="以下为封装的两个工具函数"><a href="#以下为封装的两个工具函数" class="headerlink" title="以下为封装的两个工具函数"></a>以下为封装的两个工具函数</h2><h3 id="利用log4js封装日志输出"><a href="#利用log4js封装日志输出" class="headerlink" title="利用log4js封装日志输出"></a>利用log4js封装日志输出</h3><p>首先在<code>utils</code>文件夹中建好你的<code>log4j.js</code>文件，引入<strong>log4js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const log4js = require(&#x27;log4js&#x27;)</span><br></pre></td></tr></table></figure><p>下面是定义的level等级，截止到目前只用到了三种，但是教程里定义的确实是很多，可能是我没用到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const levels = &#123;</span><br><span class="line">    &#x27;trace&#x27;:log4js.levels.TRACE,</span><br><span class="line">    &#x27;debug&#x27;:log4js.levels.DEBUG,</span><br><span class="line">    &#x27;info&#x27;:log4js.levels.INFO,</span><br><span class="line">    &#x27;warn&#x27;:log4js.levels.WARN,</span><br><span class="line">    &#x27;error&#x27;:log4js.levels.ERROR,</span><br><span class="line">    &#x27;fatal&#x27;:log4js.levels.FATAL,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是要用<strong>log4js.configure</strong>去添加一些配置。</p><blockquote><p>appenders: 追加器</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">appenders:&#123;</span><br><span class="line">    console:&#123; type: &#x27;console&#x27; &#125;,</span><br><span class="line">    info:&#123;</span><br><span class="line">        type:&#x27;file&#x27;,</span><br><span class="line">        filename:&#x27;logs/all-logs.log&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    error:&#123;</span><br><span class="line">        type: &#x27;dateFile&#x27;,</span><br><span class="line">        filename:&#x27;logs/log&#x27;,</span><br><span class="line">        pattern:&#x27;yyyy-MM-dd.log&#x27;,</span><br><span class="line">        alwaysIncludePattern:true // 设置文件名称是filename+pattern</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><strong>可以看到我们在追加器上，让info和error的日志输出都存到文件里，方便我们查阅和记录，其中error的日志我们用当天的年月日来作为记录，info的日志我们用一个文件来存储就好</strong></p><blockquote><p>categories: 输出种类</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">categories:&#123;</span><br><span class="line">    default: &#123; appenders: [&#x27;console&#x27;], level: &#x27;debug&#x27; &#125;,</span><br><span class="line">    info:&#123;</span><br><span class="line">        appenders: [&#x27;info&#x27;,&#x27;console&#x27;],</span><br><span class="line">        level: &#x27;info&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    error:&#123;</span><br><span class="line">        appenders: [&#x27;error&#x27;,&#x27;console&#x27;],</span><br><span class="line">        level: &#x27;error&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>default默认，这个单词都很熟悉了，默认输出level就是debug，我们自己用来打印东西用的一个输出等级</strong></p><p><strong>我们要注意一下，此时appenders里的我们只能添加上面appenders里定义好的东西。</strong></p><p>下面是三个函数，分别为debug、error、info，将他们导出出去方便使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">exports.debug = (content) =&gt;&#123;</span><br><span class="line">    let logger = log4js.getLogger()</span><br><span class="line">    logger.level = levels.debug</span><br><span class="line">    logger.debug(content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.error = (content) =&gt;&#123;</span><br><span class="line">    let logger = log4js.getLogger(&#x27;error&#x27;)</span><br><span class="line">    logger.level = levels.error</span><br><span class="line">    logger.error(content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> exports.info = (content) =&gt;&#123;</span><br><span class="line">    let logger = log4js.getLogger(&#x27;info&#x27;)</span><br><span class="line">    logger.level = levels.info</span><br><span class="line">    logger.info(content)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后我们去<code>app.js</code>里将原本的日志输出换成我们写好的。位置大约一个在logger那，一个在error那。分别换上我们的info和error就行啦。</p><blockquote><p>记得先引入log4js！</p></blockquote><h3 id="封装工具函数"><a href="#封装工具函数" class="headerlink" title="封装工具函数"></a>封装工具函数</h3><p><strong>工具函数目前具有的功能：</strong></p><ul><li>成功或者失败返回状态码</li><li>初步的分页结构<br>先来定义我们的状态码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const CODE = &#123;</span><br><span class="line">    SUCCESS:200,</span><br><span class="line">    PARAM_ERROR:10001, //参数错误</span><br><span class="line">    USER_ACCOUNT_ERROR:20001, //账号或者密码错误</span><br><span class="line">    USER_LOGIN_ERROR:30001, //用户未登录</span><br><span class="line">    BUSINESS_ERROR:40001, //业务请求失败</span><br><span class="line">    AUTH_ERROR:50001, //认证失败或者TOKEN过期</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>下一个肯定是60001，别猜，我说哒！<br>下面函数均用<code>module.exports</code>导出:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">success(data=&#x27;&#x27;,msg=&#x27;&#x27;,code=CODE.SUCCESS)&#123;</span><br><span class="line">     log4js.debug(data);</span><br><span class="line">     return&#123;</span><br><span class="line">         code,data,msg</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> fail(msg=&#x27;&#x27;,code=CODE.ERROR)&#123;</span><br><span class="line">     log4js.debug(msg);</span><br><span class="line">     return&#123;</span><br><span class="line">         code,data,msg</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>我这里特意将之前日志输出的函数引入过来，在此打印方便我们调试，如果成功的话，应该重点看返回的数据，如果失败的话，我们肯定不返回数据，重点要看当时的<strong>msg</strong>，查明失败原因。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pager(&#123;pageNum=1,pageSize=10&#125;)&#123;</span><br><span class="line">    pageNum*=1;</span><br><span class="line">    pageSize*=1;</span><br><span class="line">    const skipIndex = (pageNum-1)*pageSize;</span><br><span class="line">    return&#123;</span><br><span class="line">        page:&#123;</span><br><span class="line">            pageNum,</span><br><span class="line">            pageSize</span><br><span class="line">        &#125;,</span><br><span class="line">        skipIndex</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>这个函数是分页结构的函数，默认一页是十条数据，利用算数将pageNum和pageSize转换成number类型。</li></ul><p><strong>skipIndex是我们用来查索引的，这里来解释一下：一页十条数据，假如我们现在是第三页，(3-1) * 10=20,所以我们下一个索引就从20开始查起就好了。</strong></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><blockquote><p>1024马上就到了呀，祝愿天下的程序员最近的bug都少一点，头发都多一点！</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这次整理了一些写node中遇到的知识点呀，查缺补漏，才能让自己成长的更稳哦！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最近有在参加蓝桥杯we</summary>
      
    
    
    
    
    <category term="Node.js" scheme="https://wangenze267.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Vue3旅途中的一些小知识</title>
    <link href="https://wangenze267.github.io/posts/809095630.html/"/>
    <id>https://wangenze267.github.io/posts/809095630.html/</id>
    <published>2021-10-17T14:42:19.000Z</published>
    <updated>2021-10-17T14:51:01.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在学习Vue3跟用node koa写后端，此篇文章是记录一些平时学习中的小知识点，未经整理，以后或许会整理一下。</p><blockquote><p>很乱，但有很多都是当时最直接的想法</p><p>整理后也会在此挂上新链接的</p><p>还会一直更新</p></blockquote><h2 id="路由跳转的三种方式"><a href="#路由跳转的三种方式" class="headerlink" title="路由跳转的三种方式"></a>路由跳转的三种方式</h2><h3 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to&quot;/login&quot;&gt;去登陆&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><h3 id="传统跳转（options-API）"><a href="#传统跳转（options-API）" class="headerlink" title="传统跳转（options API）"></a>传统跳转（options API）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;el-button @click=&quot;goLogin&quot;&gt;去登陆&lt;/el-button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">        name:&#x27;home&#x27;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            goLogin()&#123;</span><br><span class="line">this.$router.push(&#x27;/login&#x27;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="Composition-API跳转"><a href="#Composition-API跳转" class="headerlink" title="Composition API跳转"></a>Composition API跳转</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; useRouter &#125; from &#x27;vue-router&#x27;</span><br><span class="line">let router = userRouter()</span><br><span class="line">const goLogin = ()=&gt;&#123;</span><br><span class="line">    router.push(&#x27;/login&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>注意：setup是钩子函数，如果像第三个例子写的话，里面的函数都属于钩子范畴，可以像第二种方式那样，setup类似于methods，完后将它return出去应该也是可以的。</strong></p><h3 id="下面为上面注意中，方法的实现代码"><a href="#下面为上面注意中，方法的实现代码" class="headerlink" title="下面为上面注意中，方法的实现代码"></a>下面为上面注意中，方法的实现代码</h3><p><strong>大体上还是options API的写法，只是setup的思想属于composition API范畴，应该属于框架迁移过程中的写法吧</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-button @click=&quot;goLogin&quot;&gt;去登陆&lt;/el-button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; useRouter &#125; from &#x27;vue-router&#x27;</span><br><span class="line">export default&#123;</span><br><span class="line">  setup()&#123;</span><br><span class="line">    let router = useRouter()</span><br><span class="line">    function goLogin()&#123;</span><br><span class="line">      router.push(&#x27;./login&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123; goLogin &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="封装两种习惯使用request"><a href="#封装两种习惯使用request" class="headerlink" title="封装两种习惯使用request"></a>封装两种习惯使用request</h2><h3 id="this-request-obj"><a href="#this-request-obj" class="headerlink" title="this.$request({ obj })"></a>this.$request({ obj })</h3><p>将参数用一个对象的方式进行解构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$request(&#123;</span><br><span class="line">      <span class="attr">methods</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">      <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;Ned&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p><strong>封装如下</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * axios二次封装</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">&#x27;./../config&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./../router&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ElMessage &#125; <span class="keyword">from</span> <span class="string">&#x27;element-plus&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TOKEN_INVALID = <span class="string">&#x27;Token认证失败，请从新登陆&#x27;</span></span><br><span class="line"><span class="keyword">const</span> NETWORK_ERROR = <span class="string">&#x27;网络请求异常，请稍后重试&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建axios实例对象，添加全局配置</span></span><br><span class="line"><span class="keyword">const</span> service = axios.create(&#123;</span><br><span class="line">     <span class="attr">baseURL</span>:config.baseApi,</span><br><span class="line">     <span class="attr">timeout</span>:<span class="number">8000</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">service.interceptors.request.use(<span class="function">(<span class="params">req</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// to do</span></span><br><span class="line">    <span class="keyword">const</span> headers = req.headers</span><br><span class="line">    <span class="keyword">if</span>(!headers.Authorization) headers.Authorization = <span class="string">&#x27;Bear token&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> req</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">service.interceptors.response.use(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// to do</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注意状态码一共有两个</span></span><br><span class="line"><span class="comment">     * 一为http状态码</span></span><br><span class="line"><span class="comment">     * 二为接口返回状态码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> &#123; code, data, msg &#125; = res.data</span><br><span class="line">    <span class="keyword">if</span>(code === <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(code === <span class="number">40001</span>)&#123;</span><br><span class="line">        ElMessage.error(TOKEN_INVALID)</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            router.push(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">        &#125;, <span class="number">15000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(TOKEN_INVALID)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ElMessage.error(msg || NETWORK_ERROR)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(msg || NETWORK_ERROR)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求核心函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>options  请求配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断get/post</span></span><br><span class="line">    options.method = options.method || <span class="string">&#x27;get&#x27;</span></span><br><span class="line">    <span class="comment">// 防止有时候写了GET</span></span><br><span class="line">    <span class="keyword">if</span>(options.method.toLowerCase() === <span class="string">&#x27;get&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果是get就将data直接赋值给params</span></span><br><span class="line">        <span class="comment">// 类型转换</span></span><br><span class="line">        options.params = options.data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(config.env === <span class="string">&#x27;prod&#x27;</span>)&#123;</span><br><span class="line">        service.defaults.baseURL = config.baseApi</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        service.defaults.baseURL = config.mock ? config.mockApi:config.baseApi</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> service(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> request</span><br></pre></td></tr></table></figure><h3 id="this-request-get-post-‘-api’-obj"><a href="#this-request-get-post-‘-api’-obj" class="headerlink" title="this.$request.get/post(‘/api’,{ obj })"></a>this.$request.get/post(‘/api’,{ obj })</h3><p>将get/post用.的方式取出，一个参数是接口路径，另一个参数是数据对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$request.get(<span class="string">&#x27;/login&#x27;</span>,&#123;<span class="attr">name</span>:Ned&#125;).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>在上一步的封装上，支持这种习惯</p><p><strong>增加如下：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;get&#x27;</span>,<span class="string">&#x27;post&#x27;</span>,<span class="string">&#x27;put&#x27;</span>,<span class="string">&#x27;delete&#x27;</span>,<span class="string">&#x27;patch&#x27;</span>].forEach(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    request[item] = <span class="function">(<span class="params">url,data,options</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request(&#123;</span><br><span class="line">            url,</span><br><span class="line">            data,</span><br><span class="line">            <span class="attr">method</span>:item,</span><br><span class="line">            ...options</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="什么时候用到"><a href="#什么时候用到" class="headerlink" title="什么时候用到"></a>什么时候用到</h3><p>开发环境：mock地址</p><p>测试环境：测试接口的地址</p><p>部署环境：线上接口的地址</p><h3 id="mock的重要性"><a href="#mock的重要性" class="headerlink" title="mock的重要性"></a>mock的重要性</h3><p>前后端分离的时候，mock可以帮助前端利用接口文档测试接口。</p><p>帮助前端完成开发</p><h3 id="配置config"><a href="#配置config" class="headerlink" title="配置config"></a>配置config</h3><p>默认是生产环境 prod，如果有值就赋值到env变量上，当做当前的环境变量。</p><p>最后将EnvConfig以解构的方式导出，方便根据当前环境直接调取两种Api</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> env = <span class="keyword">import</span>.meta.env.MODE || <span class="string">&#x27;prod&#x27;</span></span><br><span class="line"><span class="keyword">const</span> EnvConfig = &#123;</span><br><span class="line">    <span class="attr">dev</span>:&#123;</span><br><span class="line">        <span class="attr">baseApi</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="attr">mockApi</span>:<span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">test</span>:&#123;</span><br><span class="line">        <span class="attr">baseApi</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="attr">mockApi</span>:<span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">prod</span>:&#123;</span><br><span class="line">        <span class="attr">baseApi</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="attr">mockApi</span>:<span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">env</span>:env,</span><br><span class="line">    <span class="attr">mock</span>:<span class="literal">true</span>,</span><br><span class="line">    ...EnvConfig[env]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于Storage使用场景"><a href="#关于Storage使用场景" class="headerlink" title="关于Storage使用场景"></a>关于Storage使用场景</h2><h3 id="jwt-token"><a href="#jwt-token" class="headerlink" title="jwt token"></a>jwt token</h3><p>在登陆时候，有一个状态，以及用token做一些权限、由访问权限等</p><h3 id="跨组件数据共享"><a href="#跨组件数据共享" class="headerlink" title="跨组件数据共享"></a>跨组件数据共享</h3><blockquote><p>跨组件数据共享：</p><p>​    Vue中使用Vuex</p><p>​    React中使用Redux</p></blockquote><p>存在问题：页面刷新后数据丢失</p><p>原因：Vuex存储数据在js内存中，刷新会销毁内存。</p><p>解决方案：Vuex+storage结合去做</p><h3 id="storage存储"><a href="#storage存储" class="headerlink" title="storage存储"></a>storage存储</h3><p>storage存储量：4M</p><p>cookie存储量：2K-4K</p><h3 id="封装storage"><a href="#封装storage" class="headerlink" title="封装storage"></a>封装storage</h3><ul><li>setItem()</li><li>getItem()</li><li>clearItem()</li><li>clearAll()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">&#x27;./../config&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">setItem</span>(<span class="params">key,val</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> storage = <span class="built_in">this</span>.getStorage()</span><br><span class="line">        storage[key] = val</span><br><span class="line">        <span class="built_in">window</span>.localStorage.setItem(config.namespace,<span class="built_in">JSON</span>.stringify(storage))</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">getItem</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getStorage()[key]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">getStorage</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  <span class="built_in">JSON</span>.parse(<span class="built_in">window</span>.localStorage.getItem(config.namespace)) || <span class="string">&quot;&#123;&#125;&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">clearItem</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> storage = <span class="built_in">this</span>.getStorage()</span><br><span class="line">        <span class="keyword">delete</span> storage[key]</span><br><span class="line">        <span class="built_in">window</span>.localStorage.setItem(config.namespace,<span class="built_in">JSON</span>.stringify(storage))</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">clearAll</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.localStorage.clear()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用koa初始化项目"><a href="#使用koa初始化项目" class="headerlink" title="使用koa初始化项目"></a>使用koa初始化项目</h2><h3 id="koa-generator快速生成koa服务的脚手架工具"><a href="#koa-generator快速生成koa服务的脚手架工具" class="headerlink" title="koa-generator快速生成koa服务的脚手架工具"></a>koa-generator快速生成koa服务的脚手架工具</h3><blockquote><p>1.1 全局安装脚手架工具</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g koa-generator </span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span> </span><br><span class="line">yarn global add koa-generator </span><br></pre></td></tr></table></figure><blockquote><p>1.2 进入到项目文件夹目录,执行生成命令</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> koa2+项目名</span></span><br><span class="line">koa2 manager-server</span><br></pre></td></tr></table></figure><blockquote><p>如果无法使用koa2命令，说明需要配置环境变量，window用户，需要找到koa-generator的安装目录，找到里面bin下面的koa2命令文件，然后配置到环境变量中。mac用户可直接创建软连接，指向到/usr/local/bin中，比如：ln -s /Users/Jack/.config/yarn/global/node_modules/koa-generator/bin/koa2 /usr/local/bin/koa2</p></blockquote><blockquote><p>1.3 安装依赖</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install </span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line">cnpm install</span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line">yarn</span><br></pre></td></tr></table></figure><h2 id="使用pm2部署Koa项目并实现启动、关闭、自动重启"><a href="#使用pm2部署Koa项目并实现启动、关闭、自动重启" class="headerlink" title="使用pm2部署Koa项目并实现启动、关闭、自动重启"></a>使用pm2部署Koa项目并实现启动、关闭、自动重启</h2><h3 id="1-全局安装"><a href="#1-全局安装" class="headerlink" title="1. 全局安装"></a><strong>1. 全局安装</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g pm2</span><br></pre></td></tr></table></figure><h3 id="2-启动项目"><a href="#2-启动项目" class="headerlink" title="2. 启动项目"></a><strong>2. 启动项目</strong></h3><blockquote><p>进入项目目录，然后使用pm2启动项目。这里要特别注意：启动<strong>单文件</strong>时用（app.js是项目文件名）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start app.js       #启动单文件</span><br></pre></td></tr></table></figure><blockquote><p>但是在koa2中需要这样启动：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start ./bin/www #启动koa2项目</span><br></pre></td></tr></table></figure><h3 id="3-pm2自动重启"><a href="#3-pm2自动重启" class="headerlink" title="3. pm2自动重启"></a><strong>3. pm2自动重启</strong></h3><blockquote><p>把pm2的服务先停下,然后起来的时候带上–watch就可以了</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start ./bin/www --watch</span><br></pre></td></tr></table></figure><h3 id="4-启动完成，可以访问了"><a href="#4-启动完成，可以访问了" class="headerlink" title="4. 启动完成，可以访问了"></a><strong>4. 启动完成，可以访问了</strong></h3><p><img src="https://segmentfault.com/img/bVbGHD3" alt="pm2启动成功"></p><h3 id="5-pm2相关命令-www是项目名"><a href="#5-pm2相关命令-www是项目名" class="headerlink" title="5. pm2相关命令(www是项目名)"></a><strong>5. pm2相关命令(www是项目名)</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pm2 list           #查看所用已启动项目</span><br><span class="line">pm2 start          #启动</span><br><span class="line">pm2 restart www    #重启</span><br><span class="line">pm2 stop www       #停止</span><br><span class="line">pm2 delete www     #删除</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在学习Vue3跟用node koa写后端，此篇文章是记录一些平时学习中的小知识点，未经整理，以后或许会整理一下。&lt;/p&gt;
&lt;blockq</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://wangenze267.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>一张图让我重学了函数表达式和函数声明</title>
    <link href="https://wangenze267.github.io/posts/1248388575.html/"/>
    <id>https://wangenze267.github.io/posts/1248388575.html/</id>
    <published>2021-10-12T09:45:00.000Z</published>
    <updated>2021-10-12T09:49:13.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天下午，在我们微信群里，学弟突然发出来这样一个图：<br><img src="/posts/1248388575.html/1.webp"></p><p>我点开一看，这不是函数声明跟函数表达式的知识点吗？前一阵子还看过相关文章。</p><p>看了几眼，我说到：<strong>第一个输出应该是最后的函数声明</strong></p><span id="more"></span><p>然后呢？ 没有然后了，真的，犹豫代表着此时的我不会。</p><blockquote><p>看来卷的还不够！</p></blockquote><p>先贴上答案，如果你跟我一样犹豫不决，不知道结果，那么跟我一起再次学习一遍吧。</p><p><img src="/posts/1248388575.html/2.webp"></p><h2 id="开始复习"><a href="#开始复习" class="headerlink" title="开始复习"></a>开始复习</h2><p><strong>首先，确定问题：函数表达式和函数声明的区别，以及困扰住我们的优先问题</strong></p><h3 id="函数声明和函数表达式的区别"><a href="#函数声明和函数表达式的区别" class="headerlink" title="函数声明和函数表达式的区别"></a>函数声明和函数表达式的区别</h3><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>首先我们要知道，当函数声明与变量命名冲突的时候，要保持着<strong>函数声明优先的原则</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(‘fn’);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>例如这样，<strong>不会报错</strong>，会输出fn。</p><blockquote><p>如果你不知道为什么调用函数可以在函数声明之前，看这里</p><p>是因为javascript代码是一段一段预载的，在一段代码预载完成后，会把函数声明提前到代码段的前面执行，以便在代码段的任何地方调用，所以前面的代码无错</p></blockquote><p>那么，多个同名的函数声明，会如何呢？我们接着来看一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(‘<span class="number">1</span>’);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(‘<span class="number">2</span>’);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为2。这是因为有<strong>多个函数声明的时候，是由最后的函数声明来替代前面的</strong></p><blockquote><p>这也是我上文中读了几眼代码直接说第一个输出为最后的函数声明的原因！</p></blockquote><h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn();</span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;fn&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有用过的同学可能看到这里，说我知道，完后写出了上面这段代码，但其实这段代码是不对的，会爆出<code>fn is not a function</code>这个错误。</p><p>这是什么原因呢？这其实就是<strong>函数声明和函数表达式的区别之一</strong></p><p><strong>因为函数表达式相当于把一个函数当做值，赋予一个变量，而这个变量在未声明的时候，是不能使用的</strong></p><p>正确的函数表达式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;fn&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><h2 id="复习回来，再战！"><a href="#复习回来，再战！" class="headerlink" title="复习回来，再战！"></a>复习回来，再战！</h2><p>先把代码贴出来方便阅读：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的代码输出什么</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method</span>(<span class="params">foo</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(foo)</span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span></span><br><span class="line">method(foo)</span><br></pre></td></tr></table></figure><p>经过了上面的复习，我们知道，JavaScript会将函数声明提前，所以我们来整理一下这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method</span>(<span class="params">foo</span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo)</span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">foo()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span></span><br><span class="line">method(foo)</span><br></pre></td></tr></table></figure><p>现在，再利用我们刚刚学的知识，来分析打印的都是什么数据：</p><p>首先，第一个打印的是我们<strong>输出C的foo函数</strong>，第二个和第三个调用foo函数的时候，<strong>函数表达式的变量已经声明</strong>了！所以函数发生了<strong>覆盖</strong>，现在的foo函数已经是<strong>输出B的foo函数</strong>了。</p><p>现在让我们来整理一下结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">B</span><br><span class="line">B</span><br></pre></td></tr></table></figure><p><strong>你学会了吗？没学会快去看看相关知识点！</strong></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>但是犹豫就是不会，不能拿<strong>曾经学过</strong>当做借口，把遇到的每一个自己不会的问题弄懂，才能逐渐让自己变得更强！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天下午，在我们微信群里，学弟突然发出来这样一个图：&lt;br&gt;&lt;img src=&quot;/posts/1248388575.html/1.webp&quot;&gt;&lt;/p&gt;
&lt;p&gt;我点开一看，这不是函数声明跟函数表达式的知识点吗？前一阵子还看过相关文章。&lt;/p&gt;
&lt;p&gt;看了几眼，我说到：&lt;strong&gt;第一个输出应该是最后的函数声明&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://wangenze267.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>简单的了解一下递归</title>
    <link href="https://wangenze267.github.io/posts/3902425944.html/"/>
    <id>https://wangenze267.github.io/posts/3902425944.html/</id>
    <published>2021-10-09T05:47:06.000Z</published>
    <updated>2021-10-11T05:24:05.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在编程中，递归大家肯定都不陌生了吧，今天我们来总结总结有关于递归的东西。</p><blockquote><p>什么？！ 你陌生， 去刷题去，完后你就熟了。</p></blockquote><span id="more"></span><h2 id="递归的定义"><a href="#递归的定义" class="headerlink" title="递归的定义"></a>递归的定义</h2><p><strong>程序调用自身的编程技巧称为递归</strong></p><h2 id="递归长什么样子"><a href="#递归长什么样子" class="headerlink" title="递归长什么样子"></a>递归长什么样子</h2><p>提到举例子我们肯定第一个想到的就是阶乘。</p><blockquote><p>n! = n * (n-1) * (n-2) * …* 1(n&gt;0)</p><p>5! = 5 * 4 * 3 * 2 * 1</p></blockquote><p>阶乘是我们从小学数学就接触的东西，没想到它现在还陪伴着我们🙄</p><p>用代码实现一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursion</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> n * recursion(n - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(recursion(<span class="number">5</span>)) <span class="comment">// 5 * 4 * 3 * 2 * 1 = 120</span></span><br></pre></td></tr></table></figure><p>再举一个例子吧，也是我们初高中课本上的，著名的河内塔问题：</p><img src="/posts/3902425944.html/河内塔.png"><p>这个问题也是用递归来解决的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hanoi</span>(<span class="params"> n, p1, p2, p3</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> == n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;盘子从&#x27;</span> + p1 + <span class="string">&#x27;移动到&#x27;</span> + p3);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">hanoi(n-<span class="number">1</span>, p1, p3, p2);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;盘子从&#x27;</span> + p1 + <span class="string">&#x27;移动到&#x27;</span> + p3);</span><br><span class="line">hanoi(n-<span class="number">1</span>, p2, p1, p3);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">hanoi(<span class="number">3</span>,<span class="string">&#x27;p1&#x27;</span>,<span class="string">&#x27;p2&#x27;</span>,<span class="string">&#x27;p3&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/posts/3902425944.html/%E6%B2%B3%E5%86%85%E5%A1%94%E7%BB%93%E6%9E%9C.png"></p><h2 id="总结一哈"><a href="#总结一哈" class="headerlink" title="总结一哈"></a>总结一哈</h2><p>既然要写递归，就要知道它具备什么条件，从上面的例子不难看出，递归是具有边界条件的，阶乘中的<code>n==1</code>和河内塔中的<code>1==n</code>都是边界条件，递归还具有两个部分，边界条件满足的时候进入返回过程，边界条件不满足的时候，再次进入递归过程。</p><p>那么它还具有什么特点呢？</p><ul><li>它必须有一个出口条件，也就是要有一处作为结束，变成非递归的样子处理。</li><li>递归处理的子问题要同原问题一样，并且逐渐变得简单。</li></ul><p>总结一下：<strong>我们写的递归要具有边界条件，和基于边界条件分别做出的两部分处理过程。</strong></p><blockquote><p>并且使用递归是要逐渐使得问题变得简单，最终用非递归的方法作为结尾哦。</p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我觉得，递归是思考过后对于问题提出的一种解决方案。</p><p>在你提出用递归解决的时候，就已经知道他的边界条件是什么了，只需要写出递归的那部分，随后使用非递归的方式作为程序出口即可。</p><blockquote><p>点个赞，一起学习进步吧♥</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在编程中，递归大家肯定都不陌生了吧，今天我们来总结总结有关于递归的东西。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;什么？！ 你陌生， 去刷题去，完后你就熟了。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="算法/数据结构" scheme="https://wangenze267.github.io/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>关于promise的使用方法</title>
    <link href="https://wangenze267.github.io/posts/3499638177.html/"/>
    <id>https://wangenze267.github.io/posts/3499638177.html/</id>
    <published>2021-10-08T09:19:49.000Z</published>
    <updated>2021-10-11T05:27:02.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>好几天前就想写一个promise的笔记了，但是一直以来就仅仅知道它是用来解决回调地狱问题的，没有一个详细的了解，所以在这几天学习的时候，针对它名下的几个方法，做了一个简要的使用介绍。</p><blockquote><p>promise：这就是我的说明书！</p><p>我：可能说的不是太全，多包涵~</p></blockquote><span id="more"></span><h2 id="先来了解一下它"><a href="#先来了解一下它" class="headerlink" title="先来了解一下它"></a>先来了解一下它</h2><p>什么是promise？它是一个类？一个对象？一个数组？</p><p>我们先打印它来看一看吧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.dir(<span class="built_in">Promise</span>);</span><br></pre></td></tr></table></figure><img src="/posts/3499638177.html/认识promise.png" style="zoom:60%;"><p>打印完了，我们来正式认识一下它。</p><p><strong>promise</strong>是一个构造函数，是ES6提出的异步编程解决方案，用来解决<strong>回调地狱</strong>这种问题，从打印可以看出，它有<code>reject</code>、<code>all</code>、<code>resolve</code>等方法，它的原型上有<code>catch</code>、<code>then</code>等方法。</p><p><strong>还有一种说法来自于网络：</strong>promise，意为承诺，承诺过一段时间给你结果。promise有三种状态，分别为pending（等待），fulfiled（成功），rejected（失败），状态一旦经过改变，就不会在变。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn1执行，如果a&gt;10 执行fn2 ，如果a == 11，执行fn3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">a, fn2</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">10</span> &amp;&amp; <span class="keyword">typeof</span> fn2 == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    fn2(a,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">11</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;this is fn3&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fn1(<span class="number">11</span>, <span class="function"><span class="keyword">function</span>(<span class="params">a, fn3</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;this is fn2&#x27;</span>)</span><br><span class="line">    fn3()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面说了promise的提出是用来解决回调地狱的问题，那么什么是回调地狱呢？可以参考一下我这段代码，不断的嵌套回调函数之后，代码就会变得非常繁琐，看代码的时候眼睛不舒服，脑子也不舒服，这种嵌套回调非常多的情况，就叫做<strong>回调地狱</strong>。</p><h2 id="如何使用promise"><a href="#如何使用promise" class="headerlink" title="如何使用promise"></a>如何使用promise</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//做一些异步操作</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;执行完成&#x27;</span>);</span><br><span class="line">        resolve(<span class="string">&#x27;写啥都行&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Promise的构造函数接收一个function，并且这个函数需要传入两个参数：</p><ul><li>resolve ：异步操作执行成功后的回调函数</li><li>reject：异步操作执行失败后的回调函数</li></ul><h3 id="then"><a href="#then" class="headerlink" title="then"></a>then</h3><p>还记得上面我写的那个嵌套非常多的例子吗？啊，不记得，那你翻一翻~</p><p>Promise的优势就在于，可以在<code>then</code>方法中继续写Promise对象并返回，然后继续调用then来进行回调操作。</p><p>所以，从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。所以使用Promise的正确场景是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//做一些异步操作</span></span><br><span class="line">       resolve(a);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;            </span><br><span class="line">&#125;</span><br><span class="line">fn1(<span class="number">11</span>)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">10</span>)&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;a大于10&#x27;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   resolve(a);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">11</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a等于11&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>我将上面那个改写了一下。最后那个没有return出来是我后面没有继续then了。</p></blockquote><p>这其实就是链式写法。then就相当于我们之前的callback。</p><p>then方法中，不光可以return promise对象，也可以return数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//做一些异步操作</span></span><br><span class="line">       resolve(a);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;            </span><br><span class="line">&#125;</span><br><span class="line">fn1(<span class="number">11</span>)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">10</span>)&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;a大于10&#x27;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> a</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">11</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a等于11&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h3><p>把promise的状态从<code>pending</code>改成<code>rejected</code>，之后我们就可以在<code>then</code>中执行失败情况的回调，来看这个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(a&gt;<span class="number">10</span>)&#123;</span><br><span class="line">       resolve(a);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">       reject(a);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;            </span><br><span class="line">&#125;</span><br><span class="line">fn1(<span class="number">9</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a大于10&#x27;</span>)</span><br><span class="line">&#125;,<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a小于10&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>then可以接收两个参数，分别对应着resolve的回调和reject的回调，所以在调整传入的a的值，我们可以得到两个结果。</strong></p><blockquote><p>即a大于10和a小于10</p></blockquote><h3 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h3><p>对其他语言有了解的人应该可以知道，catch是用来抓取异常的，那么在promise里，它的作用也一样，<strong>它就如同then的第二个参数，对应着reject的回调</strong></p><p>写法是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.then(<span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a大于10&#x27;</span>)</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a小于10&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>效果和写在then的第二个参数里面是一样的。</p><p>不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死进程，而是会进到这个catch方法中。</p><blockquote><p>就很像 try catch </p></blockquote><p>再来看这段代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//做一些异步操作</span></span><br><span class="line">       resolve(a);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;            </span><br><span class="line">&#125;</span><br><span class="line">fn1(<span class="number">11</span>)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">10</span>)&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;a大于10&#x27;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> b</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;发生了错误:&#x27;</span> + err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这段代码中 本来想return a的 结果写成了b，正常来说浏览器会报错，不会向下执行了，在我们用了catch后，</p><p>浏览器会打印出<strong>a大于10</strong>和<strong>发生了错误:ReferenceError: b is not defined</strong>。</p><p>也就是说即使是上面出错了，还是进到catch方法里面去了，而且把错误原因传到了err参数中，使得程序继续执行下去。</p><h3 id="all"><a href="#all" class="headerlink" title="all"></a>all</h3><p>all方法提供了多个任务并行，执行异步操作的能力，并且在所有异步操作执行完后才执行回调。</p><ul><li>all方法接收的参数是一个数组，其中每个对象都是promise</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.all([fn1, fn2, fn3])</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="title">funciton</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 三个都成功则成功  </span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 只要有一个失败，则失败 </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>有了all，我们就可以并行执行多个异步操作，有一个场景是很适合用这个的，打开一个网页，需要加载各类资源，所有的都加载完后，我们再进行页面的初始化。</p><h3 id="race"><a href="#race" class="headerlink" title="race"></a>race</h3><p>all方法的效果实际上是<strong>谁跑的慢，以谁为准执行回调</strong>，那么相对的就有另一个方法<strong>谁跑的快，以谁为准执行回调</strong>，这就是race方法，这个词本来就是赛跑的意思。</p><p>拿上面的fn123举例子，假如他们分别是1、2、3秒执行完，那么在第一秒结束的时候就会输出fn1执行后的结果，在两秒跟三秒的时候会分别输出fn2、fn3的结果。</p><p>这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作。</p><p>例如图片请求，我们将一个延迟请求（假如是3秒）跟图片请求同时使用race方法调用，在3秒的时候如果请求成功了，就会resolve进入then方法，如果失败了就会进入catch方法输出图片资源请求失败的错误。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>十一的假期结束了，上学人又要继续上课了，害。</p><blockquote><p>点个赞，一起努力进步吧♥</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;好几天前就想写一个promise的笔记了，但是一直以来就仅仅知道它是用来解决回调地狱问题的，没有一个详细的了解，所以在这几天学习的时候，针对它名下的几个方法，做了一个简要的使用介绍。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;promise：这就是我的说明书！&lt;/p&gt;
&lt;p&gt;我：可能说的不是太全，多包涵~&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="ES6" scheme="https://wangenze267.github.io/tags/ES6/"/>
    
    <category term="JavaScript" scheme="https://wangenze267.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>用那么久this了，来详细了解一下</title>
    <link href="https://wangenze267.github.io/posts/724479206.html/"/>
    <id>https://wangenze267.github.io/posts/724479206.html/</id>
    <published>2021-10-06T00:00:15.000Z</published>
    <updated>2021-10-11T05:25:41.351Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>this想必大家都很不陌生了，在例如<code>Vue.js</code>中，各种this，唰唰唰的写，但是有没有遇到this指向出错的问题呢？</p><p>我有，我猜应该也会有人跟我一样。</p><p>所以，我总结了一些this的基础概念和基本使用在这里，供大家参考。</p><span id="more"></span><h2 id="this出现在哪里"><a href="#this出现在哪里" class="headerlink" title="this出现在哪里"></a>this出现在哪里</h2><p><strong>全局上下文中的this</strong></p><p>console.log(this)来打印出来全局执行上下文中的 this，最终输出的是 window 对象。</p><p>所以可以得出这样一个结论：全局执行上下文中的 this 是指向 window 对象的。这也是 this 和作用域链的唯一交点，作用域链的最底端包含了 window 对象，全局执行上下文中的 this 也是指向 window 对象</p><p><strong>函数上下文中的this</strong></p><p>在全局环境中调用一个函数，函数内部的 this 指向的是全局变量 window。</p><p>通过一个对象来调用其内部的一个方法，该方法的执行上下文中的 this 指向对象本身</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;;</span><br><span class="line">foo(); <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line"><span class="attr">b</span>:<span class="number">0</span>,</span><br><span class="line"><span class="attr">fn</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a.fn(); <span class="comment">//&#123; b:0, fn:f() &#125;</span></span><br></pre></td></tr></table></figure><h2 id="this指向总结"><a href="#this指向总结" class="headerlink" title="this指向总结"></a>this指向总结</h2><ul><li><p>当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window；</p></li><li><p>通过一个对象来调用其内部的一个方法，该方法的执行上下文中的 this 指向对象本身</p></li><li><p>ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数</p></li><li><p>new 关键字构建好了一个新对象，并且构造函数中的 this 其实就是新对象本身</p></li><li><p>嵌套函数中的 this 不会继承外层函数的 this 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123; </span><br><span class="line"><span class="attr">name</span> : <span class="string">&quot;Ned&quot;</span>, </span><br><span class="line"><span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// myObj</span></span><br><span class="line">        <span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;阿泽&quot;</span>; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// window</span></span><br><span class="line">        &#125; </span><br><span class="line">        bar(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">myObj.showThis();</span><br><span class="line"><span class="built_in">console</span>.log(myObj.name); <span class="comment">// Ned</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">// 阿泽</span></span><br></pre></td></tr></table></figure><ul><li><p>解决this不继承的方法</p><ul><li>内部函数使用箭头函数</li><li>将在外层函数中创建一个变量，用来存储this，内层函数通过作用域链即可访问</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123; </span><br><span class="line"><span class="attr">name</span> : <span class="string">&quot;Ned&quot;</span>, </span><br><span class="line"><span class="attr">showThis</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// myObj</span></span><br><span class="line">        <span class="keyword">var</span> bar = <span class="function">()=&gt;</span>&#123; </span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;阿泽&quot;</span>; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// window</span></span><br><span class="line">        &#125; </span><br><span class="line">        bar(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">myObj.showThis();</span><br><span class="line"><span class="built_in">console</span>.log(myObj.name); <span class="comment">// 阿泽</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">//  </span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123; </span><br><span class="line"><span class="attr">name</span> : <span class="string">&quot;Ned&quot;</span>, </span><br><span class="line"><span class="attr">showThis</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// myObj</span></span><br><span class="line">        <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; </span><br><span class="line">        self.name = <span class="string">&quot;阿泽&quot;</span>; </span><br><span class="line">        <span class="built_in">console</span>.log(self) <span class="comment">// window</span></span><br><span class="line">        &#125; </span><br><span class="line">        bar(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">myObj.showThis();</span><br><span class="line"><span class="built_in">console</span>.log(myObj.name); <span class="comment">// 阿泽</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">// </span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="改变this指向的方法"><a href="#改变this指向的方法" class="headerlink" title="改变this指向的方法"></a>改变this指向的方法</h2><h3 id="call-和-apply-的共同点"><a href="#call-和-apply-的共同点" class="headerlink" title="call 和 apply 的共同点"></a>call 和 apply 的共同点</h3><p>都能够<strong>改变函数执行时的上下文</strong>，将一个对象的方法交给另一个对象来执行，并且是立即执行的</p><blockquote><p><strong>调用 call 和 apply 的对象，必须是一个函数 Function</strong></p></blockquote><h3 id="call-和-apply-的区别"><a href="#call-和-apply-的区别" class="headerlink" title="call 和 apply 的区别"></a>call 和 apply 的区别</h3><h4 id="call-的写法"><a href="#call-的写法" class="headerlink" title="call 的写法"></a>call 的写法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.call(obj,param1,param2,...)</span><br></pre></td></tr></table></figure><p>需要注意以下几点：</p><ul><li>调用 call 的对象，必须是个函数 Function。</li><li>call 的第一个参数，是一个对象。 Function 的调用者，将会指向这个对象。如果不传，则默认为全局对象 window。</li><li>第二个参数开始，可以接收任意个参数。每个参数会映射到相应位置的 Function 的参数上。但是如果将所有的参数作为数组传入，它们会作为一个整体映射到 Function 对应的第一个参数上，之后参数都为空。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span> (<span class="params">a,b,c</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">func.call(obj, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">// func 接收到的参数实际上是 1,2,3</span></span><br><span class="line"></span><br><span class="line">func.call(obj, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment">// func 接收到的参数实际上是 [1,2,3],undefined,undefined</span></span><br><span class="line"><span class="comment">// 其实func还是接收了三个参数，只不过咱们只传了一个过去，这个应该很容易理解的</span></span><br></pre></td></tr></table></figure><h4 id="apply-的写法"><a href="#apply-的写法" class="headerlink" title="apply 的写法"></a>apply 的写法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function.apply(obj[,argArray])</span><br></pre></td></tr></table></figure><p><strong>需要注意的是：</strong></p><ul><li>它的调用者必须是函数 Function，并且只接收两个参数，第一个参数的规则与 call 一致。</li><li>第二个参数，必须是数组或者类数组，它们会被转换成类数组，传入 Function 中，并且会被映射到 Function 对应的参数上。这也是 call 和 apply 之间，很重要的一个区别。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func.apply(obj, [1,2,3])</span><br><span class="line">// func 接收到的参数实际上是 1,2,3</span><br><span class="line"></span><br><span class="line">func.apply(obj, &#123;</span><br><span class="line">    0: 1,</span><br><span class="line">    1: 2,</span><br><span class="line">    2: 3,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;)</span><br><span class="line">// func 接收到的参数实际上是 1,2,3</span><br></pre></td></tr></table></figure><h3 id="call-和-apply-的用途"><a href="#call-和-apply-的用途" class="headerlink" title="call 和 apply 的用途"></a>call 和 apply 的用途</h3><p>下面会分别列举 call 和 apply 的一些使用场景。</p><blockquote><p>声明：例子中没有哪个场景是必须用 call 或者必须用 apply 的，看个人习惯就好。</p></blockquote><h4 id="call-的使用场景"><a href="#call-的使用场景" class="headerlink" title="call 的使用场景"></a>call 的使用场景</h4><p><strong>对象的继承</strong>如下面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">superClass</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subClass</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    superClass.call(<span class="built_in">this</span>);  <span class="comment">// 执行superClass，并将superClass方法中的this指向subClass</span></span><br><span class="line">    <span class="built_in">this</span>.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subClass();</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>subClass 通过 call 方法，继承了 superClass 的 print 方法和 a 变量。</p><p>此外，subClass 还可以扩展自己的其他方法。</p><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><h4 id="bind-的用法"><a href="#bind-的用法" class="headerlink" title="bind 的用法"></a>bind 的用法</h4><p>在 MDN 上的解释是：bind() 方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。</p><p>它的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function.bind(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure><p>bind 方法 与 apply 和 call 比较类似，也能改变函数体内的 this 指向。</p><p>不同的是，<strong>bind 方法的返回值是函数，并且需要稍后调用，才会执行</strong>。</p><p>而 apply 和 call 则是立即调用，来看下面这个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function add (c) &#123;</span><br><span class="line">    return this.a + this.b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;a:1,b:2&#125;</span><br><span class="line"></span><br><span class="line">add.bind(obj, 5); // 这时，并不会返回 8</span><br><span class="line">add.bind(sub, 5)(); // 调用后，返回 8</span><br></pre></td></tr></table></figure><p>如果 bind 的第一个参数是 null 或者 undefined，this 就指向全局对象 window。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>“abc”的使用，具体还是要看个人运用，理解了之后，那它们就变成了工具，怎么顺手怎么来了~</p><p>顺便说一下本人，我还是喜欢apply多一点hhh，用它的次数多一点，所以在场景用谁都行的时候，我一般都会选择apply。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;this想必大家都很不陌生了，在例如&lt;code&gt;Vue.js&lt;/code&gt;中，各种this，唰唰唰的写，但是有没有遇到this指向出错的问题呢？&lt;/p&gt;
&lt;p&gt;我有，我猜应该也会有人跟我一样。&lt;/p&gt;
&lt;p&gt;所以，我总结了一些this的基础概念和基本使用在这里，供大家参考。&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://wangenze267.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>网络安全 | XSS基础知识</title>
    <link href="https://wangenze267.github.io/posts/1710773078.html/"/>
    <id>https://wangenze267.github.io/posts/1710773078.html/</id>
    <published>2021-10-05T14:26:37.000Z</published>
    <updated>2021-10-11T05:25:20.403Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天又到了我最喜欢的东西，一些网络安全有关的东西。</p><blockquote><p>小时候就特别喜欢黑客，觉得特帅~ </p><p>大学报计算机相关专业可能也是这方面的原因，但是阴差阳错，没有走网络安全的方向。</p></blockquote><p>今天来说一说，XSS攻击的事情，我有幸，曾经用php搭建的博客（typecho），被我同学挂了脚本，xss了一下，完后，什么什么的，啊，你们懂得。</p><p>从那以后，我就知道，网络安全，是不可避免的，是一定要考虑到的，是一定要去了解的东西。</p><blockquote><p>身处网络时代，谁又能置身事外！</p></blockquote><span id="more"></span><h3 id="什么是xss攻击？"><a href="#什么是xss攻击？" class="headerlink" title="什么是xss攻击？"></a>什么是xss攻击？</h3><p>XSS又叫CSS（Cross Site Script），跨站脚本攻击：指恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。</p><img src="/posts/1710773078.html/image-20210617162454870.png" alt="image-20210617162454870" style="zoom: 33%;"><p>那么，当当前的网页弹出1的时候，我们就知道，这个网页是可以执行js脚本的了，那么我们是不是就可以通过document去盗取一些信息，来帮助我们<strong>更进一步</strong>的去潜入进去呢？例如盗取一下cookie等。</p><p><strong>先来看一下XSS有几种吧</strong>：</p><ul><li><strong>持久型</strong>：一些可以提交的地方，文章评论，个人信息填写等，如果没有加过滤的话，嵌入的脚本就会被提交到服务器上，之后用户每次访问都会触发脚本（例如图中的alert(1)，每个用户打开都会弹出1）</li><li><strong>非持久型</strong>：反射型跨站脚本漏洞，是最普遍的类型。大多是链接的方式，需要用户点击，才能返回脚本进行操作（用户访问服务器–&gt;点击跨站链接—&gt;返回脚本代码）</li><li><strong>DOM型</strong>：客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM XSS漏洞（很少见emm，反正我没见过hhh，日后见到了来补上，再细说）</li></ul><h3 id="XSS可能会带来的危害"><a href="#XSS可能会带来的危害" class="headerlink" title="XSS可能会带来的危害"></a>XSS可能会带来的危害</h3><p><strong>使网页无法正常运行</strong>：这个就是我们上面中图示的内容，如果不仅仅是一个<code>alert(1)</code>呢？外部来一个永久循环，这个网页的弹窗就会永远关不掉，导致无法正常的实现整体业务流程。</p><p><strong>获取cookie信息</strong>：这个我们也在上文中说过，如果网页上可以执行js脚本的话，那么我们是可以通过<code>document.cookie</code>来实现获取用户cookie的。</p><blockquote><p>试想下如果像QQ空间说说中能够写入xss攻击语句，那岂不是看了你说说的人的号你都可以登录</p><p>一个字：爽~</p></blockquote><p><strong>劫持流量恶意跳转</strong>：</p><p>像这样，在网页中想办法插入一句像这样的语句，访问的网页就会直接跳转到百度去。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">window</span>.location.href=<span class="string">&quot;http://www.baidu.com&quot;</span>;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="XSS的攻击应该具备这样的条件"><a href="#XSS的攻击应该具备这样的条件" class="headerlink" title="XSS的攻击应该具备这样的条件"></a>XSS的攻击应该具备这样的条件</h3><p>网页内部有输入框，内容可存储在服务器上</p><p>输入框内的内容，才能被<strong>提交</strong>到他的服务器上，才能改变这个网页内部的文件内容。</p><blockquote><p>前提是这个输入，没有被过滤，才会成功哦！</p><p>可以自己写demo尝试一下，不建议直接在网络上开搞emm，自己玩玩就行哈~</p></blockquote><h3 id="XSS防御措施（对用户输入内容和服务端返回内容进行过滤和转译）"><a href="#XSS防御措施（对用户输入内容和服务端返回内容进行过滤和转译）" class="headerlink" title="XSS防御措施（对用户输入内容和服务端返回内容进行过滤和转译）"></a><strong>XSS防御措施（对用户输入内容和服务端返回内容进行过滤和转译）</strong></h3><p><strong>现代大部分浏览器都自带 XSS 筛选器</strong>（vue/react等主流框架已经避免类似问题，vue举例：不能在template中写script标签，无法在js中通过ref或append等方式动态改变或添加script标签）</p><p><strong>过滤</strong>，对诸如<strong>script</strong>、<strong>img</strong>、<strong>a</strong>等标签进行过滤。</p><p><strong>编码</strong>，像一些常见的符号，如&lt;&gt;在输入的时候要对其进行转换编码，这样做浏览器是不会对该标签进行解释执行的，同时也不影响显示效果。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>学习网络安全是为了保护好自己，在这个网络时代，避免自己的信息被不法分子盗取，而不是说我们学会如何去<strong>攻击别人</strong>。</p><blockquote><p> 还有更多的网络安全知识等着我们去学习呢，冲！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;今天又到了我最喜欢的东西，一些网络安全有关的东西。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;小时候就特别喜欢黑客，觉得特帅~ &lt;/p&gt;
&lt;p&gt;大学报计算机相关专业可能也是这方面的原因，但是阴差阳错，没有走网络安全的方向。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天来说一说，XSS攻击的事情，我有幸，曾经用php搭建的博客（typecho），被我同学挂了脚本，xss了一下，完后，什么什么的，啊，你们懂得。&lt;/p&gt;
&lt;p&gt;从那以后，我就知道，网络安全，是不可避免的，是一定要考虑到的，是一定要去了解的东西。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;身处网络时代，谁又能置身事外！&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="网络安全" scheme="https://wangenze267.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的继承，原型和原型链</title>
    <link href="https://wangenze267.github.io/posts/2566346867.html/"/>
    <id>https://wangenze267.github.io/posts/2566346867.html/</id>
    <published>2021-10-04T04:26:58.000Z</published>
    <updated>2021-10-11T05:21:59.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想必，学过 java 和 C++ 的小伙伴们，对于继承这个词应该不陌生，最近我也是一直在巩固JavaScript的知识，今天就来一起学习一下JavaScript里的继承吧。</p><span id="more"></span><h2 id="继承是什么？"><a href="#继承是什么？" class="headerlink" title="继承是什么？"></a>继承是什么？</h2><p>首先我们要明确继承的概念：</p><p><strong>继承就是一个对象可以访问另外一个对象中的属性和方法</strong></p><img src="/posts/2566346867.html/01.png" alt="image-20210617142202137" style="zoom: 50%;"><p>B继承了A，所以B也有A具有的<code>color</code>属性，这个是不是我们接触CSS的时候，会有样式继承这个东西，可以这么理解一下下~</p><h2 id="继承的目的？"><a href="#继承的目的？" class="headerlink" title="继承的目的？"></a>继承的目的？</h2><p>继承的目的我觉得殊途同归，都是实现了父类的设计，并且进行代码复用。</p><h2 id="继承的方式"><a href="#继承的方式" class="headerlink" title="继承的方式"></a>继承的方式</h2><p>java、c++等：java是通过<code>class</code>类，C++是通过<code>:</code></p><p>而我们的JavaScript，是通过<strong>原型链</strong> ，ES2015/ES6 中引入了 class 关键字，但那只是语法糖，JavaScript 的继承依然和基于类的继承没有一点关系。</p><h2 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h2><p><strong>JavaScript 只有一种结构：对象。</strong></p><p>JavaScript 的每个对象都包含了一个隐藏属性__proto__，我们就把该隐藏属性 <strong>proto</strong> 称之为该<strong>对象的原型</strong> (prototype)，<strong>proto</strong> 指向了内存中的另外一个对象，我们就把 <strong>proto</strong> 指向的对象称为该<strong>对象的原型</strong>，那么该对象就可以直接访问其原型对象的方法或者属性。</p><p><img src="/posts/2566346867.html/02.png" alt="image-20210617143041487"></p><p>我们可以看到使用 C.name 和 C.color 时，给人的感觉属性 <code>name</code> 和 <code>color</code> 都是对象 C 本身的属性，但实际上这些属性都是位于原型对象上，我们把这个查找属性的路径称为<strong>原型链</strong></p><p>每个实例对象（ <strong>object</strong> ）都有一个私有属性（称之为 <strong>proto</strong> ）指向它的构造函数的原型对象（<strong>prototype</strong> ）。该原型对象也有一个自己的原型对象( <strong>proto</strong> ) ，层层向上直到一个对象的原型对象为 <code>null</code>。根据定义，<code>null</code> 没有原型，并作为这个<strong>原型链</strong>中的最后一个环节。</p><blockquote><p>查到到null，证明链子到头啦~</p></blockquote><p>总结一下：<strong>继承</strong>就是一个对象可以访问另外一个对象中的属性和方法，在JavaScript 中，我们通过<strong>原型和原型链</strong>的方式来实现了继承特性。</p><h2 id="继承的方式-1"><a href="#继承的方式-1" class="headerlink" title="继承的方式"></a>继承的方式</h2><h3 id="构造函数如何创建对象"><a href="#构造函数如何创建对象" class="headerlink" title="构造函数如何创建对象"></a>构造函数如何创建对象</h3><blockquote><p>有一点java基础的看这块会不会特别得劲~，我当初是学过java之后接触到的这个概念，就很顺利的就理解了。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DogFactory</span>(<span class="params">type, color</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">    <span class="built_in">this</span>.color = color</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> DogFactory(<span class="string">&#x27;Dog&#x27;</span>,<span class="string">&#x27;Black&#x27;</span>)</span><br></pre></td></tr></table></figure><p>创建实例的过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dog = &#123;&#125;;</span><br><span class="line">dog.__proto__ = DogFactory.prototype;</span><br><span class="line">DogFactory.call(dog,<span class="string">&#x27;Dog&#x27;</span>,<span class="string">&#x27;Black&#x27;</span>);</span><br></pre></td></tr></table></figure><img src="/posts/2566346867.html/03.png" alt="image-20210617153157853" style="zoom: 33%;"><p>观察这个图，我们可以看到执行流程分为三步：</p><ul><li><p><strong>首先，创建了一个空白对象 dog；</strong></p></li><li><p><strong>然后，将 DogFactory 的 prototype 属性设置为 dog 的原型对象，这就是给 dog 对象设置原型对象的关键一步；</strong></p></li><li><p><strong>最后，再使用 dog 来调用 DogFactory，这时候 DogFactory 函数中的 this 就指向了对象 dog，然后在 DogFactory 函数中，利用 this 对对象 dog 执行属性填充操作，最终就创建了对象 dog。</strong></p></li></ul><blockquote><p>每个函数对象中都有一个公开的 prototype 属性，当你将这个函数作为构造函数来创建一个新的对象时，新创建对象的原型对象就指向了该函数的 prototype 属性，所以通过该构造函数创建的任何实例都可以通过原型链找到构造函数的prototype上的属性</p></blockquote><p><strong>实例的proto属性 ==  构造函数的proyotype</strong></p><p>也就是说<strong>dog.__proto == DogFactory.prototype</strong></p><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p><strong>原理：</strong> 实现的本质是<strong>将子类的原型指向了父类的实例</strong></p><p><strong>优点：</strong></p><ul><li>父类新增原型方法/原型属性，子类都能访问到</li><li>简单容易实现</li></ul><p><strong>缺点：</strong></p><ul><li>不能实现多重继承</li><li>来自原型对象的所有属性被所有实例共享</li><li>创建子类实例时，无法向父类构造函数传参</li></ul><img src="/posts/2566346867.html/image-20210617154553631.png" alt="image-20210617154553631" style="zoom:50%;"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name,</span><br><span class="line">    <span class="built_in">this</span>.age = age,</span><br><span class="line">    <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="built_in">this</span>.setName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"><span class="comment">//子类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.price = price</span><br><span class="line">    <span class="built_in">this</span>.setScore = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person(<span class="string">&#x27;wang&#x27;</span>,<span class="number">23</span>) <span class="comment">// 子类型的原型为父类型的一个实例对象</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Student(<span class="number">15000</span>)</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> Student(<span class="number">14000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1,s2)</span><br></pre></td></tr></table></figure><h3 id="借用构造函数实现继承"><a href="#借用构造函数实现继承" class="headerlink" title="借用构造函数实现继承"></a>借用构造函数实现继承</h3><p><strong>原理</strong>：在子类型构造函数中通用call()调用父类型构造函数</p><p><strong>特点</strong>：</p><ul><li>解决了原型链继承中子类实例共享父类引用属性的问题</li><li>创建子类实例时，可以向父类传递参数</li><li>可以实现多重继承(call多个父类对象)</li></ul><p><strong>缺点</strong>：</p><ul><li>实例并不是父类的实例，只是子类的实例</li><li>只能继承父类的实例属性和方法，不能继承父类原型属性和方法</li><li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name,</span><br><span class="line">    <span class="built_in">this</span>.age = age,</span><br><span class="line">    <span class="built_in">this</span>.setName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Person.prototype.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="built_in">this</span>, name, age) </span><br><span class="line">    <span class="comment">// 相当于: </span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    this.Person(name, age)</span></span><br><span class="line"><span class="comment">    this.name = name</span></span><br><span class="line"><span class="comment">    this.age = age*/</span></span><br><span class="line">    <span class="built_in">this</span>.price = price</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> s1 = <span class="keyword">new</span> Student(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">20</span>, <span class="number">15000</span>)</span><br></pre></td></tr></table></figure><h3 id="原型链-借用构造函数的组合继承"><a href="#原型链-借用构造函数的组合继承" class="headerlink" title="原型链+借用构造函数的组合继承"></a>原型链+借用构造函数的组合继承</h3><p><strong>原理</strong>：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用。</p><p><strong>优点</strong>：</p><ul><li>可以继承实例属性/方法，也可以继承原型属性/方法</li><li>不存在引用属性共享问题</li><li>可传参</li><li>父类原型上的函数可复用</li></ul><p><strong>缺点</strong>：</p><ul><li>调用了两次父类构造函数，生成了两份实例</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name,</span><br><span class="line">    <span class="built_in">this</span>.age = age,</span><br><span class="line">    <span class="built_in">this</span>.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="built_in">this</span>,name,age)</span><br><span class="line">    <span class="built_in">this</span>.price = price</span><br><span class="line">    <span class="built_in">this</span>.setScore = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person()</span><br><span class="line">Student.prototype.constructor = Student<span class="comment">//组合继承也是需要修复构造函数指向的</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Student(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">20</span>, <span class="number">15000</span>)</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> Student(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">22</span>, <span class="number">14000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1)</span><br><span class="line"><span class="built_in">console</span>.log(s1.constructor) <span class="comment">//Student</span></span><br></pre></td></tr></table></figure><h3 id="ES6-class继承"><a href="#ES6-class继承" class="headerlink" title="ES6 class继承"></a>ES6 class继承</h3><p><strong>原理：</strong> ES6中引入了class关键字，class可以通过extends关键字实现继承，还可以通过static关键字定义类的静态方法,这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p><blockquote><p>我当时第一次见的时候，还以为是java</p><p>其实我还是觉得，class写起来得劲多了，哈哈哈</p></blockquote><p><strong>优点</strong>：</p><ul><li>语法简单易懂,操作更方便</li></ul><p><strong>缺点</strong>：</p><ul><li>并不是所有的浏览器都支持class关键字</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用类的构造方法</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">        <span class="built_in">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一般的方法</span></span><br><span class="line">    <span class="function"><span class="title">showName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;调用父类的方法&quot;</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name, <span class="built_in">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span>  Person(<span class="string">&#x27;kobe&#x27;</span>, <span class="number">39</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1)</span><br><span class="line"><span class="comment">//定义一个子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, age, salary</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age)<span class="comment">//通过super调用父类的构造方法</span></span><br><span class="line">        <span class="built_in">this</span>.salary = salary</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">showName</span>(<span class="params"></span>)</span> &#123;<span class="comment">//在子类自身定义方法</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;调用子类的方法&quot;</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name, <span class="built_in">this</span>.age, <span class="built_in">this</span>.salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> Student(<span class="string">&#x27;wade&#x27;</span>, <span class="number">38</span>, <span class="number">1000000000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1)</span><br><span class="line">s1.showName()</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>其实我没有在平时写的项目中，用过继承，所以不太懂具体的应用场景，希望大佬们可以指点一下。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;想必，学过 java 和 C++ 的小伙伴们，对于继承这个词应该不陌生，最近我也是一直在巩固JavaScript的知识，今天就来一起学习一下JavaScript里的继承吧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://wangenze267.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>学会这些，再也不怕水平垂直居中了</title>
    <link href="https://wangenze267.github.io/posts/4281072405.html/"/>
    <id>https://wangenze267.github.io/posts/4281072405.html/</id>
    <published>2021-10-03T06:26:56.000Z</published>
    <updated>2021-10-11T05:25:35.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天来看看一个之前困扰我很久的问题，在CSS中，水平垂直居中，能有几种写法。</p><h2 id="方法一：margin-auto"><a href="#方法一：margin-auto" class="headerlink" title="方法一：margin:auto"></a>方法一：margin:auto</h2><p>子绝父相，当元素绝对定位的时候，会根据最近父元素进行定位，利用这个特性，我们有了这种方法。</p><span id="more"></span><p>CSS代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTML代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;avatar.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果图：</p><img src="/posts/4281072405.html/marginauto.png" style="zoom:60%;"><h2 id="方法二：flex弹性盒子法"><a href="#方法二：flex弹性盒子法" class="headerlink" title="方法二：flex弹性盒子法"></a>方法二：flex弹性盒子法</h2><p>利用flex，<code>align-items:center</code>是控制垂直方向居中，<code>justify-content:center</code>是控制水平方向的居中。</p><p>CSS代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTML代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;avatar.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果图：</p><img src="/posts/4281072405.html/marginauto.png" style="zoom:60%;"><h2 id="方法三：margin-负数法"><a href="#方法三：margin-负数法" class="headerlink" title="方法三：margin:负数法"></a>方法三：margin:负数法</h2><p>margin可以为负数是我在牛客上报了个课之后才学到的，在那之前一直没有试过。</p><p>道理其实跟方法一差不多，通过百分比将图片移动到容器中心，再对齐中心点就行了。</p><p>要记住margin如果是负数的话就是向该方向移动，例如margin-left:-100px;，就是向左移动100px。它与正常添加margin是撑开正好相反。</p><blockquote><p>还不明白可以去写个小demo就懂啦。</p></blockquote><p>CSS代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTML代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;avatar.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果图：</p><img src="/posts/4281072405.html/marginauto.png" style="zoom:60%;"><h2 id="方法四：table-cell法"><a href="#方法四：table-cell法" class="headerlink" title="方法四：table-cell法"></a>方法四：table-cell法</h2><p>这应该算是很老的方法了吧，我没有这么写过。是在百度上搜索得到的结果，完后尝试写了一下。</p><blockquote><p>有个问题，因为按照理解，我觉得img里不加那个应该也是居中的，但是我加了之后在浏览器调试发现，他向上偏移了一些肉眼大概数不出来的距离，在img里加上之后才消失，不知道为什么，希望有大佬可以告知。</p></blockquote><p>CSS代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">   <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTML代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;avatar.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果图：</p><img src="/posts/4281072405.html/marginauto.png" style="zoom:60%;"><h2 id="方法五：translate-50-50"><a href="#方法五：translate-50-50" class="headerlink" title="方法五：translate(-50%,-50%)"></a>方法五：translate(-50%,-50%)</h2><p>translate()函数可以将元素向指定的方向移动，我们可以利用它来做成与方法三相同的事情。</p><p>CSS代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">   <span class="attribute">position</span>: absolute;</span><br><span class="line">   <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">   <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">   <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTML代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;avatar.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果图：</p><img src="/posts/4281072405.html/marginauto.png" style="zoom:60%;"><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>说一下我自己的感受吧，这一共是五种方法，我用过1、2、3、5，其中2和5我用的较多，又以2为最多。</p><p>日后如果见到还有别的，也会记录在此的。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天来看看一个之前困扰我很久的问题，在CSS中，水平垂直居中，能有几种写法。&lt;/p&gt;
&lt;h2 id=&quot;方法一：margin-auto&quot;&gt;&lt;a href=&quot;#方法一：margin-auto&quot; class=&quot;headerlink&quot; title=&quot;方法一：margin:auto&quot;&gt;&lt;/a&gt;方法一：margin:auto&lt;/h2&gt;&lt;p&gt;子绝父相，当元素绝对定位的时候，会根据最近父元素进行定位，利用这个特性，我们有了这种方法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Css" scheme="https://wangenze267.github.io/tags/Css/"/>
    
    <category term="CSS" scheme="https://wangenze267.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>用Node.js做一个本地的石头剪刀布游戏</title>
    <link href="https://wangenze267.github.io/posts/2316163776.html/"/>
    <id>https://wangenze267.github.io/posts/2316163776.html/</id>
    <published>2021-10-02T15:59:41.000Z</published>
    <updated>2021-10-11T05:25:45.840Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前一段日子学了个石头剪刀布游戏，自己在本地进行了实现，想挂在自己服务器上让他形成一个外网可访问的游戏的时候，出了问题，是接口请求路径不对的问题，现在还不知道什么原因，等解决之后我还会更一下。</p><span id="more"></span><h3 id="所需要准备的"><a href="#所需要准备的" class="headerlink" title="所需要准备的"></a>所需要准备的</h3><ul><li>Node.js环境（没有的可以去官网下一下，傻瓜式安装就好）</li><li>基础的html、css、js能力</li><li>入门级的Node.js就好（因为我也是这个级别）</li><li>一个你熟悉的代码编写工具</li></ul><h3 id="开始上手操作"><a href="#开始上手操作" class="headerlink" title="开始上手操作"></a>开始上手操作</h3><p>首先我们需要一个html页面来作游戏结果的返回以及玩家操作。</p><p><strong>需求分析：</strong></p><ul><li>我们需要一个地方来做游戏结果的返回</li><li>还需要三个按钮来给用户做操作交互</li></ul><p>下面来看<code>index.html</code>文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;output&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 400px; width: 600px; background: #eee&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;rock&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 40px; width: 80px&quot;</span>&gt;</span>石头<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;scissor&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 40px; width: 80px&quot;</span>&gt;</span>剪刀<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;paper&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 40px; width: 80px&quot;</span>&gt;</span>布<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我定义了一个<code>div</code>，来作为显示游戏结果的地方，定义了三个按钮，分别代表剪刀、石头、布。</p><p>接下来我们应该做的就是通过接口的方式，提交我们用户的操作并且获取游戏结果，将他显示在刚刚的<code>div</code>里。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $button = &#123;</span><br><span class="line">        <span class="attr">rock</span>: <span class="built_in">document</span>.getElementById(<span class="string">&#x27;rock&#x27;</span>),</span><br><span class="line">        <span class="attr">scissor</span>: <span class="built_in">document</span>.getElementById(<span class="string">&#x27;scissor&#x27;</span>),</span><br><span class="line">        <span class="attr">paper</span>: <span class="built_in">document</span>.getElementById(<span class="string">&#x27;paper&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> $output = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;output&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys($button).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    $button[key].addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        fetch(<span class="string">`http://<span class="subst">$&#123;location.host&#125;</span>/game?action=<span class="subst">$&#123;key&#125;</span>`</span>)</span><br><span class="line">            .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> res.text()</span><br><span class="line">            &#125;)</span><br><span class="line">            .then(<span class="function">(<span class="params">text</span>) =&gt;</span> &#123;</span><br><span class="line">                $output.innerHTML += text + <span class="string">&#x27;&lt;br/&gt;&#x27;</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>之后我们去建立一个<code>game.js</code>文件，写一下游戏的判断逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">palyerAction</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>([<span class="string">&#x27;rock&#x27;</span>,<span class="string">&#x27;scissor&#x27;</span>,<span class="string">&#x27;paper&#x27;</span>].indexOf(palyerAction) == -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;invalid playerAction&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算出电脑出的结果</span></span><br><span class="line">    <span class="keyword">var</span> computerAction;</span><br><span class="line">    <span class="keyword">var</span> random = <span class="built_in">Math</span>.random() * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(random &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        computerAction = <span class="string">&quot;rock&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(random &gt; <span class="number">2</span>)&#123;</span><br><span class="line">        computerAction = <span class="string">&quot;scissor&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        computerAction = <span class="string">&quot;paper&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(computerAction == palyerAction)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(</span><br><span class="line">        (computerAction == <span class="string">&quot;rock&quot;</span> &amp;&amp; palyerAction == <span class="string">&quot;scissor&quot;</span>) ||</span><br><span class="line">        (computerAction == <span class="string">&quot;scissor&quot;</span> &amp;&amp; palyerAction == <span class="string">&quot;paper&quot;</span>) ||</span><br><span class="line">        (computerAction == <span class="string">&quot;paper&quot;</span> &amp;&amp; palyerAction == <span class="string">&quot;rock&quot;</span>)</span><br><span class="line">    )&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致的逻辑很简单，通过随机数让电脑出拳，之后判断胜负并返回。</p><p>下面看一下用<code>node.js</code>写的简单交互的地方：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> game = <span class="built_in">require</span>(<span class="string">&#x27;./game&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> playerWon = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> playerLastAction = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> sameCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">http</span><br><span class="line">    .createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> parsedUrl = url.parse(request.url);</span><br><span class="line">        <span class="keyword">if</span> (parsedUrl.pathname == <span class="string">&#x27;/favicon.ico&#x27;</span>) &#123;</span><br><span class="line">            response.writeHead(<span class="number">200</span>);</span><br><span class="line">            response.end();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parsedUrl.pathname == <span class="string">&#x27;/game&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> query = querystring.parse(parsedUrl.query);</span><br><span class="line">            <span class="keyword">const</span> playerAction = query.action;</span><br><span class="line">            <span class="keyword">if</span> (playerWon &gt;= <span class="number">3</span> || sameCount == <span class="number">9</span>) &#123;</span><br><span class="line">                response.writeHead(<span class="number">500</span>);</span><br><span class="line">                response.end(<span class="string">&#x27;我再也不和你玩了！&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (playerLastAction &amp;&amp; playerAction == playerLastAction) &#123;</span><br><span class="line">                sameCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sameCount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            playerLastAction = playerAction</span><br><span class="line">            <span class="keyword">if</span> (sameCount &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                response.writeHead(<span class="number">400</span>);</span><br><span class="line">                response.end(<span class="string">&#x27;你作弊！&#x27;</span>);</span><br><span class="line">                sameCount = <span class="number">9</span>;</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行游戏逻辑</span></span><br><span class="line">            <span class="keyword">const</span> gameResult = game(playerAction);</span><br><span class="line">            <span class="comment">// 先返回头部</span></span><br><span class="line">            response.writeHead(<span class="number">200</span>);</span><br><span class="line">            <span class="comment">// 根据不同的游戏结果返回不同的说明</span></span><br><span class="line">            <span class="keyword">if</span> (gameResult == <span class="number">0</span>) &#123;</span><br><span class="line">                response.end(<span class="string">&#x27;平局！&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gameResult == <span class="number">1</span>) &#123;</span><br><span class="line">                response.end(<span class="string">&#x27;你赢了！&#x27;</span>);</span><br><span class="line">                <span class="comment">// 玩家胜利次数统计+1</span></span><br><span class="line">                playerWon++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                response.end(<span class="string">&#x27;你输了！&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果访问的是根路径，则把游戏页面读出来返回出去</span></span><br><span class="line">        <span class="keyword">if</span> (parsedUrl.pathname == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            fs.createReadStream(__dirname + <span class="string">&#x27;/index.html&#x27;</span>).pipe(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><p>在cmd窗口中输入<code>node index.js</code>就可以在浏览器的<code>localhost:3000</code>端口中看见这个游戏啦！</p><blockquote><p>有一些node基础的同学们应该看起来很容易，毕竟我也不咋会emm。</p></blockquote><p>那，来看一下效果吧。</p><blockquote><p>没有做丝毫美化，实在是懒欸。</p></blockquote><p><img src="/posts/2316163776.html/%E7%9F%B3%E5%A4%B4%E5%89%AA%E5%88%80%E5%B8%831.gif"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>日后想优化一下，挂到自己服务器上，嘿嘿，好歹是自己做的第一个小游戏~</p><blockquote><p>大家有什么好的建议嘛~</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;前一段日子学了个石头剪刀布游戏，自己在本地进行了实现，想挂在自己服务器上让他形成一个外网可访问的游戏的时候，出了问题，是接口请求路径不对的问题，现在还不知道什么原因，等解决之后我还会更一下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Node.js" scheme="https://wangenze267.github.io/tags/Node-js/"/>
    
    <category term="经历" scheme="https://wangenze267.github.io/tags/%E7%BB%8F%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript数组去重问题</title>
    <link href="https://wangenze267.github.io/posts/1826147754.html/"/>
    <id>https://wangenze267.github.io/posts/1826147754.html/</id>
    <published>2021-10-01T08:27:02.536Z</published>
    <updated>2021-10-11T05:22:18.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这应该是一个很常见的问题了，既然是常见的，那我们就更应该来学习一下！</p><h2 id="开始研究"><a href="#开始研究" class="headerlink" title="开始研究"></a>开始研究</h2><h3 id="原始"><a href="#原始" class="headerlink" title="原始"></a>原始</h3><p>数组去重，最开始我的思路是这样：定义一个新数组，完后两层for循环，如果数据第一次出现，就push到新数组里，如果重复就break掉，利用j的值与res长度相等这一点来判断数据唯一，最后返回新数组就行了。</p><span id="more"></span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">8</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;66&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> res = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; res.length; j ++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i] === res[j])&#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果数据第一次出现，那么执行完上面for语句后，j的值应该等于res的长度才对</span></span><br><span class="line"><span class="keyword">if</span>(j === res.length)&#123;</span><br><span class="line">res.push(arr[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br></pre></td></tr></table></figure><h3 id="利用indexOf优化原始方法"><a href="#利用indexOf优化原始方法" class="headerlink" title="利用indexOf优化原始方法"></a>利用indexOf优化原始方法</h3><p>我们先来简单了解一下indexOf：</p><p>indexOf(item,start) 方法可返回数组中某个指定的元素位置。</p><p>该方法将从头到尾地检索数组，看它是否含有对应的元素。开始检索的位置在数组 start 处或数组的开头（没有指定 start 参数时）。如果找到一个 item，则返回 item 的第一次出现的位置。开始位置的索引为 0。</p><p><strong>如果在数组中没找到指定元素则返回 -1。</strong></p><p>看到这大家都明白我们利用的是哪一点了吧，没错，就是加粗的那一句话：<strong>如果在数组中没找到指定元素则返回 -1。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">8</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;66&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> res = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(res.indexOf(arr[i]) === -<span class="number">1</span>)&#123;</span><br><span class="line">res.push(arr[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br></pre></td></tr></table></figure><h3 id="再次优化，filter方法！"><a href="#再次优化，filter方法！" class="headerlink" title="再次优化，filter方法！"></a>再次优化，filter方法！</h3><p>filter，顾名思义，过滤的意思，该方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</p><p>思路：用filter代替一层循环与indexOf配合，达到过滤效果，直接返回去重过后的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">8</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;66&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> res = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> arr.indexOf(item) === index</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br></pre></td></tr></table></figure><h3 id="换种思路？变成有序数组？"><a href="#换种思路？变成有序数组？" class="headerlink" title="换种思路？变成有序数组？"></a>换种思路？变成有序数组？</h3><p>不知道刷过几天力扣的小伙伴们有没有这种感觉，看见题目中出现数组，眼睛就立刻往前瞄了瞄，看看是有序数组还是无序数组~</p><p>回到这个问题上，我们将要去重的数组变成有序，重复的数据肯定都挨着了，用一个变量存放上一个元素值，再循环判断当前值与上一个元素值是否相同，如果不相同，就将它添加到res中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">8</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;66&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> res = []</span><br><span class="line"><span class="keyword">var</span> pre</span><br><span class="line">arr = arr.sort()</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!i || pre !== arr[i])&#123;</span><br><span class="line">res.push(arr[i])</span><br><span class="line">&#125;</span><br><span class="line">pre = arr[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br></pre></td></tr></table></figure><h3 id="再再次优化，filter！"><a href="#再再次优化，filter！" class="headerlink" title="再再次优化，filter！"></a>再再次优化，filter！</h3><p>刚刚悟了~，filter好像也可以把排序这里重写一下，变得更为简洁，我们直接看代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">8</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;66&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> res = arr.sort().filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> !index || item !== arr[index - <span class="number">1</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br></pre></td></tr></table></figure><h3 id="ES6，Set来袭！"><a href="#ES6，Set来袭！" class="headerlink" title="ES6，Set来袭！"></a>ES6，Set来袭！</h3><p>ES6给我们带来了很多好处，其中，map、set尤为优秀。</p><p>Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。</p><p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</p><p>所以我们可以利用Set的这一特性，来进行去重处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">8</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;66&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br></pre></td></tr></table></figure><p>注：Set是对象，所以要转成数组进行返回。</p><h4 id="懂解构赋值的你，可以再简化一点"><a href="#懂解构赋值的你，可以再简化一点" class="headerlink" title="懂解构赋值的你，可以再简化一点"></a>懂解构赋值的你，可以再简化一点</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">8</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;66&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> [...new <span class="built_in">Set</span>(arr)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br></pre></td></tr></table></figure><blockquote><p>想了解一下解构赋值的也可以先康康这个：<a href="https://blog.wangez.site/posts/1586874348.html/">解构运算符的理解与运用 </a></p><p>之前学习，记录的笔记🎨</p></blockquote><h4 id="继续优秀下去（箭头函数）"><a href="#继续优秀下去（箭头函数）" class="headerlink" title="继续优秀下去（箭头函数）"></a>继续优秀下去（箭头函数）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">8</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;66&#x27;</span>]</span><br><span class="line"><span class="keyword">var</span> unique = <span class="function">(<span class="params">arr</span>) =&gt;</span> [...new <span class="built_in">Set</span>(arr)]</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>从最开始的好几行代码，到最后利用箭头函数，可以一行就写完，足以见得，JavaScript是在逐渐变得更好。</p><p>那我们，作为开发者，也要努力学习，才能更好的去使用这门语言呀🎈</p><blockquote><p>学无止境，不是说说而已。</p><p>点个赞，我们一起学习进步吧~</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这应该是一个很常见的问题了，既然是常见的，那我们就更应该来学习一下！&lt;/p&gt;
&lt;h2 id=&quot;开始研究&quot;&gt;&lt;a href=&quot;#开始研究&quot; class=&quot;headerlink&quot; title=&quot;开始研究&quot;&gt;&lt;/a&gt;开始研究&lt;/h2&gt;&lt;h3 id=&quot;原始&quot;&gt;&lt;a href=&quot;#原始&quot; class=&quot;headerlink&quot; title=&quot;原始&quot;&gt;&lt;/a&gt;原始&lt;/h3&gt;&lt;p&gt;数组去重，最开始我的思路是这样：定义一个新数组，完后两层for循环，如果数据第一次出现，就push到新数组里，如果重复就break掉，利用j的值与res长度相等这一点来判断数据唯一，最后返回新数组就行了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://wangenze267.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>都2021年了，节流是不是也应该了解一下了</title>
    <link href="https://wangenze267.github.io/posts/335803086.html/"/>
    <id>https://wangenze267.github.io/posts/335803086.html/</id>
    <published>2021-09-29T10:44:42.000Z</published>
    <updated>2021-10-11T05:22:56.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天发了有关防抖的文章，很多人都问为啥节流不一起写了呢？这当然是因为昨天那个是上实验课摸鱼写的，节流不没摸出来嘛，嘿嘿。</p><p>不过不要慌，节流，它来了！</p><p>个人理解：节流的作用与防抖相似，都是为了限制事件的频繁触发。</p><span id="more"></span><h2 id="如何实现节流"><a href="#如何实现节流" class="headerlink" title="如何实现节流"></a>如何实现节流</h2><p>实现节流，就要先了解节流的原理。</p><p>节流就是，在一定的时间内，只执行一次事件。</p><p>或者说是，每隔一段时间，只执行一次事件。</p><blockquote><p>要与防抖做一下区分哦~</p><p>防抖是，不管你触发了几次，我只看你最后触发的那一次，并且在若干时间后去执行此次事件。</p></blockquote><p>我了解到的节流，有两种方式，分别是<strong>时间戳</strong>与<strong>定时器</strong>。</p><p>那么我们来实现一下看看吧~</p><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>使用时间戳，当触发事件的时候，我们记录当前的时间戳，然后减去之前记录的时间戳(最一开始值一定不要忘了设为 0 )，如果大于设置的时间周期(也就是那个间隔的时间段)，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。</p><p>看完是不是觉得很简单？那我们来写一下。</p><blockquote><p>具体的例子还是使用防抖的那个，懒得再写一个啦，嘿嘿~   将防抖函数换成节流就可</p><p>防抖文章链接：<a href="https://blog.wangez.site/posts/647457095.html">都2021年了，不会还有人不知道防抖吧？</a></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">todo, time</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (now - pre &gt; time) &#123;</span><br><span class="line">            todo.apply(that);</span><br><span class="line">            pre = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的话还是跟之前相同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = throttle(shake,<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>为什么设置3000，当然想让效果看起来明显一些，下面来看看效果吧：</p><p><img src="/posts/335803086.html/%E6%97%B6%E9%97%B4%E6%88%B3%E8%8A%82%E6%B5%81.gif"></p><p>好了好了，别在心里数123了，我们接着往下来。</p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。</p><p>上代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">todo, time</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout,that;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">                todo.apply(that)</span><br><span class="line">            &#125;, time)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看效果：</p><p><img src="/posts/335803086.html/%E5%AE%9A%E6%97%B6%E5%99%A8%E8%8A%82%E6%B5%81.gif"></p><p>可以看出，它是过了3s才生效的，但是不知道为什么，这种方式给我的体验感不是很好，可能是因为不是点击的下一刻就有了反馈吧~</p><blockquote><p>这块要加上一个过渡动画，是不是会好很多？</p></blockquote><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>既然有两种方法，那就要说一下他们的区别。</p><p>第一种：在例子中可以清楚的看到，点击触发后立即有反馈（执行第一次），连续触发直到过了等待时间才会进行下一次执行，停止触发就不会执行。</p><p>第二种：过了等待时间才会执行第一次，停止触发还会执行一次。</p><p>在网上看到了这样的形容词：<strong>有头无尾，和无头有尾</strong>，是不是很形象。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>啊，终于结束了！还是那句话，可能我想到的或者写的不是很完善，希望大家能够指出，我会及时更正哒。</p><blockquote><p>要是以后的我觉得某处可以优化，也会回来更新的！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;昨天发了有关防抖的文章，很多人都问为啥节流不一起写了呢？这当然是因为昨天那个是上实验课摸鱼写的，节流不没摸出来嘛，嘿嘿。&lt;/p&gt;
&lt;p&gt;不过不要慌，节流，它来了！&lt;/p&gt;
&lt;p&gt;个人理解：节流的作用与防抖相似，都是为了限制事件的频繁触发。&lt;/p&gt;</summary>
    
    
    
    
    <category term="ES6" scheme="https://wangenze267.github.io/tags/ES6/"/>
    
    <category term="JavaScript" scheme="https://wangenze267.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>都2021年了，你还不会防抖吗？</title>
    <link href="https://wangenze267.github.io/posts/647457095.html/"/>
    <id>https://wangenze267.github.io/posts/647457095.html/</id>
    <published>2021-09-28T08:12:44.000Z</published>
    <updated>2021-10-11T05:23:00.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在我们写项目遇到不听话的用户的时候，例如一个登录按钮，他就偏偏要反复点好几次，调用了<code>/login</code>接口好多次，是不是很烦？</p><p>因为涉及到ajax请求，就会有这样的情况，假设 1 秒触发了 60 次，每个回调就必须在 1000 / 60 = 16.67ms 内完成，否则就会有卡顿出现。</p><p>那么只有请求需要写防抖吗？</p><p>当然不是，凡是（可能）涉及到频繁事件触发的地方，都需要写防抖。</p><span id="more"></span><blockquote><ol><li>window 的 resize、scroll</li><li>mousedown、mousemove</li><li>keyup、keydown</li><li>click事件</li><li>……</li></ol></blockquote><p>我们简单的写一个小demo，看一下没有防抖跟有防抖的效果。</p><p>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// html</span></span><br><span class="line">&lt;button id=<span class="string">&quot;btn&quot;</span> onclick=<span class="string">&quot;shake()&quot;</span>&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shake</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    container.innerHTML = count++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p><img src="/posts/647457095.html/%E6%9C%AA%E9%98%B2%E6%8A%96.gif"></p><hr><h2 id="如何实现防抖"><a href="#如何实现防抖" class="headerlink" title="如何实现防抖"></a>如何实现防抖</h2><p>实现防抖，就要了解防抖的原理。</p><p>防抖就是，不管你触发了几次，我只看你最后触发的那一次，并且在若干时间后去执行此次事件。</p><p>根据这个原理，我们可以写出这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preventShake</span>(<span class="params">todo,time</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(todo, time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置一个延迟操作的事件，并且如果再次触发就把之前的延迟取消掉，重新进入计时。</p><p>将它运用在刚刚的例子上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shake</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    container.innerHTML = count++;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preventShake</span>(<span class="params">todo,time</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(todo, time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">btn.onclick = preventShake(shake,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><hr><p><img src="/posts/647457095.html/%E9%98%B2%E6%8A%96%E6%9C%AA%E4%BC%98%E5%8C%96.gif"></p><hr><p>我们已经实现了基础的它，那么我们继续优化一下吧！</p><h2 id="this指向优化"><a href="#this指向优化" class="headerlink" title="this指向优化"></a>this指向优化</h2><p>看似上面的结果没有什么太大问题，但是我们打印一下原先的<code>shake</code>和使用了<code>preventShake</code>后的this就会知道，他们指向的并不是一个东西。</p><ul><li><p>原先指向的是</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用了<code>preventShake</code>后this指向的是<strong>Window</strong>对象！</p></li></ul><p>于是我们要加一步，就是改变this指向。</p><blockquote><p>欸，这个是不是又是一篇文章？？</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preventShake</span>(<span class="params">todo,time</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            todo.apply(that);</span><br><span class="line">        &#125;, time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就解决了this指向可能带来的问题。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>至此，这个简易的防抖函数就写完了，可能我想的还不太完善，希望大家给予建议，我也会及时学习，之后将其完善，争取做的更好。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在我们写项目遇到不听话的用户的时候，例如一个登录按钮，他就偏偏要反复点好几次，调用了&lt;code&gt;/login&lt;/code&gt;接口好多次，是不是很烦？&lt;/p&gt;
&lt;p&gt;因为涉及到ajax请求，就会有这样的情况，假设 1 秒触发了 60 次，每个回调就必须在 1000 / 60 = 16.67ms 内完成，否则就会有卡顿出现。&lt;/p&gt;
&lt;p&gt;那么只有请求需要写防抖吗？&lt;/p&gt;
&lt;p&gt;当然不是，凡是（可能）涉及到频繁事件触发的地方，都需要写防抖。&lt;/p&gt;</summary>
    
    
    
    
    <category term="ES6" scheme="https://wangenze267.github.io/tags/ES6/"/>
    
    <category term="JavaScript" scheme="https://wangenze267.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>快速了解ES6模块化少不了这篇文章</title>
    <link href="https://wangenze267.github.io/posts/3892826279.html/"/>
    <id>https://wangenze267.github.io/posts/3892826279.html/</id>
    <published>2021-09-27T08:04:47.960Z</published>
    <updated>2021-10-11T05:21:43.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在之前的JavaScript中是没有模块化概念的，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。如果要进行模块化操作，就需要引入第三方的类库。随着技术的发展，前后端分离，前端的业务变的越来越复杂化，于是才有了ES6模块化的诞生。</p><p>为什么要有模块化，或者模块化的好处是什么呢？</p><blockquote><p> 大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块间的相互调用，利人利己。</p><p> 可以将一段复杂的程序拆解开来，方便维护可拓展。</p></blockquote><span id="more"></span><h2 id="前端模块化规范"><a href="#前端模块化规范" class="headerlink" title="前端模块化规范"></a>前端模块化规范</h2><p>在<strong>ES6模块化</strong>诞生之前，JavaScript社区尝试并提出了<strong>AMD、CMD、commonJS</strong>等模块化规范。</p><p>但是，这些模块化规范，存在一定的差异性与局限性，并不能通用。</p><p>例如：</p><ul><li><p>AMD和CMD适用于浏览器端的JavaScript模块化</p></li><li><p>commonJS适用于服务器端的JavaScript模块化</p><blockquote><p>Node.js 就是遵循的这个规范</p><p>导入其它模块使用require()</p><p>导出使用module.exports对象</p></blockquote></li></ul><p>太多的模块化规范给开发者增加了学习的难度与开发的成本。所以，ES6模块化规范诞生了！</p><h3 id="什么是ES6模块化规范"><a href="#什么是ES6模块化规范" class="headerlink" title="什么是ES6模块化规范"></a>什么是ES6模块化规范</h3><p>ES6模块化规范是浏览器端与服务端通用的模块化开发规范。它的出现极大的降低了前端开发者的模块化学习成本，开发者不需要在额外学习AMD、CMD或者commonJS等模块化规范。</p><p>ES6中模块化规范中定义：</p><ul><li>每个js文件都是一个独立的模块</li><li>导入其他模块成员使用<code>import</code>关键字</li><li>向外共享模块成员使用<code>export</code>关键字</li></ul><h2 id="在node-js中体验ES6模块化"><a href="#在node-js中体验ES6模块化" class="headerlink" title="在node.js中体验ES6模块化"></a>在node.js中体验ES6模块化</h2><p>node.js中默认仅支持commonJS模块化规范，若想在node中进行体验，要按照如下两步骤进行配置：</p><ul><li><p>确保安装了<code>v14.15.1</code>或者更高版本的node.js</p><blockquote><p>可以使用在cmd窗口中使用<code>node -v</code>命令查看当前版本号哦~</p></blockquote></li><li><p>在package.json的根节点中添加<code>&quot;type&quot;:&quot;module&quot;</code>节点</p><blockquote><p>不知道如何添加的小伙伴看这里：</p><p>首先我们要在一个空文件夹内，执行<code>npm init -y</code>，这时候我们就能看见已经自动生成了<code>package.json</code>文件了</p><p>完后在vs-code打开，在内添加<code>&quot;type&quot;:&quot;module&quot;</code>节点即可</p><p>小提示：type值默认为commonJS，所以我们平时node遵循的模块化规范都是commonJS</p></blockquote></li></ul><h2 id="ES6模块化的基本语法"><a href="#ES6模块化的基本语法" class="headerlink" title="ES6模块化的基本语法"></a>ES6模块化的基本语法</h2><p>ES6的模块化主要包含如下3种用法：</p><ul><li>默认导出与默认导入</li><li>按需导出与按需导入</li><li>直接导入并执行模块中的代码</li></ul><h3 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h3><p>语法：<code>export default</code> <font color="nred">默认导出的成员</font></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n1 = <span class="number">10</span> <span class="comment">// 定义模块私有成员 n1</span></span><br><span class="line"><span class="keyword">let</span> n2 = <span class="number">20</span> <span class="comment">// 定义模块私有成员 n2 因为没有共享出去，所以外界访问不到</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 定义模块私有方法 show</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; <span class="comment">// 使用export default 默认导出语法 向外共享n1 和 show 两个成员</span></span><br><span class="line">n1,</span><br><span class="line">    show</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><p>每个模块中，只允许用唯一的一次 <code>export default</code>，否则会报错！</p><h3 id="默认导入"><a href="#默认导入" class="headerlink" title="默认导入"></a>默认导入</h3><p>语法：<code>import</code><font color="nred">接收名称</font><code>form</code><font color="nred">模块标识符</font></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 m1.js 模块中导入 export default 向外共享的成员</span></span><br><span class="line"><span class="comment">// 并使用 m1 进行接收</span></span><br><span class="line"><span class="keyword">import</span> m1 form <span class="string">&#x27;./m1.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(m1)</span><br><span class="line"><span class="comment">// 输出为: &#123; n1: 10, show: [Function:show]&#125;</span></span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><p>默认导入的时候，接收名字可以任意写，注意是合法的成员名称就行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m1 合法 不报错</span></span><br><span class="line"><span class="keyword">import</span> m1 form <span class="string">&#x27;./m1.js&#x27;</span></span><br><span class="line"><span class="comment">// 成员名称不能用数字开头，所以会直接报错</span></span><br><span class="line"><span class="keyword">import</span> <span class="number">123</span> form <span class="string">&#x27;./m1.js&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="按需导出"><a href="#按需导出" class="headerlink" title="按需导出"></a>按需导出</h3><p>语法：<code>export</code><font color="nred">按需导出的成员</font></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向外按需导出变量 s</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> s = <span class="string">&#x27;Ned&#x27;</span></span><br><span class="line"><span class="comment">// 向外按需导出方法 show</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="按需导入"><a href="#按需导入" class="headerlink" title="按需导入"></a>按需导入</h3><p>语法：<code>import &#123;s&#125; from</code><font color="nred">模块标识符 </font></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; s, show &#125; form <span class="string">&#x27;./m1.js&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(s) <span class="comment">// Ned</span></span><br><span class="line"><span class="built_in">console</span>.log(show) <span class="comment">// [Function: show]</span></span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li>每个模块中可以使用多次按需导出</li><li>按需导入的成员名称必须跟按需导出的名称一致</li><li>按需导入时，可以使用<code>as</code>关键字进行重命名</li><li>按需导入可以和默认导入一起使用</li></ul><p>重命名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; s <span class="keyword">as</span> str &#125; form <span class="string">&#x27;./m1.js&#x27;</span></span><br></pre></td></tr></table></figure><p>使用as关键字，将s重命名为str，所以接下来我们使用str就好了，不能再使用s这个名字。</p><p>按需导入和默认导入一起使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> info,&#123; s <span class="keyword">as</span> str &#125; form <span class="string">&#x27;./m1.js&#x27;</span></span><br></pre></td></tr></table></figure><p>info就是默认导入，后面带大括号的就是按需导入。</p><h3 id="直接导入并执行模块中的代码"><a href="#直接导入并执行模块中的代码" class="headerlink" title="直接导入并执行模块中的代码"></a>直接导入并执行模块中的代码</h3><p>如果只想单纯的执行某个模块中的代码，并不需要得到其内部向外共享的成员，可以这样做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m1.js:</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line">-------------------------</span><br><span class="line"><span class="comment">// 直接导入并执行模块中的代码</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./m1.js&#x27;</span></span><br></pre></td></tr></table></figure><p>没错，就是直接导入即可。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这篇文章简单介绍一下模块化的概念和语法，过几天我还会出一篇文章来告诉大家模块化在实际应用里是如何使用的。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在之前的JavaScript中是没有模块化概念的，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。如果要进行模块化操作，就需要引入第三方的类库。随着技术的发展，前后端分离，前端的业务变的越来越复杂化，于是才有了ES6模块化的诞生。&lt;/p&gt;
&lt;p&gt;为什么要有模块化，或者模块化的好处是什么呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块间的相互调用，利人利己。&lt;/p&gt;
&lt;p&gt; 可以将一段复杂的程序拆解开来，方便维护可拓展。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="ES6" scheme="https://wangenze267.github.io/tags/ES6/"/>
    
  </entry>
  
</feed>
